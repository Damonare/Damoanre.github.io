<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Damonare的个人博客</title>
  <subtitle>不念过去，不畏将来</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://damonare.github.io/"/>
  <updated>2017-05-26T16:03:13.000Z</updated>
  <id>http://damonare.github.io/</id>
  
  <author>
    <name>Damonare</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我的前端进阶之路</title>
    <link href="http://damonare.github.io/2017/04/24/%E6%88%91%E7%9A%84%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"/>
    <id>http://damonare.github.io/2017/04/24/我的前端进阶之路/</id>
    <published>2017-04-24T12:57:34.000Z</published>
    <updated>2017-05-26T16:03:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 包含这三个月来碰到的一些觉得比较好的面试题，三个月没怎么写博客着实有些手痒，哈哈哈。</p>
<ul>
<li><p>原文地址：<a href="http://damonare.github.io/2017/04/24/%E6%88%91%E7%9A%84%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/#more">我的前端进阶之路</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>烈火试真金，逆境试强者</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="React和Vue对比"><a href="#React和Vue对比" class="headerlink" title="React和Vue对比"></a>React和Vue对比</h4><p>相同点:</p>
<ol>
<li>数据驱动视图，提供响应式的视图组件</li>
<li>都有Virtual DOM，组件化开发，通过props参数进行父子组件数据的传递，都实现webComponents规范</li>
<li>数据流动单向</li>
<li>都支持服务端渲染</li>
<li>都有支持native的方案，React的<code>React native</code>，Vue的<code>weex</code></li>
</ol>
<p>不同点：</p>
<ol>
<li><p>社区：React社区还是要比vue大很多；</p>
</li>
<li><p>开发模式：React在view层侵入性还是要比Vue大很多的,React严格上只针对MVC的view层，Vue则是MVVM模式的一种实现；</p>
</li>
<li><p>数据绑定：Vue有实现了双向数据绑定，React数据流动是单向的</p>
</li>
<li><p>数据渲染：对于大规模数据渲染，React要比Vue更快，渲染机制启动时候要做的工作比较多；</p>
</li>
<li><p>数据更新方面：Vue 由于采用依赖追踪，默认就是优化状态：你动了多少数据，就触发多少更新，不多也不少。React在复杂的应用里有两个选择:</p>
<p>(1). 手动添加 shouldComponentUpdate 来避免不需要的 vdom re-render。<br>(2). Components 尽可能都用 pureRenderMixin，然后采用 redux 结构 + Immutable.js；</p>
</li>
<li><p>开发风格的偏好：React 推荐的做法是 JSX + inline style，也就是把 HTML 和 CSS 全都写进 JavaScript 了，即”all in js”；Vue进阶之后推荐的是使用 webpack + vue-loader 的单文件组件格式，即html,css,js写在同一个文件；</p>
</li>
<li><p>使用场景：React配合Redux架构适合超大规模多人协作的复杂项目;Vue则适合小快灵的项目。对于需要对 DOM 进行很多自定义操作的项目，Vue 的灵活性优于 React；</p>
</li>
<li><p>Vue要比React更好上手，具体可能体现在很多人不熟悉React的JSX语法和函数式编程的思想，以及想要发挥出React的最大威力需要学习它一系列生态的缘故；</p>
</li>
<li><p>Vue着重提高开发效率,让前端程序员更快速方便的开发应用。React着重于变革开发思想，提升前端程序员编程的深度与创造力,让前端工程师成为真正的程序员而不是UI的构建者；</p>
</li>
</ol>
<h4 id="gulp和webpack区别"><a href="#gulp和webpack区别" class="headerlink" title="gulp和webpack区别"></a>gulp和webpack区别</h4><ol>
<li>gulp是一种工具，我们可以用它来优化前端的工作流程，比如自动刷新页面、combo、压缩css、js、编译less等等。具体体现为：在gulp的配置文件中书写一个个的task，webpack则是一种打包工具，或者说是一种模块化解决方案，实际上很大一部分人刚开始使用webpack的方式就是通过gulp-webpack这个插件，写好task来使用webpack对前端的一些文件进行打包;</li>
<li>gulp的处理任务需要自己去写，webpack则有现成的解决方案，只需要在webpack.config.js配置好即可;</li>
</ol>
<h4 id="防止重复发送Ajax请求"><a href="#防止重复发送Ajax请求" class="headerlink" title="防止重复发送Ajax请求"></a>防止重复发送Ajax请求</h4><ol>
<li>用户点击之后按钮disabled;</li>
<li>函数节流</li>
<li>abort掉上一个请求。</li>
</ol>
<h4 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h4><ul>
<li>事件捕获阶段(capturing phase)。事件从document一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</li>
<li>事件处理阶段(target phase)。事件到达目标元素, 触发目标元素的监听函数。</li>
<li>事件冒泡阶段(bubbling phase)。事件从目标元素冒泡到document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</li>
</ul>
<h4 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h4><ol>
<li>Expires策略</li>
</ol>
<p>Expires是Web服务器响应消息头字段，在响应http请求时告诉<strong>浏览器在过期时间前</strong>浏览器可以直接从浏览器缓存取数据，而无需再次请求。Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。</p>
<ol>
<li>Cache-Control策略</li>
</ol>
<p>Cache-Control与Expires的作用一致，都是指明当前资源的<strong>有效期</strong>，控制浏览器是否直接从浏览器缓读取数据还是重新发请求到服务器取数据。只不过Cache-Control的<strong>选择更多，设置更细致</strong>，如果同时设置的话，其<strong>优先级高于Expires</strong>。</p>
<p>以上是设置缓存时间的两种方法。那么当缓存时间过了咋整呢？有人肯定说了，那就再次发起请求啊，这是对的。问题是如果服务器资源并没有更新呢？比如说我有一个<code>jQuery.js</code>文件已经缓存了，当它的缓存时间到了之后服务器的<code>jQuery.js</code>文件也没有更新，那实际上我们直接使用本地缓存的文件就可以啊！没必要浪费带宽和时间去重新请求一个新的文件啊！这时候我们就需要再进一步看一下HTTP协议里这几个参数的作用了。</p>
<ol>
<li>Last-Modified/If-Modified-Since</li>
</ol>
<p>首先Last-Modified/If-Modified-Since要配合Cache-Control使用。</p>
<ul>
<li>Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间(这个参数是和Cache-Control一起过来的)。</li>
<li>If-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 <strong>If-Modified-Since</strong>，表示请求时间。<strong>web服务器收到请求后发现有头If-Modified-Since ，则与被请求资源的最后修改时间进行比对</strong>。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。</li>
</ul>
<ol>
<li>ETag/If-None-Match</li>
</ol>
<p>Etag/If-None-Match也要配合Cache-Control使用。</p>
<ul>
<li>Etag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器觉得）。<em>Apache</em>中，ETag的值，<strong>默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime</strong>）进行<em>Hash</em>后得到的。</li>
<li>If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match（Etag的值）。<strong>web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对</strong>，决定返回200或304。</li>
</ul>
<ol>
<li>ETag和Last-Modified</li>
</ol>
<p>HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p>
<ul>
<li>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</li>
<li>如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存</li>
<li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</li>
</ul>
<p>Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。<strong>Last-Modified</strong>与ETag是可以一起使用的，服务器会优先验证ETag<strong>，一致的情况下，才会继续比对Last-Modified</strong>，最后才决定是否返回304。</p>
<h4 id="Ajax的状态值与HTTP状态码"><a href="#Ajax的状态值与HTTP状态码" class="headerlink" title="Ajax的状态值与HTTP状态码"></a>Ajax的状态值与HTTP状态码</h4><ul>
<li><p>Ajax的状态值</p>
<p>  0: (未初始化)还没有调用open()方法；<br>  1: (载入)已经调用open()方法，正在派发请求，send()方法还未被调用；<br>  2: (载入完成)send()已经调用，响应头和响应状态已经返回；<br>  3: (交互)响应体下载中; responseText中已经获取了部分数据；<br>  4: (完成)响应内容已经解析完成，用户可以调用。</p>
</li>
<li><p>HTTP状态码</p>
<p>200 &amp; OK: 请求成功；</p>
<p>204 &amp; No Content: 请求处理成功，但没有资源可以返回；</p>
<p>206 &amp; Partial Content: 对资源某一部分进行请求(比如对于只加载了一般的图片剩余部分的请求)；</p>
<p>301 &amp; Move Permanently: 永久性重定向；</p>
<p>302 &amp; Found： 临时性重定向；</p>
<p>303 &amp;  See Other: 请求资源存在另一个URI，应使用get方法请求；</p>
<p>304 &amp; Not Modified: 服务器判断本地缓存未更新，可以直接使用本地的缓存；</p>
<p>307 &amp; Temporary Redirect: 临时重定向；</p>
<p>400 &amp; Bad Request: 请求报文存在语法错误；</p>
<p>401 &amp; Unauthorized: 请求需要通过HTTP认证；</p>
<p>403 &amp; Forbidden: 请求资源被服务器拒绝，访问权限的问题；</p>
<p>404 &amp; Not Found: 服务器上没有请求的资源；</p>
<p>500 &amp; Internal Server Error: 服务器执行请求时出现错误；</p>
<p>502 &amp; Bad Gateway: 错误的网关；</p>
<p>503 &amp; Service Unavailable: 服务器超载或正在维护，无法处理请求；</p>
<p>504 &amp; Gateway timeout: 网关超时；</p>
</li>
</ul>
<h4 id="React-router原理"><a href="#React-router原理" class="headerlink" title="React-router原理"></a>React-router原理</h4><p>1.<strong>History</strong></p>
<ul>
<li>老浏览器的history: 主要通过hash来实现，对应<code>createHashHistory</code></li>
<li>高版本浏览器: 通过html5里面的history，对应<code>createBrowserHistory</code></li>
<li>node环境下: 主要存储在memeory里面，对应<code>createMemoryHistory</code></li>
</ul>
<p>内部<code>createHistory</code>实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 内部的抽象实现</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createHistory</span>(<span class="params">options=&#123;&#125;</span>) </span>&#123;</div><div class="line">  ...</div><div class="line">  return &#123;</div><div class="line">    listenBefore, <span class="comment">// 内部的hook机制，可以在location发生变化前执行某些行为，AOP的实现</span></div><div class="line">    listen, <span class="comment">// location发生改变时触发回调</span></div><div class="line">    transitionTo, <span class="comment">// 执行location的改变</span></div><div class="line">    push, <span class="comment">// 改变location</span></div><div class="line">    replace,</div><div class="line">    go,</div><div class="line">    goBack,</div><div class="line">    goForward,</div><div class="line">    createKey, <span class="comment">// 创建location的key，用于唯一标示该location，是随机生成的</span></div><div class="line">    createPath,</div><div class="line">    createHref,</div><div class="line">    createLocation, <span class="comment">// 创建location</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>createLocation</code>方法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createLocation</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    pathname, <span class="comment">// url的基本路径</span></div><div class="line">    search, <span class="comment">// 查询字段</span></div><div class="line">    hash, <span class="comment">// url中的hash值</span></div><div class="line">    state, <span class="comment">// url对应的state字段</span></div><div class="line">    action, <span class="comment">// 分为push、replace、pop三种</span></div><div class="line">    key <span class="comment">// 生成方法为: Math.random().toString(36).substr(2, length)</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>三种方法各自执行<code>URL</code>前进的方式：</p>
<ul>
<li><code>createBrowserHistory</code>: pushState、replaceState</li>
<li><code>createHashHistory</code>: <code>location.hash=***</code> <code>location.replace()</code></li>
<li><code>createMemoryHistory</code>: 在内存中进行历史记录的存储</li>
</ul>
<p>伪代码实现:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// createBrowserHistory(HTML5)中的前进实现</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">finishTransition</span>(<span class="params">location</span>) </span>&#123;</div><div class="line">  ...</div><div class="line">  const historyState = &#123; key &#125;;</div><div class="line">  ...</div><div class="line">  if (location.action === <span class="string">'PUSH'</span>) ) &#123;</div><div class="line">    <span class="built_in">window</span>.history.pushState(historyState, <span class="literal">null</span>, path);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">window</span>.history.replaceState(historyState, <span class="literal">null</span>, path)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// createHashHistory的内部实现</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">finishTransition</span>(<span class="params">location</span>) </span>&#123;</div><div class="line">  ...</div><div class="line">  if (location.action === <span class="string">'PUSH'</span>) ) &#123;</div><div class="line">    <span class="built_in">window</span>.location.hash = path;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">window</span>.location.replace(</div><div class="line">    <span class="built_in">window</span>.location.pathname + <span class="built_in">window</span>.location.search + <span class="string">'#'</span> + path</div><div class="line">  );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// createMemoryHistory的内部实现</span></div><div class="line">entries = [];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">finishTransition</span>(<span class="params">location</span>) </span>&#123;</div><div class="line">  ...</div><div class="line">  switch (location.action) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'PUSH'</span>:</div><div class="line">      entries.push(location);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">'REPLACE'</span>:</div><div class="line">      entries[current] = location;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><strong>React-router的基本原理</strong></li>
</ol>
<p><code>URL</code>对应<code>Location</code>对象，而<code>UI</code>是由react的 <code>components</code>来决定的，这样就转变成<code>location</code>与<code>components</code>之间的同步问题。</p>
<h4 id="什么是原型链"><a href="#什么是原型链" class="headerlink" title="什么是原型链"></a>什么是原型链</h4><p>每一个对象都会在内部链接到另一个对象(该对象的原型对象)，该对象有一个原型<code>prototype</code>，当访问对象的属性或是方法的时候，不仅仅会在原对象上查找，还会顺着原型链在原型对象的原型链上查找，直到查到<code>null</code>(所有原型链的顶层)为止。原型是JavaScript实现继承的基础，<code>new</code>关键字做的主要的事情就是将实例对象的<code>__proto__</code>属性指向原型对象的prototype。</p>
<h4 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h4><ul>
<li><p>闭包是javascript支持<a href="https://zh.wikipedia.org/wiki/%E5%A4%B4%E7%AD%89%E5%87%BD%E6%95%B0" target="_blank" rel="external">头等函数</a>的一种方式，它是一个能够引用其内部作用域变量(在本作用域第一次声明的变量)的表达式，这个表达式可以赋值给某个变量，可以作为参数传递给函数，也可以作为一个函数返回值返回。</p>
</li>
<li><p>闭包是函数开始执行的时候被分配的一个<a href="http://baike.baidu.com/link?url=x9za8fl-K8Gsdc0IFBbC5fTininX3H8qVBuSPsChIJd8bmzTRXvd8scDL1uCYKLS26m6GMbXgHFC5K8yXz7nZ3eImibufpfwiBWzlBDAyT_" target="_blank" rel="external">栈帧</a>，在函数执行结束返回后仍不会被释放(就好像一个栈帧被分配在堆里而不是栈里！)</p>
</li>
<li><p>闭包的应用：</p>
<ul>
<li>比如写柯里化函数的时候利用闭包，保存参数在内存中；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> currying = <span class="function"><span class="keyword">function</span>(<span class="params">fun</span>) </span>&#123;</div><div class="line">  	<span class="comment">//格式化arguments</span></div><div class="line">	<span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line">  	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      	<span class="comment">//收集所有的参数在同一个数组中，进行计算</span></div><div class="line">      	<span class="keyword">var</span> _args = args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>));</div><div class="line">      	<span class="keyword">return</span> fun.apply(<span class="literal">null</span>, _args);</div><div class="line">  	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
<ul>
<li>模拟私有变量或是私有方法；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> people = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</div><div class="line">  	<span class="keyword">var</span> num = num;</div><div class="line">  	<span class="keyword">return</span> &#123;</div><div class="line">    	<span class="attr">increase</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">          	num++;</div><div class="line">		&#125;,</div><div class="line">      	<span class="attr">get</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">          	<span class="keyword">return</span> num;</div><div class="line">      	&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> man = people(<span class="number">4</span>);</div><div class="line">man.increase();</div><div class="line">man.get();</div></pre></td></tr></table></figure>
<ul>
<li>避免引用错误</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</div><div class="line">  	(<span class="function"><span class="keyword">function</span>(<span class="params">_i</span>) </span>&#123;</div><div class="line">      	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      		<span class="built_in">console</span>.log(_i)</div><div class="line">		&#125;, <span class="number">1000</span>)</div><div class="line">  	&#125;)(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<h4 id="图片懒加载与预加载"><a href="#图片懒加载与预加载" class="headerlink" title="图片懒加载与预加载"></a>图片懒加载与预加载</h4><ul>
<li><p>图片懒加载的原理就是暂时不设置图片的<code>src</code>属性，而是将图片的<code>url</code>隐藏起来，比如先写在<code>data-src</code>里面，等某些事件触发的时候(比如滚动到底部，点击加载图片)再将图片真实的<code>url</code>放进<code>src</code>属性里面，从而实现图片的延迟加载</p>
</li>
<li><p>图片预加载，是指在一些需要展示大量图片的网站，实现图片的提前加载。从而提升用户体验。常用的方式有两种，一种是隐藏在css的background的url属性里面，一种是通过javascript的Image对象设置实例对象的src属性实现图片的预加载。相关代码如下：</p>
</li>
<li><ol>
<li>CSS预加载图片方式：</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#preload-01</span> &#123; <span class="attribute">background</span>: <span class="built_in">url</span>(http://domain.tld/image-01.png) no-repeat -<span class="number">9999px</span> -<span class="number">9999px</span>; &#125;  </div><div class="line"><span class="selector-id">#preload-02</span> &#123; <span class="attribute">background</span>: <span class="built_in">url</span>(http://domain.tld/image-02.png) no-repeat -<span class="number">9999px</span> -<span class="number">9999px</span>; &#125;  </div><div class="line"><span class="selector-id">#preload-03</span> &#123; <span class="attribute">background</span>: <span class="built_in">url</span>(http://domain.tld/image-03.png) no-repeat -<span class="number">9999px</span> -<span class="number">9999px</span>; &#125;</div></pre></td></tr></table></figure>
</li>
<li><ol>
<li>Javascript预加载图片的方式：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">preloadImg</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</div><div class="line">    img.src = url;</div><div class="line">    <span class="keyword">if</span>(img.complete) &#123;</div><div class="line">        <span class="comment">//接下来可以使用图片了</span></div><div class="line">        <span class="comment">//do something here</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">//接下来可以使用图片了</span></div><div class="line">            <span class="comment">//do something here</span></div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="类型数组"><a href="#类型数组" class="headerlink" title="类型数组"></a>类型数组</h4><p>JavaScript 是一种提供了访问原始二进制数据机制的类似数组的对象。</p>
<p>为了最大的灵活性和效率(mdn这么说的，不明觉厉)，JavaScript类型化数组提供了两部分来实现，一种是缓冲(ArrayBuffer)，一种是视图(TypedArray和DataView)。</p>
<p>所谓的<strong>缓冲</strong>其实是一种数据类型，表示一个通用的、固定长度的二进制数据缓冲区。该对象没法直接访问具体的数据，仅仅提供’缓冲’作用，要访问具体的数据，必须通过视图；</p>
<p>所谓的<strong>视图</strong>分为两种：<strong>TypedArray</strong>和<strong>DataView</strong>：</p>
<p><strong>TypedArray</strong>：</p>
<p>共包括9种类型的视图，比如<code>Uint8Array</code>（无符号8位整数）数组视图, <code>Int16Array</code>（16位整数）数组视图, <code>Float32Array</code>（32位浮点数）数组视图等等。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>字节长度</th>
<th>含义</th>
<th>对应的C语言类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>Int8</td>
<td>1</td>
<td>8位带符号整数</td>
<td>signed char</td>
</tr>
<tr>
<td>Uint8</td>
<td>1</td>
<td>8位不带符号整数</td>
<td>unsigned char</td>
</tr>
<tr>
<td>Uint8C</td>
<td>1</td>
<td>8位不带符号整数（自动过滤溢出）</td>
<td>unsigned char</td>
</tr>
<tr>
<td>Int16</td>
<td>2</td>
<td>16位带符号整数</td>
<td>short</td>
</tr>
<tr>
<td>Uint16</td>
<td>2</td>
<td>16位不带符号整数</td>
<td>unsigned short</td>
</tr>
<tr>
<td>Int32</td>
<td>4</td>
<td>32位带符号整数</td>
<td>int</td>
</tr>
<tr>
<td>Uint32</td>
<td>4</td>
<td>32位不带符号的整数</td>
<td>unsigned int</td>
</tr>
<tr>
<td>Float32</td>
<td>4</td>
<td>32位浮点数</td>
<td>float</td>
</tr>
<tr>
<td>Float64</td>
<td>8</td>
<td>64位浮点数</td>
<td>double</td>
</tr>
</tbody>
</table>
<p><strong>DataView</strong>：</p>
<p>DataView提供可以操作缓冲区中任意数据的读写接口。这对操作不同类型数据的场景很有帮助。而不再像TypedArray一样局限于某一种类型数据。</p>
<p><strong>应用</strong>：</p>
<ul>
<li>FileReader API(readAsArrayBuffer方法)</li>
<li>XMlHttpRequest的send方法(支持类型数组作为参数)</li>
<li>Canvas</li>
</ul>
<p>说明：类型数组并不是支持所有的原生数组的API(比如push和pop就不可用，因为ArrayBuffer给定了字节数，TypedArray视图自然无法调用)。</p>
<h4 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h4><p>跨域的方式有很多种，最常用的是<code>jsonp</code>主要利用了<code>script</code>的开放策略:通过script标签引入一个js或者是一个其他后缀形式（如php，jsp等）的文件，此文件返回一个js函数的调用。缺点在于只支持get请求而且存在安全问题。</p>
<p>CORS跨域，关键在于服务器，如果服务器实现了CORS跨域的接口，那么就可以使用ajax(请求路径为绝对路径)进行跨域请求。CORS请求分为两种，一种是简单请求，一种是非简单请求。简单请求是指请求方法在<code>HEAD</code>,<code>GET</code>,<code>POST</code>三者之间并且请求头信息局限在</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
</ul>
<ul>
<li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li>
</ul>
<p>非简单请求请求头：</p>
<p><strong>（1）Access-Control-Request-Method</strong></p>
<p>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法</p>
<p><strong>（2）Access-Control-Request-Headers</strong></p>
<p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段</p>
<p>执行简单请求的时候，浏览器会在请求头信息增加<code>origin</code>字段，服务器据此来判断请求域名是否在许可范围之内，来决定是否返回<code>Access-Control-Allow-Origin</code>字段。响应头有以下几种：</p>
<p><strong>（1）Access-Control-Allow-Origin</strong></p>
<p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p>
<p><strong>（2）Access-Control-Allow-Credentials</strong></p>
<p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>
<p><strong>（3）Access-Control-Expose-Headers</strong></p>
<p>该字段可选。CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。</p>
<p>  <strong>(4)Access-Control-Max-Age</strong></p>
<p><code>Access-Control-Max-Age</code> 首部字段指明了预检请求的响应的有效时间。</p>
<p>  <strong>(5)Access-Control-Allow-Methods</strong></p>
<p><code>Access-Control-Allow-Methods</code> 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP 方法。</p>
<p>  <strong>(6)Access-Control-Allow-Headers</strong></p>
<p><code>Access-Control-Allow-Headers</code>首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段。</p>
<p>其他方法：<code>document.domin</code>,html5的<code>postMessage</code>,<code>window.name</code>等</p>
<h4 id="函数节流和函数防抖"><a href="#函数节流和函数防抖" class="headerlink" title="函数节流和函数防抖"></a>函数节流和函数防抖</h4><p>函数节流让指函数有规律的进行调用，应用场景：window.resize，游戏中子弹发射(1s只能发射一颗子弹)等；</p>
<p>函数防抖让函数在”调用’’之后的一段时间后生效，应用场景:输入框(例：在用户停止输入的500ms后再处理用户数据)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//函数节流</span></div><div class="line"><span class="comment">/*</span></div><div class="line">* @params &#123;Function&#125; fun 调用函数</div><div class="line">* @params &#123;delay&#125; number 延迟时间</div><div class="line">*/</div><div class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fun, delay, ...rest</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> last = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">const</span> now = + <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">        <span class="keyword">if</span> (now - last &gt; delay) &#123;</div><div class="line">            fun(rest);</div><div class="line">            last = now;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//实例</span></div><div class="line"><span class="keyword">const</span> throttleExample  = throttle(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>), <span class="number">1000</span>);</div><div class="line"><span class="comment">//调用</span></div><div class="line">throttleExample();</div><div class="line">throttleExample();</div><div class="line">throttleExample();</div><div class="line"><span class="comment">//函数防抖</span></div><div class="line"><span class="keyword">const</span> debouce = <span class="function">(<span class="params">fun, delay, ...rest</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        clearTimeout(timer);</div><div class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            fun(rest);</div><div class="line">        &#125;, delay);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//实例</span></div><div class="line"><span class="keyword">const</span> debouceExample = debouce(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>), <span class="number">1000</span>);</div><div class="line"><span class="comment">//调用</span></div><div class="line">debouceExample();</div><div class="line">debouceExample();</div><div class="line">debouceExample();</div></pre></td></tr></table></figure>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ol>
<li>从数列中挑出一个元素，称为”基准”（pivot），</li>
<li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为<strong>分区（partition）</strong>操作。</li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92" target="_blank" rel="external">递归</a>地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ol>
<p>时间复杂度平均情况：O(n\log n) 最快：O(n^{2})  空间复杂度:  O(\log n)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> quickSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'2.快速排序耗时'</span>);</div><div class="line">　　<span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> arr; &#125;</div><div class="line">　　<span class="keyword">var</span> pivot = arr.splice(<span class="number">0</span>, <span class="number">1</span>)[<span class="number">0</span>];</div><div class="line">　　<span class="keyword">var</span> left = [];</div><div class="line">　　<span class="keyword">var</span> right = [];</div><div class="line">　　<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</div><div class="line">　　　　<span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</div><div class="line">　　　　　　left.push(arr[i]);</div><div class="line">　　　　&#125; <span class="keyword">else</span> &#123;</div><div class="line">　　　　　　right.push(arr[i]);</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'2.快速排序耗时'</span>);</div><div class="line">　　<span class="keyword">return</span> quickSort(left).concat([pivot], quickSort(right));</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(quickSort(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<h4 id="模块加载器加载原理"><a href="#模块加载器加载原理" class="headerlink" title="模块加载器加载原理"></a>模块加载器加载原理</h4><ul>
<li>id即路径原则<br>通常我们的入口是这样的： require( [ ‘a’, ‘b’ ], callback ) 。这里的 ‘a’、’b’ 都是 ModuleId。通过 id 和路径的对应原则，加载器才能知道需要加载的 js 的路径。在这个例子里，就是 baseUrl + ‘a.js’ 和 baseUrl + ‘b.js’。但 id 和 path 的对应关系并不是永远那么简单，比如在 AMD 规范里就可以通过配置 Paths  来给特定的 id 指配 path。</li>
<li>createElement(‘script’) &amp; appendChild<br>知道路径之后，就需要去请求。一般是通过 createElement(‘script’) &amp; appendChild 去请求。这个大家都知道，不多说。有时候有的加载器也会通过 AJAX 去请求脚本内容。一般来说，需要给 <script> 设置一个属性用来标识模块 id, 作用后面会提到。</li>
<li>document.currentScript<br>a.js 里可能是 define( id, factory ) 或者是 define( factory )，后者被称为匿名模块。那么当 define(factory) 被执行的时候，我们怎么知道当前被定义的是哪个模块呢，具体地说，这个匿名模块的实际模块 id 是什么？ 答案是通过 document.currentScript 获取当前执行的<script>，然后通过上面给 script 设置的属性来得到模块 id。需要注意的是，低级浏览器是不支持 currentScript 的，这里需要进行浏览器兼容。在高级浏览器里面，还可以通过 script.onload 来处理这个事情。</li>
<li>依赖分析<br>在继续讲之前，需要先简单介绍下模块的生命周期。模块在被 Define 之后并不是马上可以用了，在你执行它的 factory 方法来生产出最终的 export 之前，你需要保证它的依赖是可用的。那么首先就要先把依赖分析出来。<br>简单来说，就是通过 toString 这个方法得到 factory 的内容，然后用正则去匹配其中的 require( ‘moduleId’ )。当然也可以不用正则。这就是为什么 require( var );  这种带变量的语句是不被推荐的，因为它会影响依赖分析。如果一定要用变量，可以用 require( [ var ] ) 这种异步加载的方式。<br>原理五：递归加载在分析出模块的依赖之后，我们需要递归去加载依赖模块。用伪代码来表达大概是这样的：Module.prototype.load =<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> deps = <span class="keyword">this</span>.getDeps();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; deps.length; i++) &#123;</div><div class="line">        <span class="keyword">var</span> m = deps[i];</div><div class="line">        <span class="keyword">if</span> (m.state &lt; STATUS.LOADED) &#123;</div><div class="line">            m.load();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.state = STATUS.LOADED;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>上面的代码只是表达一个意思，实际上 load 方法很可能是异步的，所以递归的返回要特殊处理下。实现一个可用的加载器并没有那么简单，比如你要处理循环依赖，还有各种各样的牵一发动全身的细节。但要说原理，大概就是这么几条。个人觉得，比起照着规范实现一个加载器，更加吸引人的是 AMD 或者 CommonJS 这些规范的完善和背后的设计思路。<br>–来自<a href="https://www.zhihu.com/question/21157540/answer/33583597">JS模块加载器加载原理</a></p>
<h4 id="AMD和CMD的区别"><a href="#AMD和CMD的区别" class="headerlink" title="AMD和CMD的区别"></a>AMD和CMD的区别</h4><p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。<br>CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。</p>
<ol>
<li>对于依赖的模块，AMD 是<strong>提前执行</strong>，CMD 是<strong>延迟执行</strong>。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.</li>
<li>CMD 推崇<strong>依赖就近</strong>，AMD 推崇<strong>依赖前置</strong>。</li>
<li>AMD 的 API 默认是<strong>一个当多个用</strong>，CMD 的 API 严格区分，推崇<strong>职责单一</strong>。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都<strong>简单纯粹</strong>。</li>
</ol>
<h4 id="Web-worker"><a href="#Web-worker" class="headerlink" title="Web worker"></a>Web worker</h4><p>Web Workers是一种机制，通过它可以使一个脚本操作在与Web应用程序的主执行线程分离的后台线程中运行。这样做的优点是可以在单独的线程中执行繁琐的处理，让主（通常是UI）线程运行而不被阻塞/减慢。</p>
<p>Web Worker 规范中定义了两类工作线程，分别是专用线程Dedicated Worker和共享线程 Shared Worker，其中，Dedicated Worker只能为一个页面所使用，而Shared Worker则可以被多个页面所共享。</p>
<p>——来自<a href="http://www.alloyteam.com/2015/11/deep-in-web-worker/">深入理解web worker</a></p>
<h4 id="JavaScript内存泄露的原因以及如何去手动释放内存"><a href="#JavaScript内存泄露的原因以及如何去手动释放内存" class="headerlink" title="JavaScript内存泄露的原因以及如何去手动释放内存"></a>JavaScript内存泄露的原因以及如何去手动释放内存</h4><p><strong>易出现泄露的场景</strong></p>
<ul>
<li>XMLHttpRequest 泄漏发生在IE7-8,释放方法，将XMLHttpRequest实例对象设置为Null；</li>
<li>DOM&amp;BOM等COM对象循环绑定 泄漏发生在IE6-8，释放方法，切断循环引用，将对对象的应用设置为Null；</li>
<li>定时器(严格上说不能算是泄露，是被闭包持有了，是正常的表现)，对于闭包中无用的变量可以使用delete操作符进行释放；</li>
</ul>
<p><strong>JavaScript垃圾回收机制</strong></p>
<ul>
<li>引用计数</li>
</ul>
<p>此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</p>
<p>限制：无法处理循环引用。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后不会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。</p>
<ul>
<li>标记清除</li>
</ul>
<p>当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。</p>
<p>垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（<strong>闭包</strong>）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p>
<h4 id="柯里化函数"><a href="#柯里化函数" class="headerlink" title="柯里化函数"></a>柯里化函数</h4><p>所谓的柯里化函数简单的说就是将本来接受多个参数的函数变为只接受一个参数的函数。柯里化函数的模板和实例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> currying = <span class="function"><span class="keyword">function</span>(<span class="params">fun</span>) </span>&#123;</div><div class="line">  	<span class="comment">//格式化arguments</span></div><div class="line">	<span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line">  	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      	<span class="comment">//收集所有的参数在同一个数组中，进行计算</span></div><div class="line">      	<span class="keyword">var</span> _args = args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>));</div><div class="line">      	<span class="keyword">return</span> fun.apply(<span class="literal">null</span>, _args);</div><div class="line">  	&#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> add = currying(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div><div class="line">  	<span class="keyword">return</span> args.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> a + b;</div><div class="line">    &#125;);</div><div class="line">&#125;)</div><div class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>)</div><div class="line"><span class="comment">/*</div><div class="line"> * 经典面试题</div><div class="line"> * 函数参数不定回调函数数目不定</div><div class="line"> * 编写函数实现:</div><div class="line"> * add(1,2,3,4,5)==15</div><div class="line"> * add(1,2)(3,4)(5)==15</div><div class="line"> */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 第一次执行时，定义一个数组专门用来存储所有的参数</span></div><div class="line">    <span class="keyword">var</span> _args = [].slice.call(<span class="built_in">arguments</span>);</div><div class="line">    <span class="comment">// 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值</span></div><div class="line">    <span class="keyword">var</span> adder = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> _adder = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            [].push.apply(_args, [].slice.call(<span class="built_in">arguments</span>));</div><div class="line">            <span class="keyword">return</span> _adder;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="comment">// 利用隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回</span></div><div class="line">        _adder.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> _args.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> a + b;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> _adder;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> adder.apply(<span class="literal">null</span>, _args);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 输出结果，可自由组合的参数</span></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));  <span class="comment">// 15</span></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)(<span class="number">5</span>));  <span class="comment">// 15</span></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>));  <span class="comment">// 15</span></div></pre></td></tr></table></figure>
<h4 id="Less常用特性"><a href="#Less常用特性" class="headerlink" title="Less常用特性"></a>Less常用特性</h4><ul>
<li>变量(@color = #fff)</li>
<li>混合(Mixin)</li>
<li>内置函数(颜色，字符串，类型判断，数学)</li>
<li>循环</li>
<li>嵌套</li>
<li>运算</li>
<li>导入(@import)</li>
</ul>
<h4 id="ES6常用特性"><a href="#ES6常用特性" class="headerlink" title="ES6常用特性"></a>ES6常用特性</h4><ul>
<li>变量定义(let和const,可变与不可变，const定义对象的特殊情况)</li>
<li>解构赋值</li>
<li>模板字符串</li>
<li>数组新API(例：Array.from(),entries(),values(),keys())</li>
<li>箭头函数(rest参数，扩展运算符，::绑定this)</li>
<li>Set和Map数据结构(set实例成员值唯一存储key值，map实例存储键值对(key-value))</li>
<li>Promise对象(前端异步解决方案进化史，generator函数，async函数)</li>
<li>Class语法糖(super关键字)</li>
</ul>
<h4 id="react中setState的原理"><a href="#react中setState的原理" class="headerlink" title="react中setState的原理"></a>react中setState的原理</h4><p><strong>题目:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="keyword">this</span>.state = &#123;</div><div class="line">      <span class="attr">value</span>: <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  componentDidMount() &#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value);</div><div class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value);</div><div class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value);</div><div class="line">	setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value);</div><div class="line">      <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value);</div><div class="line">	&#125;, <span class="number">0</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>答案:</strong> 0、0、0、2、3；</p>
<p><strong>分析：</strong></p>
<p>当<code>setState</code>方法调用的时候<code>React</code>就会重新调用<code>render</code>方法来重新渲染组件；<code>setState</code>通过一个队列来更新<code>state</code>,当调用<code>setState</code>方法的时候会将需要更新的state放入这个状态队列中，这个队列会高效的批量更新<code>state</code>;</p>
<p><img src="http://7xsssj.com2.z0.glb.qiniucdn.com/setState%E7%AE%80%E5%8C%96%E8%B0%83%E7%94%A8%E6%A0%88.svg" alt="setState简化调用栈"></p>
<p>源码地址:<a href="https://github.com/facebook/react/blob/35962a00084382b49d1f9e3bd36612925f360e5b/src/renderers/shared/reconciler/ReactUpdates.js">enqueueUpdate</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>(<span class="params">component</span>) </span>&#123;</div><div class="line">  ensureInjected();</div><div class="line">  <span class="comment">//判断是否处于批量更新模式</span></div><div class="line">  <span class="keyword">if</span> (!batchingStrategy.isBatchingUpdates) &#123;</div><div class="line">    <span class="comment">//关键！下面的代码片段是这个方法的源码</span></div><div class="line">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//如果处于批量更新模式，则将这个组件保存在dirtyComponents</span></div><div class="line">  dirtyComponents.push(component);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>源码地址:<a href="https://github.com/facebook/react/blob/35962a00084382b49d1f9e3bd36612925f360e5b/src/renderers/shared/reconciler/ReactDefaultBatchingStrategy.js">ReactDefaultBatchingStrategy</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//batchingStrategy对象</span></div><div class="line"><span class="keyword">var</span> ReactDefaultBatchingStrategy = &#123;</div><div class="line">  <span class="comment">//注意默认为false</span></div><div class="line">  isBatchingUpdates: <span class="literal">false</span>,</div><div class="line">  <span class="attr">batchedUpdates</span>: <span class="function"><span class="keyword">function</span>(<span class="params">callback, a, b, c, d, e</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;</div><div class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">if</span> (alreadyBatchingUpdates) &#123;</div><div class="line">      callback(a, b, c, d, e);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">//关键！！！事务的理解</span></div><div class="line">      transaction.perform(callback, <span class="literal">null</span>, a, b, c, d, e);</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>源码地址：<a href="https://github.com/facebook/react/blob/401e6f10587b09d4e725763984957cf309dfdc30/src/shared/utils/Transaction.js">Transaction</a></p>
<p><img src="http://7xsssj.com2.z0.glb.qiniucdn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-15%2021.55.30.png" alt="事务流程图"></p>
<p>如图：事务会将所需要执行的方法(图中的anyMethod)使用<code>wrapper</code>封装起来，再通过<code>perform</code>方法执行该方法，但在<code>perform</code>执行之前会先执行所有<code>wrapper</code>中的<code>initialize</code>方法，<code>perform</code>方法执行结束后，再执行所有的<code>close</code>方法；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Transaction = <span class="built_in">require</span>(<span class="string">'./Transaction'</span>);</div><div class="line"><span class="comment">// 我们自己定义的</span></div><div class="line"><span class="keyword">var</span> MyTransaction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </div><div class="line">  <span class="comment">//do something</span></div><div class="line">&#125;;</div><div class="line"><span class="built_in">Object</span>.assign(MyTransaction.prototype, Transaction.Mixin, &#123;</div><div class="line">  	<span class="comment">//需要自定义一个getTransactionWrappers对象，获取所有需要封装的initialize方法和close方法</span></div><div class="line">  	getTransactionWrappers: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    </div><div class="line">  		<span class="keyword">return</span> [&#123;      </div><div class="line">          	<span class="attr">initialize</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;        </div><div class="line">              <span class="built_in">console</span>.log(<span class="string">'before method perform'</span>);      </div><div class="line">            &#125;,      </div><div class="line">          	<span class="attr">close</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;        </div><div class="line">              <span class="built_in">console</span>.log(<span class="string">'after method perform'</span>);      </div><div class="line">            &#125;    </div><div class="line">        &#125;];  </div><div class="line">	&#125;;</div><div class="line">&#125;);</div><div class="line"><span class="comment">//实例化一个transaction</span></div><div class="line"><span class="keyword">var</span> transaction = <span class="keyword">new</span> MyTransaction();</div><div class="line"><span class="comment">//需要调用的方法</span></div><div class="line"><span class="keyword">var</span> testMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'test'</span>);</div><div class="line">&#125;</div><div class="line">transaction.perform(testMethod);</div><div class="line"><span class="comment">//before method perform</span></div><div class="line"><span class="comment">//test</span></div><div class="line"><span class="comment">//after method perform</span></div></pre></td></tr></table></figure>
<p>理解题目的关键是，整个组件渲染到DOM中的过程就已经处于一次大的事务中了，因此在<code>componentDidMount</code>方法中调用<code>setState</code>的时候<code>ReactDefaultBatchingStrategy.isBatchingUpdates = true;</code>这句代码已经执行过了，所以<code>setState</code>的结果并没有立即生效，而是扔进了<code>dirtyComponent</code>;因此执行三次setState的结果this.state.value的值依然是0,而setTimeout中的两次setState由于没有调用过<code>batchedUpdates</code>方法(<code>isBatchingUpdates</code>默认为<code>false</code>)，所以<code>setState</code>方法立即生效，第二次<code>setSState</code>同理</p>
<h4 id="XSS与CSRF介绍"><a href="#XSS与CSRF介绍" class="headerlink" title="XSS与CSRF介绍"></a>XSS与CSRF介绍</h4><p>XSS是一种跨站脚本攻击，是属于代码注入的一种，攻击者通过将代码注入网页中，其他用户看到会受到影响(代码内容有请求外部服务器);</p>
<p>CSRF是一种跨站请求伪造，冒充用户发起请求，完成一些违背用户请求的行为(删帖，改密码，发邮件，发帖等)</p>
<p>防御方法举例:</p>
<ol>
<li>对一些关键字和特殊字符进行过滤(&lt;&gt;,?,script等)，或对用户输入内容进行URL编码(encodeURIComponent);</li>
<li>Cookie不要存放用户名和密码，对cookie信息进行MD5等算法散列存放，必要时可以将IP和cookie绑定;</li>
</ol>
<h4 id="new关键字的过程"><a href="#new关键字的过程" class="headerlink" title="new关键字的过程"></a>new关键字的过程</h4><ol>
<li>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</li>
<li>属性和方法被加入到 this 引用的对象中。</li>
<li>新创建的对象由 this 所引用，并且最后隐式的返回 this 。</li>
</ol>
<p>伪代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">obj.__proto__ = Base.prototype;<span class="comment">//Base为构造函数</span></div><div class="line">Base.call(obj);</div><div class="line"><span class="keyword">return</span> obj</div></pre></td></tr></table></figure>
<h4 id="外边距合并"><a href="#外边距合并" class="headerlink" title="外边距合并"></a>外边距合并</h4><ol>
<li>相邻的兄弟姐妹元素</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;p style="margin-bottom: 30px;"&gt;这个段落的下外边距被合并...&lt;/p&gt;</div><div class="line">&lt;p style="margin-top: 20px;"&gt;...这个段落的上外边距被合并。&lt;/p&gt;</div></pre></td></tr></table></figure>
<p>如上，两个P元素之间的间隔并不会是想象中的50px，而会是两者之间的最大值30px;</p>
<ol>
<li>块级父元素与其第一个/最后一个子元素</li>
</ol>
<p>块级父元素的 margin-bottom/margin-top与它的最后一个子元素的margin-bottom/margin-top之间没有父元素的 <code>border</code>、<code>padding</code>、inline content、<strong>height</strong>、<strong><em>min-height</em></strong>、 <strong>max-height</strong> 分隔时，就会发生下/上外边距合并现象</p>
<ol>
<li>空块元素</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;p style="margin-bottom: 0px;"&gt;这个段落的和下面段落的距离将为20px&lt;/p&gt;</div><div class="line">&lt;div style="margin-top: 20px; margin-bottom: 20px;"&gt;&lt;/div&gt;</div><div class="line">&lt;p style="margin-top: 0px;"&gt;这个段落的和上面段落的距离将为20px&lt;/p&gt;</div></pre></td></tr></table></figure>
<p><a href="https://developer.mozilla.org/zh-CN/docs/CSS/float">浮动</a> 及 <a href="https://developer.mozilla.org/zh-CN/docs/CSS/position">绝对定位</a> 元素外边距不会合并。—来自MDN</p>
<h4 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h4><p>浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。</p>
<p>块格式化上下文由以下之一创建：</p>
<ul>
<li>根元素或其它包含它的元素</li>
<li>浮动 (元素的<code>float</code>不是 <code>none</code>)</li>
<li>绝对定位的元素 (元素具有 <code>position</code> 为 <code>absolute</code> 或 <code>fixed</code>)</li>
<li>内联块 inline-blocks (元素具有 <code>display</code>: inline-block)</li>
<li>表格单元格 (元素具有 <code>display</code>: table-cell，HTML表格单元格默认属性)</li>
<li>表格标题 (元素具有 <code>display</code>: table-caption, HTML表格标题默认属性)</li>
<li>块元素具有<code>overflow</code> ，且值不是 <code>visible</code></li>
<li><code>display</code>: flow-root；—来自MDN</li>
</ul>
<p>用处:</p>
<ol>
<li>设置父元素为BFC清除子元素浮动；</li>
<li>解决上面的margin合并问题；</li>
<li>用于布局</li>
</ol>
<h4 id="CSS3动画"><a href="#CSS3动画" class="headerlink" title="CSS3动画"></a>CSS3动画</h4><p>关键属性：<code>animation</code>和<code>transition</code>（过渡），该属性现在已经被绝大多数浏览器支持，使用频率也越来越高。顾名思义，该属性允许我们使用css来写动画，所谓写：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// HTML</div><div class="line">&lt;div id="animate"&gt;233&lt;/div&gt;</div><div class="line">// CSS</div><div class="line">#animate &#123;</div><div class="line">  width: 200px;</div><div class="line">  height: 200px;</div><div class="line">  background: #233;</div><div class="line">  animation: anim 5s ease;</div><div class="line">&#125;</div><div class="line">@keyframes anim &#123;</div><div class="line">	from &#123;</div><div class="line">      width: 100px</div><div class="line">	&#125;</div><div class="line">  	to &#123;</div><div class="line">      width: 200px;</div><div class="line">  	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上就是一个简单的动画，核心是ease运动曲线(本质是贝塞尔曲线)，这个运用比较广泛，svg,canvas等都有用到它；关于贝塞尔曲线(核心四个点：起点，重点和两个中间点)有时间再深究。</p>
<h4 id="CSS原生变量"><a href="#CSS原生变量" class="headerlink" title="CSS原生变量"></a>CSS原生变量</h4><p>变量定义形式：<code>--</code>，我想大概应为@,$都被用掉了吧(less，scss无辜躺枪),变量对大小写敏感，比如–color和–Color是两个变量；</p>
<p>var()：var函数用来都读取变量；</p>
<p><strong>示例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-pseudo">:root</span> &#123;</div><div class="line">  <span class="attribute">--color</span>: <span class="number">#333</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">body</span> &#123;</div><div class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--color);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="移动端click事件300ms延迟问题"><a href="#移动端click事件300ms延迟问题" class="headerlink" title="移动端click事件300ms延迟问题"></a>移动端click事件300ms延迟问题</h4><p>追溯到早期苹果厂商给iPhone设置的双击缩放功能，浏览器需要300ms时间判断用户是否会有下一次点击(以此触发缩放或是双击666等功能)。</p>
<p>解决方案:</p>
<ul>
<li><strong>禁用缩放</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"user-scalable=no"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"initial-scale=1,maximum-scale=1"</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>更改默认的视口宽度(width=device-width)</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width"</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>指针事件 (Pointer Events)</strong></li>
</ul>
<p>根据<a href="https://dvcs.w3.org/hg/pointerevents/raw-file/tip/pointerEvents.html#the-touch-action-css-property">规范</a>，<code>touch-action</code> 属性决定 <em>“是否触摸操作会触发用户代理的默认行为。这包括但不限于双指缩放等行为”</em>。</p>
<h4 id="域名发散和域名收敛"><a href="#域名发散和域名收敛" class="headerlink" title="域名发散和域名收敛"></a>域名发散和域名收敛</h4><p><strong>域名发散:</strong>所谓域名发散是为了突破浏览器的并发限制。因此遵循这么一条定律：</p>
<blockquote>
<p>http 静态资源采用多个子域名</p>
</blockquote>
<p>比如：如果有大量图片会通过多个域名进行请求。</p>
<p><img src="https://camo.githubusercontent.com/e8881588de4903a30904e30de1fc6548ff906136/687474703a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3630383738322f3230313630342f3630383738322d32303136303430373139353130363632352d313235343234383232362e6a7067" alt="各浏览器同一域名的请求并发数"></p>
<p>浏览器同一域名并发数存在的原因：</p>
<ul>
<li>减轻服务器压力，防止服务器崩溃。</li>
<li>出于安全的考虑，防止DDOS攻击。因为一般DDOS攻击就是通过合理的请求加大服务器压力从而搞垮服务器，有了这个并发限制，DDOS起码没有那么简单了。</li>
</ul>
<p><strong>域名收敛:</strong>这个是和域名发散相反的(手动滑稽)，发散是说将资源分散为多个域名进行请求，以避开浏览器的并发限制。而域名收敛则是说将资源放在同一个域名下进行请求。那么实际上这是两种应用场景的解决方案罢了。域名发散是为了解决PC端浏览器并发请求限制。而域名收敛则是针对的移动端的(2G,3G网络环境不容忽视)。</p>
<p>域名收敛的原因很简单，<strong>减少不必要的域名解析</strong>，充分利用缓存，从而加快页面打开的速度。</p>
<p>关于域名收敛可以看这篇：<a href="http://taobaofed.org/blog/2015/12/16/h5-performance-optimization-and-domain-convergence/">无线性能优化：域名收敛</a></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>时隔三个月，终于迎来了博文的更新，有看到博友在评论留言：<br><img src="http://7xsssj.com2.z0.glb.qiniucdn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-14%2018.37.36.png" alt=""><br>心里很温暖，这篇不算博文的博文就当是回归之作吧，接下来的时间会尽量保持在一周一更，实习结束有的是时间了，哈哈哈。</p>
</script></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 包含这三个月来碰到的一些觉得比较好的面试题，三个月没怎么写博客着实有些手痒，哈哈哈。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://damonare.github.io/2017/04/24/%E6%88%91%E7%9A%84%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/#more&quot;&gt;我的前端进阶之路&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;烈火试真金，逆境试强者&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="CSS" scheme="http://damonare.github.io/tags/CSS/"/>
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
      <category term="HTML" scheme="http://damonare.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>理解Node.js的事件轮询</title>
    <link href="http://damonare.github.io/2017/02/08/%E7%90%86%E8%A7%A3Node.js%E7%9A%84%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2/"/>
    <id>http://damonare.github.io/2017/02/08/理解Node.js的事件轮询/</id>
    <published>2017-02-08T14:54:02.000Z</published>
    <updated>2017-02-08T14:54:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括</strong> ：</p>
<ul>
<li>原文地址：<a href="https://damonare.github.io/2017/02/08/%E7%90%86%E8%A7%A3Node.js%E7%9A%84%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2/#more">理解Node.js的事件轮询</a></li>
<li>Node小应用：<a href="https://github.com/damonare/node-sample" target="_blank" rel="external">Node-sample</a></li>
</ul>
<p><strong>智者阅读群书，亦阅历人生</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="Node-js的两个基本概念"><a href="#Node-js的两个基本概念" class="headerlink" title="Node.js的两个基本概念"></a>Node.js的两个基本概念</h4><p>Node.js的第一个基本概念就是I/O操作开销是巨大的：</p>
<p><img src="http://7xsssj.com2.z0.glb.qiniucdn.com/io-cost.png" alt=""></p>
<p>所以，当前变成技术中最大的浪费来自于等待I/O操作的完成。有几种方法可以解决性能的影响：</p>
<ul>
<li><strong>同步方式</strong>：按次序一个一个的处理请求。<em>利</em>：简单；<em>弊</em>：任何一个请求都可以阻塞其他所有请求。</li>
<li><strong>开启新进程</strong>：每个请求都开启一个新进程。<em>利</em>：简单；<em>弊</em>：大量的链接意味着大量的进程。</li>
<li><strong>开启新线程</strong>：每个请求都开启一个新线程。<em>利</em>：简单，而且跟进程比，对系统内核更加友好，因为线程比进程轻的多;<em>弊</em>:不是所有的机器都支持线程，而且对于要处理共享资源的情况，多线程编程会很快变得太过于复杂。</li>
</ul>
<p>第二个基本概念是每个连接都创建一个新线程是很消耗内存的（例如：你可以对比Nginx回想一下Apache内存耗尽的情景）。</p>
<p>Apache是多线程的：它为每个请求开启一个新的线程（或者是进程，这取决于你的配置），当并发连接增多时，你可以看看它是怎么一点一点耗尽内存的。Nginx和Node.js不是多线程的，因为线程的消耗太“重”了。它们两个是单线程、基于事件的，这就把处理众多连接所产生的线程/进程消耗给消除了。</p>
<h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p>确实只有一个线程：你不能并行执行任何代码，比如：下面的“sleep”将会阻塞sever1秒钟：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="keyword">var</span> now = <span class="keyword">new</span> Data().getTime();</div><div class="line">   <span class="keyword">while</span> (<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() &lt; now + <span class="number">1000</span>) &#123;</div><div class="line">         <span class="comment">// do nothing</span></div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">sleep();</div></pre></td></tr></table></figure>
<p>但就我目前学习阶段而言，我觉得好多人对于所谓的node单线程是有误解的。实际上官方给出的“单线程”是具有误导性的。所谓的单线程是指你的代码只运行在一个线程上(好多地方都叫它主线程，实际上Javascript的浏览器运行环境不也是这么处理我们写的Javascript代码的嘛)，而诸多任务的并行处理，就需要多线程了，如下图：</p>
<p><img src="http://7xsssj.com2.z0.glb.qiniucdn.com/104032-20150917140900539-1845886135.png" alt=""></p>
<p>如上图，Node.js中的单线程之说指的就是这个主线程，这个主线程有一个循环结构，保持着整个程序(你写的代码)的运转。</p>
<h4 id="事件轮询"><a href="#事件轮询" class="headerlink" title="事件轮询"></a>事件轮询</h4><p>其实上面我们所说的<strong>维持主线程运行的循环</strong>这部分就是”事件轮询”，它存在于主线程中，负责不停地调用开发者编写的代码。但对开发者是不可见的。so…开发者编写的代码是怎样被调用的呢？看下图：</p>
<p><img src="http://7xsssj.com2.z0.glb.qiniucdn.com/104032-20150917141055570-1948801510.png" alt=""></p>
<p>如上图，异步函数在执行结束后，会在事件队列中添加一个事件(遵循先进先出原则)，主线程中的代码执行完毕后(即一次循环结束)，下一次循环开始就在事件队列中”读取”事件，然后调用它所对应的回调函数(所以回调函数的执行顺序是不一定的)。如果开发者在回调函数中调用了阻塞方法(比如上文中的sleep函数)，那么整个事件轮询就会阻塞，事件队列中的事件得不到及时处理。正因为这样，nodejs中的一些库方法均是异步的，也提倡用户调用异步方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line">fs.readFile(<span class="string">'hello.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;  <span class="comment">//异步读取文件</span></div><div class="line">　　<span class="built_in">console</span>.log(<span class="string">"read file end"</span>);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"call readFile over"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上代码，我们虽然使用了异步方法readfile读取文件，但<code>read file end</code>永远不会输出，因为代码始终在while循环中，下一次事件轮询始终没法开始，也就没法’读取’事件队列调用相应的回调函数了。</p>
<p>最后有一个<a href="https://github.com/damonare/node-sample" target="_blank" rel="external">Node-sample</a>是博主平时积累的一些代码，包含注释，汇总成了一个小应用，还是可以看到学习的蛛丝马迹的。感兴趣的您可以看看。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>参考文章：</p>
<ul>
<li><a href="http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop" target="_blank" rel="external">Understanding the node.js event loop</a></li>
<li><a href="http://www.cnblogs.com/xiaozhi_5638/p/4816265.html" target="_blank" rel="external">nodejs事件轮询详述</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括&lt;/strong&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://damonare.github.io/2017/02/08/%E7%90%86%E8%A7%A3Node.js%E7%9A%84%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2/#more&quot;&gt;理解Node.js的事件轮询&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Node小应用：&lt;a href=&quot;https://github.com/damonare/node-sample&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Node-sample&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;智者阅读群书，亦阅历人生&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="http://damonare.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>理解Node.js(译文)</title>
    <link href="http://damonare.github.io/2017/02/08/%E7%90%86%E8%A7%A3Node.js(%E8%AF%91%E6%96%87)/"/>
    <id>http://damonare.github.io/2017/02/08/理解Node.js(译文)/</id>
    <published>2017-02-08T11:58:58.000Z</published>
    <updated>2017-02-08T11:58:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括</strong> ：这篇文章十分生动形象的的介绍了Node，满足了读者想去了解Node的需求。作者是Node的第一批贡献者之一，德国前端大神。译者觉得作者的比喻很适合初学者理解Node，特此翻译。</p>
<p><strong>译者</strong> ：原文网址里有只小蚂蚁的效果很有意思(多次鼠标悬浮会有惊喜)，哈哈哈，可以去看一下哦。</p>
<ul>
<li>原文地址：<a href="http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb" target="_blank" rel="external">Understanding node.js</a></li>
<li>原文作者：<a href="http://felixge.de/" target="_blank" rel="external">Felix Geisendörfer</a></li>
<li>Node小应用：<a href="https://github.com/damonare/node-sample" target="_blank" rel="external">Node-sample</a></li>
<li>译者：<a href="http://damonare.cn" target="_blank" rel="external">Damonare</a></li>
</ul>
<p><strong>本文属于译文</strong> </p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>当我向别人介绍<a href="http://nodejs.org/" target="_blank" rel="external">Node.js</a> 的时候一般会有两种反应，要么是立马就弄明白它是个什么玩意儿，要么是被它搞的很糊涂。</p>
<p>如果你现在还处于后者，下面就是我对于<code>node</code>的解释：</p>
<ul>
<li>它是一个命令行工具，你可以下载一个tarball文件，编译然后安装源文件；</li>
<li>它可以让你在你的终端输入<code>node my_app.js</code>来运行Javascript程序；</li>
<li>Node的JS代码是由 <a href="http://code.google.com/p/v8/" target="_blank" rel="external">V8 javascript 引擎</a>（就是那个使得Chrome如此之快的东西）所执行的；</li>
<li>Node提供了诸如访问网络或是操作文件系统的<code>Javascript API</code></li>
</ul>
<h4 id="“但我也可以用-Ruby-Python-Php-Java-…等语言来做我想要做的事啊”"><a href="#“但我也可以用-Ruby-Python-Php-Java-…等语言来做我想要做的事啊”" class="headerlink" title="“但我也可以用 Ruby, Python, Php,Java, …等语言来做我想要做的事啊”"></a>“但我也可以用 Ruby, Python, Php,Java, …等语言来做我想要做的事啊”</h4><p>我听到你说的话了，你是对的。<code>Node</code>不是狡猾的独角兽，这点很抱歉，它不会帮你做你该做的事。它仅仅是一个工具，而且他也不会替代你现在所常用的一些工具，至少现在不会。</p>
<h4 id="“说重点！！！”"><a href="#“说重点！！！”" class="headerlink" title="“说重点！！！”"></a>“说重点！！！”</h4><p>好的，我会的，当你需要同时做好几件事的时候<code>Node</code>会表现的十分优秀。你有写了一段代码然后对他说”我想你可以并行运行！”的体验吗？哈哈哈，在Node中除了你的代码所有的东西都是并行运行的。</p>
<h4 id="“啊？！”"><a href="#“啊？！”" class="headerlink" title="“啊？！”"></a>“啊？！”</h4><p>是的，没错，除了你的代码之外所有的代码都是并行运行的。为了理解这一点，你可以把你自己的代码想象成一个国王，而<code>Node</code>就是他的仆人军队。</p>
<p>新的一天是这样开始的：某个仆人叫醒了国王，然后问他是否需要什么。国王给了这个仆人一个任务清单然后就回去继续睡觉了。然后这个仆人就把任务清单上的任务分发下去，仆人们开始工作了。</p>
<p>当一个仆人完成了他的任务的时候，他就跑到国王寝宫外面排队等候报告。国王一次只能听取一个仆人报告任务，有的时候国王会在仆人报告结束的时候给他更多的任务。(看你代码咋写咯)</p>
<p>生活是美好的，因为国王的诸多仆人同时执行多个任务，但报告结果的时候是一个一个来的，所以国王能够很专注。</p>
<h4 id="“那确实很美好，但你能结束这个愚蠢的比喻用更加geek的方式来告诉我吗？”"><a href="#“那确实很美好，但你能结束这个愚蠢的比喻用更加geek的方式来告诉我吗？”" class="headerlink" title="“那确实很美好，但你能结束这个愚蠢的比喻用更加geek的方式来告诉我吗？”"></a>“那确实很美好，但你能结束这个愚蠢的比喻用更加geek的方式来告诉我吗？”</h4><p>好的，一个<code>node</code>程序或许是下面这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line">  , sys = <span class="built_in">require</span>(<span class="string">'sys'</span>);</div><div class="line"><span class="comment">//译者注：sys is deprecated. Use util instead.这里我们直接用console.log即可</span></div><div class="line">fs.readFile(<span class="string">'treasure-chamber-report.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">report</span>) </span>&#123;</div><div class="line">  <span class="comment">//sys.puts("oh, look at all my money: "+report);</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"oh, look at all my money: "</span>+report)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">fs.writeFile(<span class="string">'letter-to-princess.txt'</span>, <span class="string">'...'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">//sys.puts("can't wait to hear back from her!");</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"can't wait to hear back from her!"</span>)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>你的代码(国王)给了<code>node</code>(仆人)两个任务即读(readFile)和写(writeFile)文件，然后就去睡大觉了。一旦node完成了某个任务，跟这个任务对应的回调就会触发。但同一时间只能有一个回调被触发，在那个回调执行完成之前，所有其它的回调都得排队等待。进一步说，回调触发的顺序是不能被保证的。</p>
<h4 id="“所以我不必担心代码在同一时间访问同一个数据结构？”"><a href="#“所以我不必担心代码在同一时间访问同一个数据结构？”" class="headerlink" title="“所以我不必担心代码在同一时间访问同一个数据结构？”"></a>“所以我不必担心代码在同一时间访问同一个数据结构？”</h4><p>你确实理解了，这就是JavaScript的单进程/事件循环设计美丽的地方。</p>
<h4 id="“好棒，但我为什么应该用它呢？”"><a href="#“好棒，但我为什么应该用它呢？”" class="headerlink" title="“好棒，但我为什么应该用它呢？”"></a>“好棒，但我为什么应该用它呢？”</h4><p>一个原因是效率。在一个web应用中，响应时间主要是花在了执行数据库查询上面，而用<code>node</code>,你可以一次性执行所有的数据库查询。将响应时间减少到了执行最慢的数据库查询所用的时间。</p>
<p>另一个原因是<code>Javascript</code>。你可以使用<code>Node</code>让你的浏览器和后端共享代码。Javascript也在渐渐成为一门真正的通用语言。不管你在过去是用Python, Ruby, Java, PHP, …等等，你都或多或少的使用过Javasctipt，对吗？</p>
<p>最后一个原因是原生速度。V8正在不断的推进作为地球上最快的动态语言编译器之一的边界，我也想不到有任何其它的语言在速度上能够像Javascript一样不断的高歌猛进。再进一步说，<code>node</code>的I/O设备真的十分的轻量，能够让你尽可能最大程度的利用系统的I/O容量。</p>
<h4 id="“所以你是说从现在开始我应该用Node写我所有的应用么？”"><a href="#“所以你是说从现在开始我应该用Node写我所有的应用么？”" class="headerlink" title="“所以你是说从现在开始我应该用Node写我所有的应用么？”"></a>“所以你是说从现在开始我应该用Node写我所有的应用么？”</h4><p>是也不是，一旦你开始舞弄<code>node</code>这柄锤子，所有的东西都会开始变得像钉子。但如果你当前的工作有一个deadline，你可以参考下面的几点来做决定用不用<code>node</code>:</p>
<ul>
<li>低响应时间/高并发是否重要？Node真的很擅长处理这俩问题；</li>
<li>项目有多大？小项目没问题，如果是大项目就应该认真评估了(可用的库，修复一个bug所需的资源或者two upstream等等)</li>
</ul>
<h4 id="“我能在Node中访问DOM吗？”"><a href="#“我能在Node中访问DOM吗？”" class="headerlink" title="“我能在Node中访问DOM吗？”"></a>“我能在Node中访问DOM吗？”</h4><p>这是一个好问题！答案是不行，DOM是浏览器的东西吗，不过幸好node的JS引擎（V8）跟那些混乱的东西是完全分离的。不过，有人在以node模块的形式来实现DOM，或许带来令人兴奋的可能性比如对客户端代码进行单元测试。(译者注：现在已经有人实现了这个模块，详情查看<a href="https://www.npmjs.com/package/node-dom" target="_blank" rel="external">Node-dom</a>)。</p>
<h4 id="“难道事件驱动编程真的很难吗？”"><a href="#“难道事件驱动编程真的很难吗？”" class="headerlink" title="“难道事件驱动编程真的很难吗？”"></a>“难道事件驱动编程真的很难吗？”</h4><p>这取决于你自己，如果你已经学会了如何在浏览器里调用Ajax或是调用某个事件，那么学习node对你不会是什么难题。</p>
<p>同时，测试驱动开发能够真正的帮助你从做一个可维护的设计开始学习node。</p>
<h4 id="“我应该从哪里学到更多？”"><a href="#“我应该从哪里学到更多？”" class="headerlink" title="“我应该从哪里学到更多？”"></a>“我应该从哪里学到更多？”</h4><p>Tim Caswell正在运作优秀的<a href="http://howtonode.org/" target="_blank" rel="external">How To Node</a>博客。在twitter上Follow <a href="https://twitter.com/search?q=node.js&amp;src=typd" target="_blank" rel="external">nodejs</a>。订阅<a href="http://groups.google.com/group/nodejs" target="_blank" rel="external">邮件列表</a>。(译者注：也可以结合<a href="http://nodejs.cn/api/" target="_blank" rel="external">Node.js 6.9.5 文档</a>进行学习，另外，译者写了一个node的小应用<a href="https://github.com/damonare/node-sample" target="_blank" rel="external">node-sample</a>可以clone下来看下)</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本篇文章的比如讲真是有些简单了，但从现实事物中找到真正相对应的也是在太难。，另外，由于时间原因，本文一些不妥之处或是当时还处在实验性阶段的东西译者或删或改。能力有限，水平一般，翻译不妥之处，还望指正。感谢。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括&lt;/strong&gt; ：这篇文章十分生动形象的的介绍了Node，满足了读者想去了解Node的需求。作者是Node的第一批贡献者之一，德国前端大神。译者觉得作者的比喻很适合初学者理解Node，特此翻译。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;译者&lt;/strong&gt; ：原文网址里有只小蚂蚁的效果很有意思(多次鼠标悬浮会有惊喜)，哈哈哈，可以去看一下哦。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Understanding node.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文作者：&lt;a href=&quot;http://felixge.de/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Felix Geisendörfer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Node小应用：&lt;a href=&quot;https://github.com/damonare/node-sample&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Node-sample&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译者：&lt;a href=&quot;http://damonare.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Damonare&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;本文属于译文&lt;/strong&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
      <category term="译文" scheme="http://damonare.github.io/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="Node.js" scheme="http://damonare.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Javascript闭包入门(译文)</title>
    <link href="http://damonare.github.io/2017/01/21/Javascript%E9%97%AD%E5%8C%85%E5%85%A5%E9%97%A8(%E8%AF%91%E6%96%87)/"/>
    <id>http://damonare.github.io/2017/01/21/Javascript闭包入门(译文)/</id>
    <published>2017-01-21T10:01:30.000Z</published>
    <updated>2017-01-21T10:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括</strong> ：这篇文章使用有效的javascript代码向程序员们解释了闭包，大牛和功能型程序员请自行忽略。</p>
<p><strong>译者</strong> ：文章写在2006年，可直到翻译的21小时之前作者还在完善这篇文章，在Stackoverflow的<a href="http://stackoverflow.com/questions/111102/how-do-javascript-closures-work" target="_blank" rel="external">How do JavaScript closures work?</a>这个问题里更是得到了4000+的赞同，文章内容质量自然不必多说。</p>
<ul>
<li>原文地址：<a href="http://web.archive.org/web/20080209105120/http:/blog.morrisjohns.com/javascript_closures_for_dummies" target="_blank" rel="external">JavaScript Closures for Beginners</a></li>
<li>原文作者：Morris </li>
<li>译者：Damonare</li>
<li>译者博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></li>
</ul>
<p><strong>本文属于译文</strong> </p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="闭包并不是魔法"><a href="#闭包并不是魔法" class="headerlink" title="闭包并不是魔法"></a>闭包并不是魔法</h3><p>这篇文章使用有效的javascript代码向程序员们解释了闭包，大牛和功能型程序员请自行忽略。</p>
<p>实际上一旦你对闭包的核心概念心领神会了，闭包就不难理解了，但如果你想通过读那些学术性文章或是学院派的论文来理解闭包那基本是不可能的。</p>
<p>本文主要是面向那些有主流程序语言开发经验或是能看懂下面这段代码的程序员：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> text = <span class="string">'Hello '</span> + name;</div><div class="line">  <span class="keyword">var</span> say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(text); &#125;</div><div class="line">  say();</div><div class="line">&#125;</div><div class="line">sayHello(<span class="string">'Joe'</span>);</div></pre></td></tr></table></figure>
<h3 id="一个闭包小案例"><a href="#一个闭包小案例" class="headerlink" title="一个闭包小案例"></a>一个闭包小案例</h3><p><strong>两种方式概括：</strong></p>
<ul>
<li>闭包是javascript支持<a href="https://zh.wikipedia.org/wiki/%E5%A4%B4%E7%AD%89%E5%87%BD%E6%95%B0" target="_blank" rel="external">头等函数</a>的一种方式，它是一个能够引用其内部作用域变量(在本作用域第一次声明的变量)的表达式，这个表达式可以赋值给某个变量，可以作为参数传递给函数，也可以作为一个函数返回值返回。</li>
</ul>
<p>或是</p>
<ul>
<li>闭包是函数开始执行的时候被分配的一个<a href="http://baike.baidu.com/link?url=x9za8fl-K8Gsdc0IFBbC5fTininX3H8qVBuSPsChIJd8bmzTRXvd8scDL1uCYKLS26m6GMbXgHFC5K8yXz7nZ3eImibufpfwiBWzlBDAyT_" target="_blank" rel="external">栈帧</a>，在函数执行结束返回后仍不会被释放(就好像一个栈帧被分配在堆里而不是栈里！)</li>
</ul>
<p>下面这段代码返回了一个指向这个函数的引用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello2</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> text = <span class="string">'Hello '</span> + name; <span class="comment">// 局部变量text</span></div><div class="line">  <span class="keyword">var</span> say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(text); &#125;</div><div class="line">  <span class="keyword">return</span> say;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> say2 = sayHello2(<span class="string">'Bob'</span>);</div><div class="line">say2(); <span class="comment">// 打印日志： "Hello Bob"</span></div></pre></td></tr></table></figure>
<p>绝大部分Javascript程序员能够理解上面代码中的一个函数引用是如何返回赋值给变量<code>say2</code>的，如果你不理解，那么你需要理解之后再来学习闭包。C语言程序员会认为这个函数返回一个指向某函数的指针，变量<code>say</code>和<code>say2</code>都是指向某个函数的指针。</p>
<p>Javascript的函数引用和C语言指针相比还有一个关键性的不同之处，在Javascript中，一个引用函数的变量可以看做是有两个指针，一个是指向函数的指针，一个是指向闭包的隐藏指针。</p>
<p>上面代码中就有一个闭包，为什么呢？因为匿名函数<code>function() { console.log(text); }</code>是在另一个函数(在本例中就是<code>sayHello2()</code>函数)声明的。在Javascript中，如果你在另一个函数中使用了<code>function</code>关键字，那么你就创建了一个闭包。</p>
<p>在C语言和大多数常用程序语言中，当一个函数返回后，函数内声明的局部变量就不能再被访问了，因为该函数对应的栈帧已经被销毁了。</p>
<p>在Javscript中，如果你在一个函数中声明了另一个函数，那么在你调用这个函数返回后里面的局部变量仍然是可以访问的。这个已经在上面的代码中演示过了，即我们在函数<code>sayHello()</code>返回后仍然可以调用函数<code>say2()</code>。<strong>注意：我们在代码中引用的变量<code>text</code>是我们在函数<code>sayHello2()</code>中声明的局部变量。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(text); &#125; <span class="comment">// 输出say2.toString();</span></div></pre></td></tr></table></figure>
<p>观察<code>say2.toString()</code>的输出，我们可以看到确实引用了<code>text</code>变量。匿名函数之所以可以引用包含<code>&#39;Hello Bob&#39;</code>的<code>text</code>变量就是因为<code>sayhello2()</code>的局部变量被保存在了闭包中。</p>
<p>神奇的是，在JavaScript中，函数引用还有一个对于它所创建的闭包的秘密引用，类似于事件委托是一个方法指针加上对于某个对象的秘密引用。</p>
<h3 id="更多例子"><a href="#更多例子" class="headerlink" title="更多例子"></a>更多例子</h3><p>出于某种不得而知的原因，当你去阅读一些关于闭包的文章的时候，闭包看起来真的是难以理解的。但如果你看到一些你能够去操作的闭包小案例(这花费了我一段时间)，闭包就容易理解了。推荐好好推敲下这几个小案例直到你彻底理解了它们到底是如何工作的。如果你没完全弄明白闭包是如何工作的就去盲目使用闭包，会搞出很多神奇的bug的！</p>
<h4 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h4><p>局部变量虽然没有被复制，但可以通过被引用而被保留下来。这就好像外部函数退出后，但栈帧依旧保存在内存中一样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">say667</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 局部变量num最后会保存在闭包中</span></div><div class="line">  <span class="keyword">var</span> num = <span class="number">42</span>;</div><div class="line">  <span class="keyword">var</span> say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(num); &#125;</div><div class="line">  num++;</div><div class="line">  <span class="keyword">return</span> say;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> sayNumber = say667();</div><div class="line">sayNumber(); <span class="comment">// 输出 43</span></div></pre></td></tr></table></figure>
<h4 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h4><p>下面三个全局函数对同一个闭包有一个共同的引用，因为他们都是在调用函数<code>setupSomeGlobals()</code>时声明的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gLogNumber, gIncreaseNumber, gSetNumber;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupSomeGlobals</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 局部变量num最后会保存在闭包中</span></div><div class="line">  <span class="keyword">var</span> num = <span class="number">42</span>;</div><div class="line">  <span class="comment">// 将一些对于函数的引用存储为全局变量</span></div><div class="line">  gLogNumber = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(num); &#125;</div><div class="line">  gIncreaseNumber = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; num++; &#125;</div><div class="line">  gSetNumber = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; num = x; &#125;</div><div class="line">&#125;</div><div class="line">setupSomeGlobals();</div><div class="line">gIncreaseNumber();</div><div class="line">gLogNumber(); <span class="comment">// 43</span></div><div class="line">gSetNumber(<span class="number">5</span>);</div><div class="line">gLogNumber(); <span class="comment">// 5</span></div><div class="line"><span class="keyword">var</span> oldLog = gLogNumber;</div><div class="line">setupSomeGlobals();</div><div class="line">gLogNumber(); <span class="comment">// 42</span></div><div class="line">oldLog() <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<p>这三个函数具有对同一个闭包的共享访问权限——这个闭包是指当三个函数定义时<code>setupSomeGlobals()</code>的局部变量。</p>
<p><strong>注意：在上述示例中，当你再次调用<code>setupSomeGlobals()</code>时，一个新的闭包(栈帧)就被创建了。</strong>旧变量<code>gLogNumber</code>, <code>gIncreaseNumber</code>, <code>gSetNumber</code> 被有新闭包的函数覆盖(在JavaScript中，如果你在一个函数中声明了一个新的函数，那么当外部函数被调用时，内部函数会被重新创建)。</p>
<h4 id="例5"><a href="#例5" class="headerlink" title="例5"></a>例5</h4><p> 这个示例对于很多人来说都是一个挑战，所以希望你能弄懂它。<strong>注意：当你在一个循环里面定义一个函数的时候，闭包里的局部变量可能不会像你想的那样。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildList</span>(<span class="params">list</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</div><div class="line">        <span class="keyword">var</span> item = <span class="string">'item'</span> + i;</div><div class="line">        result.push( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(item + <span class="string">' '</span> + list[i])&#125; );</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">testList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> fnlist = buildList([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</div><div class="line">    <span class="comment">// 使用j是为了防止搞混---可以使用i</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; fnlist.length; j++) &#123;</div><div class="line">        fnlist[j]();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> testList() <span class="comment">//输出 "item2 undefined" 3 次</span></div></pre></td></tr></table></figure>
<p><code>result.push( function() {console.log(item + &#39; &#39; + list[i])}</code>这一行给<code>result</code>数组添加了三次函数匿名引用。如果你不熟悉匿名函数可以想象成下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pointer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(item + <span class="string">' '</span> + list[i])&#125;;</div><div class="line">result.push(pointer);</div></pre></td></tr></table></figure>
<p>注意，当你运行上述代码的时候会打印<code>&quot;item2 undefined&quot;</code>三次！和前面的示例一样，和<code>buildList</code>的局部变量对应的闭包只有一个。当匿名函数在<code>fnlist[j]()</code>这一行调用的时候，他们使用同一个闭包，而且是使用的这个闭包里<code>i</code>和<code>item</code>现在的值(循环结束后<code>i</code>的值为3，<code>item</code>的值为<code>&#39;item2&#39;</code>)。<strong>注意：我们从索引<code>0</code>开始，所以<code>item</code>最后的值为<code>item2&#39;</code>，<code>i</code>的值会被<code>i++</code>增加到<code>3</code> 。</strong></p>
<h4 id="例6"><a href="#例6" class="headerlink" title="例6"></a>例6</h4><p>这个例子表明了闭包会保存函数退出之前内部定义的所有的局部变量。<strong>注意：变量<code>alice</code>是在匿名函数之前创建的。</strong> 匿名函数先被声明，然后当它被调用的时候之所以能够访问<code>alice</code>是因为他们在同一个作用域内(JavaScript做了<a href="http://stackoverflow.com/questions/3725546/variable-hoisting/3725763#3725763" target="_blank" rel="external">变量提升</a>)，<code>sayAlice()()</code>直接调用了从<code>sayAlice()</code>中返回的函数引用——这个和前面的完全一样，只是少了临时的变量【译者注：存储sayAlice()返回的函数引用的变量】</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayAlice</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(alice); &#125;</div><div class="line">    <span class="comment">// 局部变量最后保存在闭包中</span></div><div class="line">    <span class="keyword">var</span> alice = <span class="string">'Hello Alice'</span>;</div><div class="line">    <span class="keyword">return</span> say;</div><div class="line">&#125;</div><div class="line">sayAlice()();<span class="comment">// 输出"Hello Alice"</span></div></pre></td></tr></table></figure>
<p><strong>技巧：需要注意变量<code>say</code>也是在闭包内部，也能被在<code>sayAlice()</code>内部声明的其它函数访问，或者也可以在函数内部递归访问它。</strong></p>
<h4 id="例7"><a href="#例7" class="headerlink" title="例7"></a>例7</h4><p>最后一个例子说明了每次调用函数都会为局部变量创建一个闭包。实际上每次函数声明并不会创建一个单独的闭包，但每次调用函数都会创建一个独立的闭包。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">newClosure</span>(<span class="params">someNum, someRef</span>) </span>&#123;</div><div class="line">    <span class="comment">// 局部变量最终保存在闭包中</span></div><div class="line">    <span class="keyword">var</span> num = someNum;</div><div class="line">    <span class="keyword">var</span> anArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line">    <span class="keyword">var</span> ref = someRef;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">        num += x;</div><div class="line">        anArray.push(num);</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'num: '</span> + num +</div><div class="line">            <span class="string">'\nanArray '</span> + anArray.toString() +</div><div class="line">            <span class="string">'\nref.someVar '</span> + ref.someVar);</div><div class="line">      &#125;</div><div class="line">&#125;</div><div class="line">obj = &#123;<span class="attr">someVar</span>: <span class="number">4</span>&#125;;</div><div class="line">fn1 = newClosure(<span class="number">4</span>, obj);</div><div class="line">fn2 = newClosure(<span class="number">5</span>, obj);</div><div class="line">fn1(<span class="number">1</span>); <span class="comment">// num: 5; anArray: 1,2,3,5; ref.someVar: 4;</span></div><div class="line">fn2(<span class="number">1</span>); <span class="comment">// num: 6; anArray: 1,2,3,6; ref.someVar: 4;</span></div><div class="line">obj.someVar++;</div><div class="line">fn1(<span class="number">2</span>); <span class="comment">// num: 7; anArray: 1,2,3,5,7; ref.someVar: 5;</span></div><div class="line">fn2(<span class="number">2</span>); <span class="comment">// num: 8; anArray: 1,2,3,6,8; ref.someVar: 5;</span></div></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>如果任何不太明白的地方最好的方式就是把玩这几个例子，去机械地阅读一些文章远比去做这些实例难得多。我关于闭包的说明、栈框体(stack-frame)的说明等等，严格理论上讲并不是完全正确的——它们只是为了理解而简化处理过的。当基础的概念心领神会之后，就可以轻松地理解这些细节了。</p>
<h3 id="最终总结"><a href="#最终总结" class="headerlink" title="最终总结"></a>最终总结</h3><ul>
<li>每当你在另一个函数里使用了关键字<code>function</code>，一个闭包就被创建了</li>
<li>每当你在一个函数内部使用了<code>eval()</code>，一个闭包就被创建了。在<code>eval</code>内部你可以引用外部函数定义的局部变量，同样的，在<code>eval</code>内部也可以通过<code>eval(&#39;var foo = …&#39;)</code>来创建新的局部变量。</li>
<li>当你在一个函数内部使用<code>new function(...)</code>(即<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="external">构造函数</a>)时，它不会创建闭包(新函数不能引用外部函数的局部变量）。</li>
<li>JavaScript中的闭包，就像一个副本，将某函数在退出时候的所有局部变量复制保存其中。</li>
<li>也许最好的理解是闭包总是在进入某个函数的时候被创建，而局部变量是被加入到这个闭包中。</li>
<li>闭包函数每次被调用的时候都会创建一组新的局部变量存储。(前提是这个函数包含一个内部的函数声明，并且这个函数的引用被返回或者用某种方法被存储到一个外部的引用中)</li>
<li>两个函数或许从源代码文本上看起来一样，但因为隐藏闭包的存在会让两个函数具有不同的行为。我认为Javascript代码实际上并不能找出一个函数引用是否有闭包。</li>
<li>如果你正尝试做一些动态源代码的修改(例如：<code>myFunction = Function(myFunction.toString().replace(/Hello/,&#39;Hola&#39;));</code>)，如果<code>myFunction</code>是一个闭包的话，那么这并不会生效(当然，你甚至可能从来都没有在运行的时候考虑过修改源代码字符串，但是。。。)。</li>
<li>在函数内部的函数的内部声明函数是可以的——可以获得不止一个层级的闭包。</li>
<li>通常我认为闭包是一个同时包含函数和被捕捉的变量的术语，但是请注意我并没有在本文中使用这个定义。</li>
<li>我觉得JavaScript中的闭包跟其它函数式编程语言中的闭包是有不同之处的。</li>
</ul>
<h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><p>如果你正好在学习闭包(在这里或是其他地方)，期待您对本文的任何反馈，您的任何建议都可能会使本文更加清晰易懂。请联系<a href="mailto:jztan1996@gmail.com" target="_blank" rel="external">jztan1996@gmail.com 【译者注：这是译者的邮箱，欢迎交流学习】</a></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这是译者翻译的第一篇文章，收获良多，感觉上并不比自己写一篇文章省事，相反熟悉内容了解代码的同时还得去揣摩作者表达的意图，难度的确要比自己单独写一篇高。能力有限，水平一般，有翻译不到位的地方，欢迎批评指正。感谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括&lt;/strong&gt; ：这篇文章使用有效的javascript代码向程序员们解释了闭包，大牛和功能型程序员请自行忽略。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;译者&lt;/strong&gt; ：文章写在2006年，可直到翻译的21小时之前作者还在完善这篇文章，在Stackoverflow的&lt;a href=&quot;http://stackoverflow.com/questions/111102/how-do-javascript-closures-work&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How do JavaScript closures work?&lt;/a&gt;这个问题里更是得到了4000+的赞同，文章内容质量自然不必多说。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;http://web.archive.org/web/20080209105120/http:/blog.morrisjohns.com/javascript_closures_for_dummies&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JavaScript Closures for Beginners&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文作者：Morris &lt;/li&gt;
&lt;li&gt;译者：Damonare&lt;/li&gt;
&lt;li&gt;译者博客地址：&lt;a href=&quot;http://damonare.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;本文属于译文&lt;/strong&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
      <category term="译文" scheme="http://damonare.github.io/tags/%E8%AF%91%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Ajax入门</title>
    <link href="http://damonare.github.io/2017/01/20/Ajax%E5%85%A5%E9%97%A8/"/>
    <id>http://damonare.github.io/2017/01/20/Ajax入门/</id>
    <published>2017-01-20T13:21:20.000Z</published>
    <updated>2017-05-13T06:58:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 本文讲述了ajax的历史，工作原理以及优缺点，对XMLHttpRequest对象进行了详细的讲解，并使用原生js实现了一个ajax对象以方便日常开始使用。</p>
<ul>
<li><p>damonare的ajax库：<a href="https://github.com/damonare/ajax/tree/master" target="_blank" rel="external">damonare的ajax库</a></p>
</li>
<li><p>原文博客地址：<a href="https://damonare.github.io/2017/01/18/%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82ajax%E5%90%97%EF%BC%9F/#more">你真的懂ajax吗？</a></p>
</li>
<li>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></li>
<li>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></li>
</ul>
<p><strong>古之立大事者，不惟有超世之才，亦必有坚忍不拔之志。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>相信每个前端程序员日常工作中都避免不了的工作就是和后端联调，联调自然就避免不了使用<code>ajax</code>，但我相信，不管是使用jquery封装的<code>ajax</code>方法还是使用vue的插件<code>vue-resource</code>的程序员，真正对于<code>ajax</code>有过深入探究的并不多，我们更多的是为了使用而使用，至于它的原理往往因为即使不了解依旧能做出东西而懒得去看，我们都被轮子们惯坏了。根据<a href="https://zh.wikipedia.org/wiki/%E5%B8%95%E9%9B%B7%E6%89%98%E6%B3%95%E5%88%99" target="_blank" rel="external">二八定律</a>，即任何一组东西中，最重要的只占其中一小部分，约20%，其余80%的尽管是多数，却是次要的。因 此，如果想挤进那20%的行列，就要学到一般人学不到的深度，学到一般人学不了的东西。</p>
<p>好的，现在我们从头来说一下<code>ajax</code>。</p>
<h3 id="Ajax简介"><a href="#Ajax简介" class="headerlink" title="Ajax简介"></a>Ajax简介</h3><p>在上世纪90年代，几乎所有的网站都由HTML页面实现，服务器处理每一个用户请求都需要重新加载网页。形式是怎样的呢？就比如说你在浏览器上登录自己的微博账号，填完了表单，点击登录按钮，一次”完整”的HTTP请求就此触发，服务器发现你的登录密码不对头，立马把网页原原本本的返回给你，在用户看来呢，就是一次重新加载的过程！用户体验极差！而且这个做法浪费了许多带宽，因为在前后两个页面中的大部分HTML码往往是相同的。由于每次应用的沟通都需要向服务器发送请求，应用的回应时间依赖于服务器的回应时间。这导致了用户界面的回应比本机应用慢得多。</p>
<p>到了2005年，google率先在它的应用(诸如google地图、gmail)里使用了<code>ajax</code>技术，这才让这项技术正式风靡开来。</p>
<p>如今它的应用已经十分广泛：</p>
<ul>
<li>运用<a href="https://zh.wikipedia.org/wiki/XHTML" target="_blank" rel="external">XHTML</a>+<a href="https://zh.wikipedia.org/wiki/CSS" target="_blank" rel="external">CSS</a>来表达信息；</li>
<li>运用<a href="https://zh.wikipedia.org/wiki/JavaScript" target="_blank" rel="external">JavaScript</a>操作<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%89%A9%E4%BB%B6%E6%A8%A1%E5%9E%8B" target="_blank" rel="external">DOM</a>（Document Object Model）来运行动态效果；</li>
<li>运用<a href="https://zh.wikipedia.org/wiki/XML" target="_blank" rel="external">XML</a>和<a href="https://zh.wikipedia.org/wiki/XSLT" target="_blank" rel="external">XSLT</a>操作数据；</li>
<li>运用<a href="https://zh.wikipedia.org/wiki/XMLHttpRequest" target="_blank" rel="external">XMLHttpRequest</a>或新的Fetch API与<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%A0%81%E4%BC%BA%E6%9C%8D%E5%99%A8" target="_blank" rel="external">网页服务器</a>进行异步数据交换；</li>
<li>注意：AJAX与<a href="https://zh.wikipedia.org/wiki/Flash" target="_blank" rel="external">Flash</a>、<a href="https://zh.wikipedia.org/wiki/Silverlight" target="_blank" rel="external">Silverlight</a>和<a href="https://zh.wikipedia.org/wiki/Java_Applet" target="_blank" rel="external">Java Applet</a>等<a href="https://zh.wikipedia.org/wiki/RIA" target="_blank" rel="external">RIA</a>技术是有区分的。</li>
</ul>
<h3 id="Ajax工作原理"><a href="#Ajax工作原理" class="headerlink" title="Ajax工作原理"></a>Ajax工作原理</h3><p> Ajax的工作原理相当于在用户和服务器之间加了一个中间层(ajax引擎),使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证(比如判断用户是否输入了数据)和数据处理(比如判断用户输入数据是否是数字)等都交给Ajax引擎自己来做, 只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。把这些交给了Ajax引擎，用户操作起来也就感觉更加流畅了。</p>
<h3 id="Ajax优缺点"><a href="#Ajax优缺点" class="headerlink" title="Ajax优缺点"></a>Ajax优缺点</h3><h4 id="Ajax的优点"><a href="#Ajax的优点" class="headerlink" title="Ajax的优点"></a>Ajax的优点</h4><ol>
<li>无刷新更新数据。</li>
</ol>
<p>AJAX最大优点就是能在不刷新整个页面的前提下与服务器通信维护数据。这使得Web应用程序更为迅捷地响应用户交互，并避免了在网络上发送那些没有改变的信息，减少用户等待时间，带来非常好的用户体验。</p>
<ol>
<li>异步与服务器通信。</li>
</ol>
<p>AJAX使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。优化了Browser和Server之间的沟通，减少不必要的数据传输、时间及降低网络上数据流量。</p>
<ol>
<li>前端和后端负载平衡。</li>
</ol>
<p>AJAX可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，AJAX的原则是“按需取数据”，可以最大程度的减少冗余请求和响应对服务器造成的负担，提升站点性能。</p>
<ol>
<li>基于标准被广泛支持。</li>
</ol>
<p>AJAX基于标准化的并被广泛支持的技术，不需要下载浏览器插件或者小程序，但需要客户允许JavaScript在浏览器上执行。随着Ajax的成熟，一些简化Ajax使用方法的程序库也相继问世。同样，也出现了另一种辅助程序设计的技术，为那些不支持JavaScript的用户提供替代功能。</p>
<ol>
<li>界面与应用分离。</li>
</ol>
<p>Ajax使WEB中的界面与应用分离（也可以说是数据与呈现分离），有利于分工合作、减少非技术人员对页面的修改造成的WEB应用程序错误、提高效率、也更加适用于现在的发布系统。</p>
<h4 id="Ajax缺点"><a href="#Ajax缺点" class="headerlink" title="Ajax缺点"></a>Ajax缺点</h4><ol>
<li>AjAX干掉了Back和加入收藏书签功能，即对浏览器机制的破坏。</li>
</ol>
<blockquote>
<p> 对应用Ajax最主要的批评就是，它可能破坏浏览器的后退与加入收藏书签功能。在动态更新页面的情况下，用户无法回到前一个页面状态，这是因为浏览器仅能记下历史记录中的<a href="https://zh.wikipedia.org/w/index.php?title=%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2&amp;action=edit&amp;redlink=1" target="_blank" rel="external">静态页面</a>。一个被完整读入的页面与一个已经被动态修改过的页面之间的可能差别非常微妙；用户通常都希望单击后退按钮，就能够取消他们的前一次操作，但是在Ajax应用程序中，却无法这样做。不过开发者已想出了种种办法来解决这个问题，<a href="https://zh.wikipedia.org/wiki/HTML5" target="_blank" rel="external">HTML5</a> 之前的方法大多是在用户单击后退按钮访问历史记录时，通过创建或使用一个隐藏的IFRAME来重现页面上的变更。（例如，当用户在Google Maps中单击后退时，它在一个隐藏的<a href="https://zh.wikipedia.org/w/index.php?title=IFRAME&amp;action=edit&amp;redlink=1" target="_blank" rel="external">IFRAME</a>中进行搜索，然后将搜索结果反映到Ajax元素上，以便将应用程序状态恢复到当时的状态）。</p>
<p>关于无法将状态加入收藏或书签的问题，<a href="https://zh.wikipedia.org/wiki/HTML5" target="_blank" rel="external">HTML5</a>之前的一种方式是使用<a href="https://zh.wikipedia.org/wiki/URL" target="_blank" rel="external">URL</a>片断标识符（通常被称为<a href="https://zh.wikipedia.org/wiki/%E9%94%9A%E7%82%B9" target="_blank" rel="external">锚点</a>，即URL中#后面的部分）来保持追踪，允许用户回到指定的某个应用程序状态。（许多浏览器允许JavaScript动态更新锚点，这使得Ajax应用程序能够在更新显示内容的同时更新锚点。）<a href="https://zh.wikipedia.org/wiki/HTML5" target="_blank" rel="external">HTML5</a> 以后可以直接操作浏览历史，并以字符串形式存储网页状态，将网页加入网页收藏夹或书签时状态会被隐形地保留。上述两个方法也可以同时解决无法后退的问题。</p>
</blockquote>
<ol>
<li>AJAX的安全问题。</li>
</ol>
<p>AJAX技术给用户带来很好的用户体验的同时也对IT企业带来了新的安全威胁，Ajax技术就如同对企业数据建立了一个直接通道。这使得开发者在不经意间会暴露比以前更多的数据和服务器逻辑。Ajax的逻辑可以对客户端的安全扫描技术隐藏起来，允许黑客从远端服务器上建立新的攻击。还有Ajax也难以避免一些已知的安全弱点，诸如跨站点脚步攻击、SQL注入攻击和基于Credentials的安全漏洞等等。</p>
<ol>
<li>因为网络延迟需要给用户提供必要提示</li>
</ol>
<p>进行Ajax开发时，网络延迟——即用户发出请求到服务器发出响应之间的间隔——需要慎重考虑。如果不给予用户明确的回应，没有恰当的预读数据，或者对XMLHttpRequest的不恰当处理，都会使用户感到厌烦。通常的解决方案是，使用一个可视化的组件来告诉用户系统正在进行后台操作并且正在读取数据和内容。</p>
<h3 id="XMLhttpRequest介绍"><a href="#XMLhttpRequest介绍" class="headerlink" title="XMLhttpRequest介绍"></a>XMLhttpRequest介绍</h3><p>Ajax(Asynchronous  JavaScript  and  XML)不是指一种单一的技术，而是有机地利用了一系列相关的技术。虽然其名称包含XML，但实际上数据格式可以由<a href="https://zh.wikipedia.org/wiki/JSON" target="_blank" rel="external">JSON</a>代替，进一步减少数据量，形成所谓的AJAJ。为了使用JavaScript向服务器发出 <a href="https://developer.mozilla.org/en/HTTP" target="_blank" rel="external">HTTP</a> 请求，需要一个提供此功能的类的实例。这就是XMLHttpRequest的由来。这样的类最初是在Internet Explorer中作为一个名为XMLHTTP的ActiveX对象引入的。然后，Mozilla，Safari和其他浏览器，实现一个XMLHttpRequest类，支持Microsoft的原始ActiveX对象的方法和属性。同时微软也实现了XMLHttpRequest。</p>
<p>显而易见XMLHttpRequest类是重中之重了。</p>
<h4 id="XMLhttpRequest属性"><a href="#XMLhttpRequest属性" class="headerlink" title="XMLhttpRequest属性"></a>XMLhttpRequest属性</h4><h5 id="onreadystatechange"><a href="#onreadystatechange" class="headerlink" title="onreadystatechange"></a>onreadystatechange</h5><p>一个JavaScript函数对象，当readyState属性改变时会调用它。回调函数会在user interface线程中调用。</p>
<h5 id="readyState"><a href="#readyState" class="headerlink" title="readyState"></a>readyState</h5><p>HTTP 请求的状态.当一个 XMLHttpRequest 初次创建时，这个属性的值从 0 开始，直到接收到完整的 HTTP 响应，这个值增加到 4。</p>
<p>5 个状态中每一个都有一个相关联的非正式的名称，下表列出了状态、名称和含义：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Uninitialized</td>
<td>初始化状态。XMLHttpRequest 对象已创建或已被 abort() 方法重置。</td>
</tr>
<tr>
<td>1</td>
<td>Open</td>
<td>open() 方法已调用，但是 send() 方法未调用。请求还没有被发送。</td>
</tr>
<tr>
<td>2</td>
<td>Sent</td>
<td>Send() 方法已调用，HTTP 请求已发送到 Web 服务器。未接收到响应。</td>
</tr>
<tr>
<td>3</td>
<td>Receiving</td>
<td>所有响应头部都已经接收到。响应体开始接收但未完成。</td>
</tr>
<tr>
<td>4</td>
<td>Loaded</td>
<td>HTTP 响应已经完全接收。</td>
</tr>
</tbody>
</table>
<p>readyState 的值不会递减，除非当一个请求在处理过程中的时候调用了 abort() 或 open() 方法。每次这个属性的值增加的时候，都会触发 onreadystatechange 事件句柄。</p>
<h5 id="responseText"><a href="#responseText" class="headerlink" title="responseText"></a>responseText</h5><p>目前为止为服务器接收到的响应体（不包括头部），或者如果还没有接收到数据的话，就是空字符串。</p>
<p>如果 readyState 小于 3，这个属性就是一个空字符串。当 readyState 为 3，这个属性返回目前已经接收的响应部分。如果 readyState 为 4，这个属性保存了完整的响应体。</p>
<p>如果响应包含了为响应体指定字符编码的头部，就使用该编码。否则，假定使用 Unicode UTF-8。</p>
<h5 id="responseXML"><a href="#responseXML" class="headerlink" title="responseXML"></a>responseXML</h5><p>对请求的响应，解析为 XML 并作为 Document 对象返回。</p>
<h5 id="status"><a href="#status" class="headerlink" title="status"></a>status</h5><p>由服务器返回的 HTTP 状态代码，如 200 表示成功，而 404 表示 “Not Found” 错误。当 readyState 小于 3 的时候读取这一属性会导致一个异常。</p>
<h5 id="statusText"><a href="#statusText" class="headerlink" title="statusText"></a>statusText</h5><p>这个属性用名称而不是数字指定了请求的 HTTP 的状态代码。也就是说，当状态为 200 的时候它是 “OK”，当状态为 404 的时候它是 “Not Found”。和 status 属性一样，当 readyState 小于 3 的时候读取这一属性会导致一个异常。</p>
<h4 id="XMLHttpRequest方法"><a href="#XMLHttpRequest方法" class="headerlink" title="XMLHttpRequest方法"></a>XMLHttpRequest方法</h4><h5 id="abort"><a href="#abort" class="headerlink" title="abort()"></a>abort()</h5><p>取消当前响应，关闭连接并且结束任何未决的网络活动。</p>
<p>这个方法把 XMLHttpRequest 对象重置为 readyState 为 0 的状态，并且取消所有未决的网络活动。例如，如果请求用了太长时间，而且响应不再必要的时候，可以调用这个方法。</p>
<h5 id="getAllResponseHeaders"><a href="#getAllResponseHeaders" class="headerlink" title="getAllResponseHeaders()"></a>getAllResponseHeaders()</h5><p>把 HTTP 响应头部作为未解析的字符串返回。</p>
<p>如果 readyState 小于 3，这个方法返回 null。否则，它返回服务器发送的所有 HTTP 响应的头部。头部作为单个的字符串返回，一行一个头部。每行用换行符 “\r\n” 隔开。</p>
<h5 id="getResponseHeader"><a href="#getResponseHeader" class="headerlink" title="getResponseHeader()"></a>getResponseHeader()</h5><p>返回指定的 HTTP 响应头部的值。其参数是要返回的 HTTP 响应头部的名称。可以使用任何大小写来制定这个头部名字，和响应头部的比较是不区分大小写的。</p>
<p>该方法的返回值是指定的 HTTP 响应头部的值，如果没有接收到这个头部或者 readyState 小于 3 则为空字符串。如果接收到多个有指定名称的头部，这个头部的值被连接起来并返回，使用逗号和空格分隔开各个头部的值。</p>
<h5 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h5><p>初始化一个请求. 该方法用于JavaScript代码中;如果是本地代码, 使用 <a href="https://developer.mozilla.org/zh-cn/nsIXMLHttpRequest#openRequest(" target="_blank" rel="external"><code>openRequest()</code></a>)方法代替.</p>
<blockquote>
<p> <strong>注意:</strong> 在一个已经激活的request下（已经调用open()或者openRequest()方法的request）再次调用这个方法相当于调用了abort（）方法。</p>
</blockquote>
<p>参数</p>
<ul>
<li><p><code>method</code></p>
<p>请求所使用的HTTP方法; 例如 “GET”, “POST”, “PUT”, “DELETE”等. 如果下个参数是非HTTP(S)的URL,则忽略该参数.</p>
</li>
<li><p><code>url</code></p>
<p>该请求所要访问的URL</p>
</li>
<li><p><code>async</code></p>
<p>一个可选的布尔值参数，默认为true,意味着是否执行异步操作，如果值为false,则send()方法不会返回任何东西，直到接受到了服务器的返回数据。如果为值为true，一个对开发者透明的通知会发送到相关的事件监听者。这个值必须是true,如果multipart 属性是true，否则将会出现一个意外。</p>
</li>
<li><p><code>user</code></p>
<p>用户名,可选参数,为授权使用;默认参数为空string.</p>
</li>
<li><p><code>password</code></p>
<p>密码,可选参数,为授权使用;默认参数为空string.</p>
</li>
</ul>
<h5 id="send"><a href="#send" class="headerlink" title="send()"></a>send()</h5><p>发送 HTTP 请求，使用传递给 open() 方法的参数，以及传递给该方法的可选请求体。</p>
<h5 id="setRequestHeader"><a href="#setRequestHeader" class="headerlink" title="setRequestHeader()"></a>setRequestHeader()</h5><p>向一个打开但未发送的请求设置或添加一个 HTTP 请求(设置请求头)。</p>
<p>参数</p>
<ul>
<li><p><code>header</code></p>
<p>将要被赋值的请求头名称</p>
</li>
<li><p><code>value</code></p>
<p>给指定的请求头赋的值</p>
</li>
</ul>
<h3 id="Ajax原生js实现"><a href="#Ajax原生js实现" class="headerlink" title="Ajax原生js实现"></a>Ajax原生js实现</h3><p>下面是使用原生js写的ajax：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ajax = &#123;&#125;;</div><div class="line">ajax.httpRequest = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//判断是否支持XMLHttpRequest对象</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//兼容IE浏览器</span></div><div class="line">    <span class="keyword">var</span> versions = [</div><div class="line">        <span class="string">"MSXML2.XmlHttp.6.0"</span>,</div><div class="line">        <span class="string">"MSXML2.XmlHttp.5.0"</span>,</div><div class="line">        <span class="string">"MSXML2.XmlHttp.4.0"</span>,</div><div class="line">        <span class="string">"MSXML2.XmlHttp.3.0"</span>,</div><div class="line">        <span class="string">"MSXML2.XmlHttp.2.0"</span>,</div><div class="line">        <span class="string">"Microsoft.XmlHttp"</span></div><div class="line">    ];</div><div class="line">	<span class="comment">//定义局部变量xhr,储存IE浏览器的ActiveXObject对象</span></div><div class="line">    <span class="keyword">var</span> xhr;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; versions.length; i++) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            xhr = <span class="keyword">new</span> ActiveXObject(versions[i]);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> xhr;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">ajax.send = <span class="function"><span class="keyword">function</span> (<span class="params">url, callback, method, data, async</span>) </span>&#123;</div><div class="line">    <span class="comment">//默认异步</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">async</span> === <span class="literal">undefined</span>) &#123;</div><div class="line">        <span class="keyword">async</span> = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> httpRequest = ajax.httpRequest();</div><div class="line">    <span class="comment">//初始化HTTP请求</span></div><div class="line">    httpRequest.open(method, url, <span class="keyword">async</span>);</div><div class="line">    <span class="comment">//onreadystatechange函数对象</span></div><div class="line">    httpRequest.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//readyState 的值等于4，从服务器拿到了数据</span></div><div class="line">        <span class="keyword">if</span> (httpRequest.readyState == <span class="number">4</span>) &#123;</div><div class="line">            <span class="comment">//回调服务器响应数据</span></div><div class="line">            callback(httpRequest.responseText)</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">if</span> (method == <span class="string">'POST'</span>) &#123;</div><div class="line">      	<span class="comment">//给指定的HTTP请求头赋值</span></div><div class="line">        httpRequest.setRequestHeader(<span class="string">'Content-type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</div><div class="line">    &#125;</div><div class="line">  	<span class="comment">//发送HTTP请求</span></div><div class="line">    httpRequest.send(data);</div><div class="line">&#125;;</div><div class="line"><span class="comment">//实现GET请求</span></div><div class="line">ajax.get = <span class="function"><span class="keyword">function</span> (<span class="params">url, data, callback, async</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> query = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> data) &#123;</div><div class="line">        query.push(<span class="built_in">encodeURIComponent</span>(key) + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(data[key]));</div><div class="line">    &#125;</div><div class="line">    ajax.send(url + (query.length ? <span class="string">'?'</span> + query.join(<span class="string">'&amp;'</span>) : <span class="string">''</span>), callback, <span class="string">'GET'</span>, <span class="literal">null</span>, <span class="keyword">async</span>)</div><div class="line">&#125;;</div><div class="line"><span class="comment">//实现POST请求</span></div><div class="line">ajax.post = <span class="function"><span class="keyword">function</span> (<span class="params">url, data, callback, async</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> query = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> data) &#123;</div><div class="line">        query.push(<span class="built_in">encodeURIComponent</span>(key) + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(data[key]));</div><div class="line">    &#125;</div><div class="line">    ajax.send(url, callback, <span class="string">'POST'</span>, query.join(<span class="string">'&amp;'</span>), <span class="keyword">async</span>)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果你使用jquery或是zepto很大部分是因为它的ajax兼容性高的缘故，不妨试试这个：<a href="https://github.com/damonare/ajax/tree/master" target="_blank" rel="external">damonare的ajax库</a>，喜欢给个star也是可以的。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>ajax技术对于整个web应用意义都是非凡的，仅以此篇致敬那些曾经奋斗在一线为了ajax技术的实现和普及做出工作的前辈们。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="http://www.cnblogs.com/SanMaoSpace/archive/2013/06/15/3137180.html" target="_blank" rel="external">Ajax工作原理记优缺点</a></li>
<li><a href="https://zh.wikipedia.org/wiki/AJAX" target="_blank" rel="external">Ajax</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 本文讲述了ajax的历史，工作原理以及优缺点，对XMLHttpRequest对象进行了详细的讲解，并使用原生js实现了一个ajax对象以方便日常开始使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;damonare的ajax库：&lt;a href=&quot;https://github.com/damonare/ajax/tree/master&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;damonare的ajax库&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原文博客地址：&lt;a href=&quot;https://damonare.github.io/2017/01/18/%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82ajax%E5%90%97%EF%BC%9F/#more&quot;&gt;你真的懂ajax吗？&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;古之立大事者，不惟有超世之才，亦必有坚忍不拔之志。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="javascript" scheme="http://damonare.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript数据结构(四)——树</title>
    <link href="http://damonare.github.io/2017/01/16/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91/"/>
    <id>http://damonare.github.io/2017/01/16/学习javascript数据结构（四）——树/</id>
    <published>2017-01-16T13:41:32.000Z</published>
    <updated>2017-01-16T13:41:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 本文讲解了数据结构中的[树]的概念，尽可能通俗易懂的解释树这种数据结构的概念，使用javascript实现了树，如有纰漏，欢迎批评指正。</p>
<ul>
<li>原文博客地址：<a href="https://damonare.github.io/2017/01/14/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91/#more">学习javascript数据结构(四)——树</a></li>
<li>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></li>
<li>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></li>
</ul>
<p><strong>人之所能，不能兼备，弃其所短，取其所长。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="树简介"><a href="#树简介" class="headerlink" title="树简介"></a>树简介</h3><p>在上一篇<a href="http://damonare.github.io/2016/11/26/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%9B%86%E5%90%88/#more">学习javascript数据结构(三)——集合</a>中我们说了集合这种数据结构，在<a href="http://damonare.github.io/2016/11/01/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/#more">学习javascript数据结构(一)——栈和队列</a>和<a href="http://damonare.github.io/2016/11/09/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/#more">学习javascript数据结构(二)——链表</a>说了栈和队列以及链表这类线性表数据结构。接下来这一篇说的是<code>树</code>这种数据结构。首先想让大家明白的是数据结构是个什么玩意儿，数据结构可以分为数据的逻辑结构和数据的物理结构，所谓的数据逻辑结构在我理解就是计算机对于数据的组织方式的研究。也就是说研究的是数据和数据之间的关系。而数据的物理结构是数据的逻辑结构在计算机中的具体实现，也就是说一种逻辑结构可能会有多种存储结构与之相对应。</p>
<p>那么我们这一篇所说的<code>树</code>就是一种数据逻辑结构，即研究的是数据和数据之间的关系。之前所说的<code>栈</code>、<code>队列</code>、<code>链表</code>都是一种线性结构，相信大家也能发现这种线性结构的数据关系有一个共同点，就是数据都是一对一的，而上一篇说到的集合这种数据结构，数据是散乱的，他们之间的关系就是隶属于同一个集合，如上一篇例子所说，这些小孩子都是同一个幼儿园的，但是这些小孩子之间的关系我们并不知道。线性表(栈、队列、链表)就是对这些小孩子关系的一种表达(一对一)。而集合也是对于这些小孩子关系的一种表达。和线性表不同的是，树这种数据结构是一对多的，也就是说他所描述的是某个小孩子和其它小孩子之间的关系。</p>
<p>树这种结构实际上我们平时也有见到，比如下图这种简单的思维导图：</p>
<p><img src="http://7xsssj.com2.z0.glb.qiniucdn.com/4e4a20a4462309f7b9c58b78720e0cf3d7cad635.jpg" alt="思维导图"></p>
<p>如下也是一棵树：</p>
<p><img src="http://7xsssj.com2.z0.glb.qiniucdn.com/2009072216345191.jpg" alt="树"></p>
<p>关于树概念总结如下:</p>
<p> 1）树形结构是一对多的非线性结构。<br> 2）树形结构有树和二叉树两种，树的操作实现比较复杂，但树可以转换为二叉树进行处理。<br> 3）树的定义：树(Tree)是 n(n≥0)个相同类型的数据元素的有限集合。<br> 4）树中的数据元素叫节点(Node)。<br> 5）n=0 的树称为空树(Empty Tree)；<br> 6）对于 n＞0 的任意非空树 T 有：<br>     （1）有且仅有一个特殊的节点称为树的根(Root)节点，根没有前驱节点；<br>     （2）若n＞1，则除根节点外，其余节点被分成了m(m＞0)个互不相交的集合<br>           T1，T2，。。。，Tm，其中每一个集合Ti(1≤i≤m)本身又是一棵树。树T1，T2，。。。，Tm称为这棵树的子树(Subtree)。<br> 7）树的定义是递归的，用树来定义树。因此，树（以及二叉树）的许多算法都使用了递归。 </p>
<p>参看维基百科对于<code>树</code>的定义：</p>
<blockquote>
<p>在计算机科学中，<strong>树</strong>（英语：tree）是一种<a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5" target="_blank" rel="external">抽象数据类型</a>（ADT）或是实作这种抽象数据类型的<a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B" target="_blank" rel="external">数据结构</a>，用来模拟具<a href="https://zh.wikipedia.org/wiki/%E6%A8%B9%E7%8B%80%E7%B5%90%E6%A7%8B" target="_blank" rel="external">有树状结构</a>性质的数据集合。它是由n（n&gt;=1）个有限节点组成一个具有层次关系的<a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E5%90%88" target="_blank" rel="external">集合</a>。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>
<ul>
<li>每个节点有零个或多个子节点；</li>
<li>没有父节点的节点称为根节点；</li>
<li>每一个非根节点有且只有一个父节点；</li>
<li>除了根节点外，每个子节点可以分为多个不相交的子树；</li>
</ul>
</blockquote>
<p>树的种类：</p>
<blockquote>
<ul>
<li>无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E6%A0%91" target="_blank" rel="external">自由树</a>；</li>
<li>有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="external">二叉树</a>：每个节点最多含有两个子树的树称为二叉树；<a href="https://zh.wikipedia.org/wiki/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="external">完全二叉树</a>：对于一颗二叉树，假设其深度为d（d&gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；<a href="https://zh.wikipedia.org/w/index.php?title=%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91&amp;action=edit&amp;redlink=1" target="_blank" rel="external">满二叉树</a>：所有叶节点都在最底层的完全二叉树；<a href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="external">平衡二叉树</a>（<a href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91" target="_blank" rel="external">AVL树</a>）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；<a href="https://zh.wikipedia.org/w/index.php?title=%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91&amp;action=edit&amp;redlink=1" target="_blank" rel="external">排序二叉树</a>(二叉查找树（英语：Binary Search Tree），也称二叉搜索树、有序二叉树)；</li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91" target="_blank" rel="external">霍夫曼树</a>：<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84&amp;action=edit&amp;redlink=1" target="_blank" rel="external">带权路径</a>最短的二叉树称为哈夫曼树或最优二叉树；</li>
<li><a href="https://zh.wikipedia.org/wiki/B%E6%A0%91" target="_blank" rel="external">B树</a>：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两个子树。</li>
</ul>
</li>
</ul>
</blockquote>
<p>有关树的术语:</p>
<blockquote>
<ol>
<li><strong>节点的度</strong>：一个节点含有的子树的个数称为该节点的度；</li>
<li><strong>树的度</strong>：一棵树中，最大的节点的度称为树的度；</li>
<li><strong>叶节点</strong>或<strong>终端节点</strong>：度为零的节点；</li>
<li><strong>非终端节点</strong>或<strong>分支节点</strong>：度不为零的节点；</li>
<li><strong>父亲节点</strong>或<strong>父节点</strong>：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li>
<li><strong>孩子节点</strong>或<strong>子节点</strong>：一个节点含有的子树的根节点称为该节点的子节点；</li>
<li><strong>兄弟节点</strong>：具有相同父节点的节点互称为兄弟节点；</li>
<li>节点的<strong>层次</strong>：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</li>
<li>树的<strong>高度</strong>或<strong>深度</strong>：树中节点的最大层次；</li>
<li><strong>堂兄弟节点</strong>：父节点在同一层的节点互为堂兄弟；</li>
<li><strong>节点的祖先</strong>：从根到该节点所经分支上的所有节点；</li>
<li><strong>子孙</strong>：以某节点为根的子树中任一节点都称为该节点的子孙。</li>
<li><strong>森林</strong>：由m（m&gt;=0）棵互不相交的树的集合称为森林；</li>
</ol>
</blockquote>
<p>（我是维基百科搬运工，哈哈哈）</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><blockquote>
<p> <strong>二叉树</strong>（英语：Binary tree）是每个节点最多有两个子树的<a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E7%BB%93%E6%9E%84" target="_blank" rel="external">树结构</a>。通常子树被称作“左子树”（<em>left subtree</em>）和“右子树”（<em>right subtree</em>）。<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%A8%B9" target="_blank" rel="external">二叉树</a>常被用于实现<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9" target="_blank" rel="external">二叉查找树</a>和<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E5%A0%86%E7%A9%8D" target="_blank" rel="external">二元堆积</a>。</p>
</blockquote>
<p>我们主要研究的就是二叉树，也就是数据为一对二的关系。那么在二叉树中又有些分类；</p>
<p><img src="http://7xsssj.com2.z0.glb.qiniucdn.com/2329205432280906653.jpg" alt="二叉树"></p>
<p>二叉树分类：</p>
<ul>
<li>一棵深度为k，且有<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f24729d4eae59094b7ed114e09dcbf142f32cde8" alt="{\displaystyle 2^{\begin{aligned}k+1\end{aligned}}-1}">个节点称之为<strong>满二叉树</strong>；</li>
<li>深度为k，有n个节点的<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%A8%B9" target="_blank" rel="external">二叉树</a>，当且仅当其每一个节点都与深度为k的<a href="https://zh.wikipedia.org/w/index.php?title=%E6%BB%BF%E4%BA%8C%E5%85%83%E6%A8%B9&amp;action=edit&amp;redlink=1" target="_blank" rel="external">满二叉树</a>中，序号为1至n的节点对应时，称之为<strong>完全二叉树</strong>。</li>
<li>平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵<strong>平衡二叉树</strong>。</li>
</ul>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>1）一棵二叉树由根结点、左子树和右子树三部分组成，<br>2） D、L、R 分别代表遍历根结点、遍历左子树、遍历右子树，则二叉树的<br>3） 遍历方式有6 种：DLR、DRL、LDR、LRD、RDL、RLD。先左或先右算法基本一样，所以就剩下三种DLR（先序或是前序）、LDR（中序）、LRD（后序）。</p>
<ul>
<li><strong>前序遍历</strong>：首先访问根节点，然后遍历左子树，最后遍历右子树，可记录为根—左—右；</li>
</ul>
<ul>
<li><strong>中序遍历</strong>：首先访问左子树，然后访问根节点，最后遍历右子树，可记录为左—根—右；</li>
</ul>
<ul>
<li><strong>后序遍历</strong>：首先遍历左子树，然后遍历右子树，最后遍历根节点，可记录为左—右—根。</li>
</ul>
<p><img src="http://7xsssj.com2.z0.glb.qiniucdn.com/BINTREE2.jpg" alt="二叉树的遍历"></p>
<p><img src="http://7xsssj.com2.z0.glb.qiniucdn.com/2017-01-16_173441.png" alt="二叉树遍历"></p>
<p>以上图1为例解释前序遍历：</p>
<p>首先访问根节点<code>a</code>=&gt;然后遍历左子树<code>b</code>=&gt;左子树<code>b</code>的左子树<code>d</code>=&gt;<code>d</code>的右孩子<code>e</code>&gt;此时<code>b</code>的左子树遍历完，遍历<code>b</code>的右子树<code>f</code>=&gt;<code>f</code>的左孩子<code>g</code>=&gt;左子树<code>b</code>遍历完，遍历根节点的右孩子<code>c</code>，完成=&gt;<code>abdefgc</code></p>
<p>中序遍历，后序遍历就不多说了，不同的只是访问的顺序。</p>
<p>注意：</p>
<p>(1)已知前序、后序遍历结果，不能推导出一棵确定的树；</p>
<p>(2)已知前序、中序遍历结果，能够推导出后序遍历结果；</p>
<p>(3)已知后序、中序遍历结果，能够推导出前序遍历结果；</p>
<h3 id="二叉搜索树的创建"><a href="#二叉搜索树的创建" class="headerlink" title="二叉搜索树的创建"></a>二叉搜索树的创建</h3><p>二叉查找树（BinarySearch Tree，也叫二叉搜索树，或称二叉排序树Binary Sort Tree）或者是一棵空树，或者是具有下列性质的二叉树：</p>
<pre><code>（1）若它的左子树不为空，则左子树上所有结点的值均小于它的根结点的值；

（2）若它的右子树不为空，则右子树上所有结点的值均大于它的根结点的值；

（3）它的左、右子树也分别为二叉查找树。
</code></pre><p>首先我们声明一个BinarySearchTree类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function BinarySearchTree() &#123;</div><div class="line">	var Node = function(key)&#123;</div><div class="line">        this.key = key;</div><div class="line">        this.left = null;</div><div class="line">        this.right = null;</div><div class="line">    &#125;;</div><div class="line">    var root=null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://7xsssj.com2.z0.glb.qiniucdn.com/binary6.gif" alt="二叉树"></p>
<p>和链表一样，二叉树也通过指针来表示节点之间的关系。在双向链表中，每一个节点有两个指针，一个指向下一个节点，一个指向上一个节点。对于树，使用同样的方式，只不过一个指向左孩子，一个指向右孩子。现在我们给这棵树弄一些方法：</p>
<ul>
<li>insert(key):向树中插入一个新的键(节点);</li>
<li>search(key):在书中查找一个键，如果节点存在，返回true;如果不存在，返回false;</li>
<li>inOrdertraverse:通过中序遍历方式遍历所有节点；</li>
<li>preorderTraverse:通过先序遍历方式遍历所有的节点；</li>
<li>postOrdertraverse:通过后序遍历的方式遍历所有的节点；</li>
<li>min:返回树中的最小值；</li>
<li>max:返回树中的最大值；</li>
<li>remove(key):从树中移除某个键；</li>
</ul>
<p>BinarySearchTree类的完整代码（充分添加注释）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">BinarySearchTree</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> Node = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.key = key;</div><div class="line">        <span class="keyword">this</span>.left = <span class="literal">null</span>;</div><div class="line">        <span class="keyword">this</span>.right = <span class="literal">null</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> root = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> newNode = <span class="keyword">new</span> Node(key);</div><div class="line"></div><div class="line">        <span class="comment">//判断是否是第一个节点，如果是作为根节点保存。不是调用inserNode方法</span></div><div class="line">        <span class="keyword">if</span> (root === <span class="literal">null</span>)&#123;</div><div class="line">            root = newNode;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            insertNode(root,newNode);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> insertNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, newNode</span>)</span>&#123;</div><div class="line">      <span class="comment">//判断两个节点的大小，根据二叉搜索树的特点左子树上所有结点的值均小于它的根结点的值，右子树上所有结点的值均大于它的根结点的值</span></div><div class="line">        <span class="keyword">if</span> (newNode.key &lt; node.key)&#123;</div><div class="line">            <span class="keyword">if</span> (node.left === <span class="literal">null</span>)&#123;</div><div class="line">                node.left = newNode;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                insertNode(node.left, newNode);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (node.right === <span class="literal">null</span>)&#123;</div><div class="line">                node.right = newNode;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                insertNode(node.right, newNode);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.getRoot = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.search = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> searchNode(root, key);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> searchNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, key</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (node === <span class="literal">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (key &lt; node.key)&#123;</div><div class="line">            <span class="keyword">return</span> searchNode(node.left, key);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.key)&#123;</div><div class="line">            <span class="keyword">return</span> searchNode(node.right, key);</div><div class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//element is equal to node.item</span></div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.inOrderTraverse = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</div><div class="line">        inOrderTraverseNode(root, callback);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> inOrderTraverseNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, callback</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</div><div class="line">            inOrderTraverseNode(node.left, callback);</div><div class="line">            callback(node.key);</div><div class="line">            inOrderTraverseNode(node.right, callback);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.preOrderTraverse = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</div><div class="line">        preOrderTraverseNode(root, callback);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> preOrderTraverseNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, callback</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</div><div class="line">            callback(node.key);</div><div class="line">            preOrderTraverseNode(node.left, callback);</div><div class="line">            preOrderTraverseNode(node.right, callback);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.postOrderTraverse = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</div><div class="line">        postOrderTraverseNode(root, callback);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> postOrderTraverseNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, callback</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</div><div class="line">            postOrderTraverseNode(node.left, callback);</div><div class="line">            postOrderTraverseNode(node.right, callback);</div><div class="line">            callback(node.key);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.min = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> minNode(root);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> minNode = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node)&#123;</div><div class="line">            <span class="keyword">while</span> (node &amp;&amp; node.left !== <span class="literal">null</span>) &#123;</div><div class="line">                node = node.left;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> node.key;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.max = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> maxNode(root);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> maxNode = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node)&#123;</div><div class="line">            <span class="keyword">while</span> (node &amp;&amp; node.right !== <span class="literal">null</span>) &#123;</div><div class="line">                node = node.right;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> node.key;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">        root = removeNode(root, element);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> findMinNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>)</span>&#123;</div><div class="line">        <span class="keyword">while</span> (node &amp;&amp; node.left !== <span class="literal">null</span>) &#123;</div><div class="line">            node = node.left;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> node;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> removeNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, element</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (node === <span class="literal">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (element &lt; node.key)&#123;</div><div class="line">            node.left = removeNode(node.left, element);</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element &gt; node.key)&#123;</div><div class="line">            node.right = removeNode(node.right, element);</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125; <span class="keyword">else</span> &#123; </div><div class="line">            <span class="comment">//处理三种特殊情况</span></div><div class="line">            <span class="comment">//1 - 叶子节点</span></div><div class="line">            <span class="comment">//2 - 只有一个孩子的节点</span></div><div class="line">            <span class="comment">//3 - 有两个孩子的节点</span></div><div class="line">            <span class="comment">//case 1</span></div><div class="line">            <span class="keyword">if</span> (node.left === <span class="literal">null</span> &amp;&amp; node.right === <span class="literal">null</span>)&#123;</div><div class="line">                node = <span class="literal">null</span>;</div><div class="line">                <span class="keyword">return</span> node;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//case 2</span></div><div class="line">            <span class="keyword">if</span> (node.left === <span class="literal">null</span>)&#123;</div><div class="line">                node = node.right;</div><div class="line">                <span class="keyword">return</span> node;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right === <span class="literal">null</span>)&#123;</div><div class="line">                node = node.left;</div><div class="line">                <span class="keyword">return</span> node;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//case 3</span></div><div class="line">            <span class="keyword">var</span> aux = findMinNode(node.right);</div><div class="line">            node.key = aux.key;</div><div class="line">            node.right = removeNode(node.right, aux.key);</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>树是一种比较常见的数据结构，不管是考试还是日常编码或是面试都是没法避免的一个知识点，此篇总结不甚完善，纰漏之处还望指出方便之后更改。敬请期待数据结构篇最后一篇文章：[学习javascript数据结构（五）——图]</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="https://zh.wikipedia.org/wiki/树_(数据结构" target="_blank" rel="external">树（数据结构）</a>)</li>
<li><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91#.E4.BA.8C.E5.8F.89.E6.A0.91.E7.9A.84.E7.B1.BB.E5.9E.8B" target="_blank" rel="external">二叉树</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 本文讲解了数据结构中的[树]的概念，尽可能通俗易懂的解释树这种数据结构的概念，使用javascript实现了树，如有纰漏，欢迎批评指正。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原文博客地址：&lt;a href=&quot;https://damonare.github.io/2017/01/14/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91/#more&quot;&gt;学习javascript数据结构(四)——树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人之所能，不能兼备，弃其所短，取其所长。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="javascript" scheme="http://damonare.github.io/tags/javascript/"/>
    
      <category term="数据结构" scheme="http://damonare.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构与算法" scheme="http://damonare.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript数据结构(三)——集合</title>
    <link href="http://damonare.github.io/2017/01/16/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%9B%86%E5%90%88/"/>
    <id>http://damonare.github.io/2017/01/16/学习javascript数据结构（三）——集合/</id>
    <published>2017-01-16T13:28:02.000Z</published>
    <updated>2017-01-16T13:28:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 本文讲解了数据结构中的[集合]概念，并使用javascript实现了集合。</p>
<ul>
<li>原文博客地址：<a href="http://damonare.github.io/2016/11/26/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%9B%86%E5%90%88/#more">学习javascript数据结构(三)——集合</a></li>
<li>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></li>
<li>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></li>
</ul>
<p><strong>人生多风雨，何处无险阻。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="集合简介"><a href="#集合简介" class="headerlink" title="集合简介"></a>集合简介</h3><p>在上一篇<a href="http://damonare.github.io/2016/11/09/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/#more">学习javascript数据结构(二)——链表</a>中我们说了链表这种数据结构，但归根结底，不论是栈，队列亦或是链表都是线性结构。他们都是一种很规矩的数据结构，就像幼儿园的小朋友排队乖乖的站在那不会动一样。</p>
<hr>
<p><img src="http://img.blog.csdn.net/20161129224745616" alt="幼儿园小朋友排队"></p>
<hr>
<p>然而纷杂的数据并不会总是排队站在那里，幼儿园小朋友一旦下了课那可就撒欢了，乱糟糟一团。可我们的幼儿园老师却能分辨出这些小朋友，因为啥？因为每个小朋友都在一个班里，而且每一个小朋友都有自己的名字。老师自然很容易就找到小朋友了。</p>
<hr>
<p><img src="http://img.blog.csdn.net/20161129224928510" alt="幼儿园小朋友下课"></p>
<hr>
<p>而本篇博文要说的集合正是一堆<code>乱糟糟的数据</code>，唯一的共同点是这些数据隶属于同一个<code>集合</code>,看下百科给出的解释：</p>
<blockquote>
<p>由一个或多个元素所构成的叫做集合。</p>
</blockquote>
<p>此处的元素就是小朋友了，他们所在的集合就是他们的班级。其实我们在高中的时候也接触过集合的概念。那时候还没有套路这个名词，单纯的岁月，那个年代对于集合是这么解释的：</p>
<blockquote>
<p>集合是指具有某种特定性质的具体的或抽象的对象汇总成的集体，这些对象称为该集合的元素。</p>
</blockquote>
<p>然后又是这么分类的：</p>
<ul>
<li>空集：{}</li>
<li>有限集：{a,b,4}</li>
<li>无限集：{1,2,3,4…}</li>
</ul>
<p>不过，数据结构中集合是没有无限集这个概念的。再然后那时候的集合还有这么几个特性：</p>
<ul>
<li>确定性：给定一个集合，任给一个元素，该元素或者属于或者不属于该集合，二者必居其一，不允许有模棱两可的情况出现。</li>
<li>互异性：一个集合中，任何两个元素都认为是不相同的，即每个元素只能出现一次。有时需要对同一元素出现多次的情形进行刻画，可以使用多重集，其中的元素允许出现多次。</li>
<li>无序性：一个集合中，每个元素的地位都是相同的，元素之间是无序的。集合上可以定义序关系，定义了序关系后，元素之间就可以按照序关系排序。但就集合本身的特性而言，元素之间没有必然的序。</li>
</ul>
<p>想当年哥还是个数学学霸，如今却沦落为了一个码农……真是让人唏嘘啊。咳咳！接着说：</p>
<p>集合还有这几种常见的基本操作：</p>
<ul>
<li>并集</li>
<li>交集</li>
<li>差集</li>
</ul>
<p>而且我们数据结构中的集合基本是也符合高中时候的数学中的概念的。接下来我们是用ES5来实现集合，为啥子这么说呢……因为在ES6中已经新给出了Set，Map等几个集合类，更加方便快捷的锁定键值对。</p>
<h3 id="集合的创建"><a href="#集合的创建" class="headerlink" title="集合的创建"></a>集合的创建</h3><p>首先我们先声明一个集合类：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> items=&#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，我们需要给链表声明一些方法：</p>
<ul>
<li>add(value):向集合添加一个新的项</li>
<li>remove(value):从集合移除一个值</li>
<li>has(value):如果值在集合中，返回true,否则返回false</li>
<li>clear():移除集合中的所有项</li>
<li>size():返回集合所包含的元素数量，与数组的length属性相似</li>
<li>values():返回一个集合中所有值的数组</li>
<li>union(setName):并集，返回包含两个集合所有元素的新集合(元素不重复)</li>
<li>intersection(setName):交集，返回包含两个集合中共有的元素的集合、</li>
<li>difference(setName):差集，返回包含所有存在本集合而不存在setName集合的元素的新集合</li>
<li>subset(setName):子集，验证setName是否是本集合的子集</li>
</ul>
<p>下面是Set类的完整代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> items = &#123;&#125;;</div><div class="line">    <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.has(value))&#123;</div><div class="line">            items[value] = value;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.delete = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.has(value))&#123;</div><div class="line">            <span class="keyword">delete</span> items[value];</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.has = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items.hasOwnProperty(value);</div><div class="line">        <span class="comment">//return value in items;</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        items = &#123;&#125;;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Modern browsers function</div><div class="line">     * IE9+, FF4+, Chrome5+, Opera12+, Safari5+</div><div class="line">     * @returns &#123;Number&#125;</div><div class="line">     */</div><div class="line">    <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.keys(items).length;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * cross browser compatibility - legacy browsers</div><div class="line">     * for modern browsers use size function</div><div class="line">     * @returns &#123;number&#125;</div><div class="line">     */</div><div class="line">    <span class="keyword">this</span>.sizeLegacy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">let</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> items) &#123;</div><div class="line">            <span class="keyword">if</span>(items.hasOwnProperty(key))</div><div class="line">                ++count;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Modern browsers function</div><div class="line">     * IE9+, FF4+, Chrome5+, Opera12+, Safari5+</div><div class="line">     * @returns &#123;Array&#125;</div><div class="line">     */</div><div class="line">    <span class="keyword">this</span>.values = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">let</span> values = [];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>, keys=<span class="built_in">Object</span>.keys(items); i&lt;keys.length; i++) &#123;</div><div class="line">            values.push(items[keys[i]]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> values;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.valuesLegacy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">let</span> values = [];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> items) &#123;</div><div class="line">            <span class="keyword">if</span>(items.hasOwnProperty(key)) &#123;</div><div class="line">                values.push(items[key]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> values;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.getItems = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> items;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.union = <span class="function"><span class="keyword">function</span>(<span class="params">otherSet</span>)</span>&#123;</div><div class="line">        <span class="keyword">let</span> unionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">        <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">            unionSet.add(values[i]);</div><div class="line">        &#125;</div><div class="line">        values = otherSet.values();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">            unionSet.add(values[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> unionSet;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.intersection = <span class="function"><span class="keyword">function</span>(<span class="params">otherSet</span>)</span>&#123;</div><div class="line">        <span class="keyword">let</span> intersectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">        <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">            <span class="keyword">if</span> (otherSet.has(values[i]))&#123;</div><div class="line">                intersectionSet.add(values[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> intersectionSet;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.difference = <span class="function"><span class="keyword">function</span>(<span class="params">otherSet</span>)</span>&#123;</div><div class="line">        <span class="keyword">let</span> differenceSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">        <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">            <span class="keyword">if</span> (!otherSet.has(values[i]))&#123;    </div><div class="line">                differenceSet.add(values[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> differenceSet;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.subset = <span class="function"><span class="keyword">function</span>(<span class="params">otherSet</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.size() &gt; otherSet.size())&#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">                <span class="keyword">if</span> (!otherSet.has(values[i]))&#123;  </div><div class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是ES6版本代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> Set2 = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Set2</span> </span>&#123;</div><div class="line">        <span class="keyword">constructor</span> () &#123;</div><div class="line">            items.set(<span class="keyword">this</span>, &#123;&#125;);</div><div class="line">        &#125;</div><div class="line">        add(value)&#123;</div><div class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.has(value))&#123;</div><div class="line">                <span class="keyword">let</span> items_ = items.get(<span class="keyword">this</span>);</div><div class="line">                items_[value] = value;</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">delete</span>(value)&#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.has(value))&#123;</div><div class="line">                <span class="keyword">let</span> items_ = items.get(<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">delete</span> items_[value];</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        has(value)&#123;</div><div class="line">            <span class="keyword">let</span> items_ = items.get(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span> items_.hasOwnProperty(value);</div><div class="line">        &#125;</div><div class="line">        clear()&#123;</div><div class="line">            items.set(<span class="keyword">this</span>, &#123;&#125;);</div><div class="line">        &#125;</div><div class="line">        size()&#123;</div><div class="line">            <span class="keyword">let</span> items_ = items.get(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.keys(items_).length;</div><div class="line">        &#125;</div><div class="line">        values()&#123;</div><div class="line">            <span class="keyword">let</span> values = [];</div><div class="line">            <span class="keyword">let</span> items_ = items.get(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>, keys=<span class="built_in">Object</span>.keys(items_); i&lt;keys.length; i++) &#123;</div><div class="line">                values.push(items_[keys[i]]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> values;</div><div class="line">        &#125;</div><div class="line">        getItems()&#123;</div><div class="line">            <span class="keyword">return</span> items.get(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">        union(otherSet)&#123;</div><div class="line">            <span class="keyword">let</span> unionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">            <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">                unionSet.add(values[i]);</div><div class="line">            &#125;</div><div class="line">            values = otherSet.values();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">                unionSet.add(values[i]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> unionSet;</div><div class="line">        &#125;</div><div class="line">        intersection(otherSet)&#123;</div><div class="line">            <span class="keyword">let</span> intersectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">            <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">                <span class="keyword">if</span> (otherSet.has(values[i]))&#123;</div><div class="line">                    intersectionSet.add(values[i]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> intersectionSet;</div><div class="line">        &#125;</div><div class="line">        difference(otherSet)&#123;</div><div class="line">            <span class="keyword">let</span> differenceSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">            <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">                <span class="keyword">if</span> (!otherSet.has(values[i]))&#123;</div><div class="line">                    differenceSet.add(values[i]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> differenceSet;</div><div class="line">        &#125;;</div><div class="line">        subset(otherSet)&#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.size() &gt; otherSet.size())&#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">                    <span class="keyword">if</span> (!otherSet.has(values[i]))&#123;</div><div class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Set2;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>集合是一种比较常见的数据结构，在JS中我们已经有了一种类似哈希表的东西：Object(对象)。但现在我们所说的集合只是以[value,value]形式存储数据.敬请期待：<a href="https://damonare.github.io/2017/01/14/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91/#more">学习javascript数据结构(四)——树</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 本文讲解了数据结构中的[集合]概念，并使用javascript实现了集合。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原文博客地址：&lt;a href=&quot;http://damonare.github.io/2016/11/26/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%9B%86%E5%90%88/#more&quot;&gt;学习javascript数据结构(三)——集合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人生多风雨，何处无险阻。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="javascript" scheme="http://damonare.github.io/tags/javascript/"/>
    
      <category term="数据结构" scheme="http://damonare.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构与算法" scheme="http://damonare.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript数据结构(一)——栈和队列</title>
    <link href="http://damonare.github.io/2017/01/16/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>http://damonare.github.io/2017/01/16/学习javascript数据结构（一）——栈和队列/</id>
    <published>2017-01-16T07:52:10.000Z</published>
    <updated>2017-01-16T07:52:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 本文使用javascript数组的API定义了栈和队列并较为详细的说明了栈和队列的概念。</p>
<ul>
<li><p>原文地址：<a href="http://damonare.github.io/2016/11/01/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/#more">学习javascript数据结构(一)——栈和队列</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>只要你不计较得失，人生还有什么不能想法子克服的。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>几乎所有的编程语言都原生支持数组类型，因为数组是最简单的内存数据结构。javascript也有数组类型，而数组呢，其实就是一种特殊的栈或是队列，利用javascript&nbsp;Array所内置的API可以很方便的模拟栈和队列。</p>
<blockquote>
<p>我想对于数组每一个学过编程语言的都不会陌生吧，我们知道，我们可以在数组的任意位置添加或是删除元素，然而，有时候我们还需要一种在添加或是删除元素的时候有更多控制的数据结构。有两种数据结构类似于数组。但在添加或是删除元素的时候更为的可控。他们就是栈和队列。</p>
</blockquote>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><strong>栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或是待删除的元素都保存在栈的末尾。我们称作栈顶，而另一端我们称作栈底。</strong><br><br><br>在现实生活中就有很多栈的例子，比如下图的书本，这一摞书如果要取肯定是先去最上面的那一本，但它是最后一个放上去的，也就是栈顶的元素都是待添加或是待删除的。这就是后进先出的实际例子。<br></p>
<blockquote>
<p><img src="http://img.blog.csdn.net/20161102145616341" alt="栈"></p>
</blockquote>
<h4 id="栈的创建"><a href="#栈的创建" class="headerlink" title="栈的创建"></a>栈的创建</h4><p>首先我们先创建一个类：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//各种属性和方法的声明</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们需要一种数据结构来保存栈里面的数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> items=[];</div></pre></td></tr></table></figure>
<p>接下来，我们需要给栈声明一些方法：</p>
<ul>
<li>push(element):添加一个或是几个新元素到栈顶。</li>
<li>pop():移除栈顶的元素，同时返回被移除元素。</li>
<li>peek():返回栈顶的元素，但并不对栈顶的元素做出任何的修改。</li>
<li>isEmpty():检查栈内是否有元素，如果有返回true，没有返回false。</li>
<li>clear():清除栈里的元素。</li>
<li>size():返回栈的元素个数。</li>
<li>print():打印栈里的元素。</li>
</ul>
<h4 id="栈的完整代码"><a href="#栈的完整代码" class="headerlink" title="栈的完整代码"></a>栈的完整代码</h4><p>我们通过javascript提供的API，实现栈如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> items = [];</div><div class="line">    <span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">        items.push(element);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items.pop();</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.peek = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items[items.length<span class="number">-1</span>];</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items.length == <span class="number">0</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items.length;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        items = [];</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(items.toString());</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items.toString();</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ES6版本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> _items = <span class="built_in">Symbol</span>();</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack2</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> () &#123;</div><div class="line">        <span class="keyword">this</span>[_items] = [];</div><div class="line">    &#125;</div><div class="line">    push(element)&#123;</div><div class="line">        <span class="keyword">this</span>[_items].push(element);</div><div class="line">    &#125;</div><div class="line">    pop()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>[_items].pop();</div><div class="line">    &#125;</div><div class="line">    peek()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>[_items][<span class="keyword">this</span>[_items].length<span class="number">-1</span>];</div><div class="line">    &#125;</div><div class="line">    isEmpty()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>[_items].length == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    size()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>[_items].length;</div><div class="line">    &#125;</div><div class="line">    clear()&#123;</div><div class="line">        <span class="keyword">this</span>[_items] = [];</div><div class="line">    &#125;</div><div class="line">    print()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.toString());</div><div class="line">    &#125;</div><div class="line">    toString()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>[_items].toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用栈"><a href="#使用栈" class="headerlink" title="使用栈"></a>使用栈</h4><p>创建完了栈，也给他了方法，然后我们来实例化一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stack=<span class="keyword">new</span> Stack();</div><div class="line"><span class="built_in">console</span>.log(stack.isEmpty());</div><div class="line"><span class="comment">//true</span></div><div class="line">stack.push(<span class="number">1</span>);</div><div class="line">stack.push(<span class="number">3</span>);</div><div class="line"><span class="comment">//添加元素</span></div><div class="line"><span class="built_in">console</span>.log(stack.peek());</div><div class="line"><span class="comment">//输出栈顶元素3</span></div><div class="line"><span class="built_in">console</span>.log(stack.size());</div><div class="line"><span class="comment">//2</span></div><div class="line"><span class="comment">//输出元素个数</span></div></pre></td></tr></table></figure>
<p>其余方法调用读者可自行尝试。</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>我们已经接触了栈，接下来要说的队列和栈十分相似，他们都是线性表，元素都是有序的<br>。队列和栈不同的是，队列遵循的是FIFO，也就是先进先出的原则。队列从尾部添加新元素，从顶部移除元素，最新添加的元素必须排列在队列的末尾。<br><br><br>在现实生活中，最常见的队列就是排队，如下图，先进入队列的先接受服务，后进入队列的必须排在队列末尾。</p>
<blockquote>
<p><img src="http://img.blog.csdn.net/20161102145601043" alt="队列"></p>
</blockquote>
<h4 id="队列的创建"><a href="#队列的创建" class="headerlink" title="队列的创建"></a>队列的创建</h4><p>首先我们声明一个类：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//这里是队列的属性和方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们同样创建一个保存元素的数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> items=[];</div></pre></td></tr></table></figure>
<p>接下来声明一些队列可用的方法：</p>
<ul>
<li>enqueue(element):向队列尾部添加一个（或是多个）元素。</li>
<li>dequeue():移除队列的第一个元素，并返回被移除的元素。</li>
<li>front():返回队列的第一个元素——最先被添加的也是最先被移除的元素。队列不做任何变动。</li>
<li>isEmpty():检查队列内是否有元素，如果有返回true，没有返回false。</li>
<li>size():返回队列的长度。</li>
<li>print():打印队列的元素。</li>
</ul>
<h4 id="队列的完整代码"><a href="#队列的完整代码" class="headerlink" title="队列的完整代码"></a>队列的完整代码</h4><p>我们通过javascript提供的API，实现队列如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> items = [];</div><div class="line">    <span class="keyword">this</span>.enqueue = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">        items.push(element);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.dequeue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items.shift();</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.front = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items[<span class="number">0</span>];</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items.length == <span class="number">0</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        items = [];</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items.length;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(items.toString());</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ES6版本:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> Queue2 = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Queue2</span> </span>&#123;</div><div class="line">        <span class="keyword">constructor</span> () &#123;</div><div class="line">            items.set(<span class="keyword">this</span>, []);</div><div class="line">        &#125;</div><div class="line">        enqueue(element) &#123;</div><div class="line">            <span class="keyword">let</span> q = items.get(<span class="keyword">this</span>);</div><div class="line">            q.push(element);</div><div class="line">        &#125;</div><div class="line">        dequeue() &#123;</div><div class="line">            <span class="keyword">let</span> q = items.get(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">let</span> r = q.shift();</div><div class="line">            <span class="keyword">return</span> r;</div><div class="line">        &#125;</div><div class="line">        front() &#123;</div><div class="line">            <span class="keyword">let</span> q = items.get(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span> q[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        isEmpty()&#123;</div><div class="line">            <span class="keyword">return</span> items.get(<span class="keyword">this</span>).length == <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        size()&#123;</div><div class="line">            <span class="keyword">let</span> q = items.get(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span> q.length;</div><div class="line">        &#125;</div><div class="line">        clear()&#123;</div><div class="line">            items.set(<span class="keyword">this</span>, []);</div><div class="line">        &#125;</div><div class="line">        print()&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.toString());</div><div class="line">        &#125;</div><div class="line">        toString()&#123;</div><div class="line">            <span class="keyword">return</span> items.get(<span class="keyword">this</span>).toString();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Queue2;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h4 id="使用队列"><a href="#使用队列" class="headerlink" title="使用队列"></a>使用队列</h4><p>创建完了队列，也给他了方法，然后我们来实例化一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> queue=<span class="keyword">new</span> Queue();</div><div class="line"><span class="built_in">console</span>.log(queue.isEmpty());</div><div class="line"><span class="comment">//true</span></div><div class="line">queue.enqueue(<span class="number">1</span>);</div><div class="line">queue.enqueue(<span class="number">3</span>);</div><div class="line"><span class="comment">//添加元素</span></div><div class="line"><span class="built_in">console</span>.log(queue.front());</div><div class="line"><span class="comment">//返回队列的第一个元素1</span></div><div class="line"><span class="built_in">console</span>.log(queue.size());</div><div class="line"><span class="comment">//2</span></div><div class="line"><span class="comment">//输出元素个数</span></div></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote>
<p>这篇博客使用javascript实现了栈和队列这两种数据结构。关于具体的应用的有机会补上。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 本文使用javascript数组的API定义了栈和队列并较为详细的说明了栈和队列的概念。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://damonare.github.io/2016/11/01/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/#more&quot;&gt;学习javascript数据结构(一)——栈和队列&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;只要你不计较得失，人生还有什么不能想法子克服的。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="javascript" scheme="http://damonare.github.io/tags/javascript/"/>
    
      <category term="数据结构" scheme="http://damonare.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构与算法" scheme="http://damonare.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>从隐藏元素谈起</title>
    <link href="http://damonare.github.io/2017/01/02/%E4%BB%8E%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E8%B0%88%E8%B5%B7/"/>
    <id>http://damonare.github.io/2017/01/02/从隐藏元素谈起/</id>
    <published>2017-01-02T13:28:44.000Z</published>
    <updated>2017-01-02T13:28:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 本文详细讲述了在网页中用CSS隐藏元素的七种方法。</p>
<ul>
<li>原文博客地址：<a href="http://damonare.github.io/2016/09/05/%E4%BB%8E%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E8%B0%88%E8%B5%B7/#more">从隐藏元素谈起</a></li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>念念不忘,必有回响;有一口气,点一盏灯。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>说起隐藏元素我想每一个前端er都能说起几种，但能说全的我想就不是很多了。博主总结了几种隐藏元素的方法，总结如下：</p>
<blockquote>
<p>overflow:hidden<br>opacity:0；<br>visibility:hidden<br>display:none<br>position:absolute<br>clip(clip-path):rect()/inset()/polygon()<br>z-index:-1000<br>transform:scaleY(0)</p>
</blockquote>
<p><strong>我们为什么会需要这么多隐藏元素的方法呢，而且他们看起来实现的都是同样的效果。其实每一种方法实际上都有一些细微的不同，这些不同决定了在一些特定场合下使用哪一种方法。我们下面细细探讨下这些细微之处.</strong></p>
<h3 id="1-overflow"><a href="#1-overflow" class="headerlink" title="1. overflow"></a>1. overflow</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.hide</span>&#123;</div><div class="line">	 <span class="attribute">overflow</span>:hidden; <span class="comment">/* 占据空间，无法点击 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>overflow的hidden用来隐藏元素溢出部分，占据空间，无法响应点击事件。</strong></p>
<h3 id="2-opacity"><a href="#2-opacity" class="headerlink" title="2.opacity"></a>2.opacity</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.hide</span>&#123;</div><div class="line">	<span class="attribute">opacity</span>:<span class="number">0</span>;<span class="comment">/* 占据空间，可以点击 */</span></div><div class="line">&#125;</div><div class="line"><span class="selector-class">.hide_2</span>&#123;</div><div class="line">	<span class="attribute">-webkit-filter</span>:<span class="built_in">opacity</span>(0);</div><div class="line">	<span class="attribute">filter</span>:<span class="built_in">opacity</span>(0);<span class="comment">/* 占据空间，可以点击 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>过滤元素filter也可使用opacity值设置透明度，不过filter现在的兼容性不好，只支持webkit内核，这里顺带一提。</p>
</blockquote>
<p><strong>opacity是用来设置元素透明度的，但当设置成0的时候也就相当于隐藏元素了。因此，元素依然存在原来的位置，占据空间也可响应事件。如果你打算使用 opacity 属性在读屏软件中隐藏元素，很不幸，你并不能如愿。元素和它所有的内容会被读屏软件阅读，就像网页上的其他元素那样。换句话说，元素的行为就和它们不透明时一致。</strong></p>
<h3 id="3-visibility"><a href="#3-visibility" class="headerlink" title="3.visibility"></a>3.visibility</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.hide</span>&#123;</div><div class="line">	<span class="attribute">visibility</span>:hidden; <span class="comment">/* 占据空间，无法点击 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>如同 opacity 属性，被隐藏的元素依然会对我们的网页布局起作用。与 opacity 唯一不同的是它不会响应任何用户交互。此外，元素在读屏软件中也会被隐藏</strong></p>
<h3 id="4-display"><a href="#4-display" class="headerlink" title="4.display"></a>4.display</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.hide</span>&#123;</div><div class="line">    <span class="attribute">display</span>:none;<span class="comment">/* 不占据空间，无法点击 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>经典的display隐藏元素,这个是彻底的隐藏了元素，不占据空间，也就不影响布局，当然也无法响应事件。</strong></p>
<h3 id="5-position"><a href="#5-position" class="headerlink" title="5.position"></a>5.position</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">.hide&#123;</div><div class="line">    position：absolute;</div><div class="line">    left:-99999px;</div><div class="line">	top:-90999px;/* 不占据空间，无法点击 */</div><div class="line">&#125;</div><div class="line">.hide-2&#123;</div><div class="line">	position：relative;</div><div class="line">	left:-99999px;</div><div class="line">	top:-90999px;/* 占据空间，无法点击 */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设有一个元素你想要与它交互，但是你又不想让它影响你的网页布局，没有合适的属性可以处理这种情况（opacity 和 visibility 影响布局， display 不影响布局但又无法直接交互——译者注）。在这种情况下，你只能考虑将元素移出可视区域。这个办法既不会影响布局，有能让元素保持可以操作。下采用这种办法未尝不可。</p>
<h3 id="6-clip-clip-path"><a href="#6-clip-clip-path" class="headerlink" title="6.clip/clip-path"></a>6.clip/clip-path</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.hide</span>&#123;</div><div class="line">    <span class="attribute">position</span>:absolute;<span class="comment">/*fixed*/</span></div><div class="line">	<span class="attribute">clip</span>:<span class="built_in">rect</span>(top,right,bottom,left);<span class="comment">/* 占据空间，无法点击 */</span></div><div class="line">&#125;</div><div class="line"><span class="selector-class">.hide_2</span> &#123;</div><div class="line">  <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(0px 0px,0px 0px,0px 0px,0px 0px);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>隐藏元素的另一种方法是通过剪裁它们来实现。在以前，这可以通过 clip 属性来实现，但是这个属性被废弃了(现在浏览器依然支持)，换成一个更好的属性叫做 clip-path。clip-path属性实在是用处大大滴有，可以很容易的实现一些复杂的图形<a href="http://species-in-pieces.com/#" target="_blank" rel="external">大漠老师分享的一个链接</a>，该链接里的图形大多都是用clip-path的polygon值来实现的。但可惜的是依旧只能在chrome40+浏览器里使用.</strong></p>
<h3 id="7-z-index"><a href="#7-z-index" class="headerlink" title="7.z-index"></a>7.z-index</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.hide</span>&#123;</div><div class="line">	<span class="attribute">position</span>:absolute;</div><div class="line">	<span class="attribute">z-index</span>:-<span class="number">1000</span>;<span class="comment">/* 不占据空间，无法点击 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>通过设置z-index值使其它元素遮盖该元素也算是一种隐藏了。</strong></p>
<h3 id="8-transform"><a href="#8-transform" class="headerlink" title="8. transform"></a>8. transform</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.hide</span>&#123;</div><div class="line">	<span class="attribute">transform</span>: <span class="built_in">scale</span>(0,0)<span class="comment">/* 占据空间，无法点击 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote>
<p>在这篇教程里，我们看了 7 种不同的通过 CSS 隐藏元素的方法。每一种方法都与其他几种有一点区别。知道你想要实现什么有助于你决定采用哪一个属性，随着时间推移，你就能根据实际需求本能地选择最佳方式了。如果你对于隐藏元素的这些方法还有任何问题，请在评论中留言。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 本文详细讲述了在网页中用CSS隐藏元素的七种方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原文博客地址：&lt;a href=&quot;http://damonare.github.io/2016/09/05/%E4%BB%8E%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E8%B0%88%E8%B5%B7/#more&quot;&gt;从隐藏元素谈起&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;念念不忘,必有回响;有一口气,点一盏灯。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="CSS" scheme="http://damonare.github.io/tags/CSS/"/>
    
      <category term="前端" scheme="http://damonare.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTML" scheme="http://damonare.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Javascript填坑史</title>
    <link href="http://damonare.github.io/2016/12/23/Javascript%E5%A1%AB%E5%9D%91%E5%8F%B2/"/>
    <id>http://damonare.github.io/2016/12/23/Javascript填坑史/</id>
    <published>2016-12-23T09:38:48.000Z</published>
    <updated>2016-12-23T09:38:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 这是笔者平时积累的一些觉得比较有意思或是比较有难度的JavaScript题目理解和心得，会保持长期更新。</p>
<ul>
<li><p>原文地址：<a href="http://damonare.github.io/2016/09/05/javascript%E5%A1%AB%E5%9D%91%E5%8F%B2/#more">Javascript填坑史</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>人生莫作妇人身，百年苦乐由他人。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-setTimeout和setInterval深入理解"><a href="#1-setTimeout和setInterval深入理解" class="headerlink" title="1.setTimeout和setInterval深入理解"></a>1.setTimeout和setInterval深入理解</h3><p>在<a href="https://segmentfault.com/a/1190000004034739" target="_blank" rel="external">setTimeout和setInterval深入理解</a>这篇博客里笔者曾做过总结，我们知道JavaScript试单线程的产物，两个函数就是利用了插入代码的方式实现了伪异步，和AJAX的原理实际上是一样的。下面来看下这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">"1"</span>);</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">"3"</span>)</div><div class="line">	&#125;,<span class="number">0</span>);</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"2"</span>);</div></pre></td></tr></table></figure>
<p>结果：控制台依次输出1,2,3;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'can you see me?'</span>);&#125;,<span class="number">1000</span>);</div><div class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你觉得这段代码的执行结果是什么呢？答案是，alert永远不会出现。<br>&nbsp;&nbsp;&nbsp;&nbsp;这是为什么呢？因为，while这段代码没有执行完，所以插入在后面的代码便永远不会执行。<br>综上所述，其实JS终归是单线程产物。无论如何“异步”都不可能突破单线程这个障碍。所以许多的“异步调用”（包括Ajax）事实上也只是“伪异步”而已。只要理解了这么一个概念，也许理解setTimeout和setInterval也就不难了。</p>
<h3 id="2-闭包初探小题"><a href="#2-闭包初探小题" class="headerlink" title="2. 闭包初探小题"></a>2. 闭包初探小题</h3><p>在<a href="https://segmentfault.com/a/1190000004093058" target="_blank" rel="external">JavaScript闭包初探</a>这篇博客里面进行了初步探讨，有几个小题个人觉得还是比较有意思的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">　　<span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line">　　<span class="keyword">var</span> object = &#123;</div><div class="line">　　　　<span class="attr">name</span> : <span class="string">"My Object"</span>,</div><div class="line">　　　　<span class="attr">getNameFunc</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　　　<span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">　　　　　　&#125;;</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;;</div><div class="line">　　alert(object.getNameFunc()());<span class="comment">//The Window</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">　  <span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line">　　<span class="keyword">var</span> object = &#123;</div><div class="line">　　　　<span class="attr">name</span> : <span class="string">"My Object"</span>,</div><div class="line">　　　　<span class="attr">getNameFunc</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　<span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">　　　　　　<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　　　<span class="keyword">return</span> that.name;</div><div class="line">　　　　　　&#125;;</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;;　　alert(object.getNameFunc()());<span class="comment">//My Object</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">n,o</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(o)</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">fun</span>:<span class="function"><span class="keyword">function</span>(<span class="params">m</span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> fun(m,n);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = fun(<span class="number">0</span>);  a.fun(<span class="number">1</span>);  a.fun(<span class="number">2</span>);  a.fun(<span class="number">3</span>);<span class="comment">//undefined,?,?,?</span></div><div class="line"><span class="keyword">var</span> b = fun(<span class="number">0</span>).fun(<span class="number">1</span>).fun(<span class="number">2</span>).fun(<span class="number">3</span>);<span class="comment">//undefined,?,?,?</span></div><div class="line"><span class="keyword">var</span> c = fun(<span class="number">0</span>).fun(<span class="number">1</span>);  c.fun(<span class="number">2</span>);  c.fun(<span class="number">3</span>);<span class="comment">//undefined,?,?,?</span></div></pre></td></tr></table></figure>
<blockquote>
<p>//问:三行a,b,c的输出分别是什么？</p>
</blockquote>
<p><strong>这是一道非常典型的JS闭包问题。其中嵌套了三层fun函数，搞清楚每层fun的函数是那个fun函数尤为重要。</strong></p>
<blockquote>
<p>//答案：<br>//a: undefined,0,0,0<br>//b: undefined,0,1,2<br>//c: undefined,0,1,1</p>
</blockquote>
<h3 id="3-Array-map-Number-parseInt"><a href="#3-Array-map-Number-parseInt" class="headerlink" title="3. Array/map,Number/parseInt"></a>3. Array/map,Number/parseInt</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>].map(<span class="built_in">parseInt</span>)<span class="comment">//求输出结果</span></div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;首先, map接受两个参数, 一个回调函数 callback, 一个回调函数的this值<br>其中回调函数接受三个参数 currentValue, index, arrary;而题目中, map只传入了回调函数–parseInt.其次, parseInt 只接受两个两个参数 string, radix(基数). radix的合法区间是2-36. 0或是默认是10.所以本题即问</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">parseInt</span>(<span class="string">'1'</span>, <span class="number">0</span>);</div><div class="line"><span class="built_in">parseInt</span>(<span class="string">'2'</span>, <span class="number">1</span>);</div><div class="line"><span class="built_in">parseInt</span>(<span class="string">'3'</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>后两者参数不合法.所以答案是：[1, NaN, NaN]；</p>
<h3 id="4-nbsp-0-1-0-2-0-3和9999999999999999-10000000000000000"><a href="#4-nbsp-0-1-0-2-0-3和9999999999999999-10000000000000000" class="headerlink" title="4.&nbsp;0.1+0.2!=0.3和9999999999999999 == 10000000000000000;"></a>4.&nbsp;0.1+0.2!=0.3和9999999999999999 == 10000000000000000;</h3><blockquote>
<p>根据语言规范，JavaScript 采用“IEEE 754 标准定义的双精度64位格式”（”double-precision 64-bit format IEEE 754 values”）表示数字。据此我们能得到一个有趣的结论，和其他编程语言（如 C 和 Java）不同，JavaScript 不区分整数值和浮点数值，所有数字在 JavaScript 中均用浮点数值表示，所以在进行数字运算的时候要特别注意。<a href="http://demon.tw/copy-paste/javascript-precision.html" target="_blank" rel="external">精度丢失</a>看看下面的例子:</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">0.1</span> + <span class="number">0.2</span> = <span class="number">0.30000000000000004</span></div></pre></td></tr></table></figure>
<blockquote>
<p>在具体实现时，整数值通常被视为32位整型变量，在个别实现（如某些浏览器）中也以32位整型变量的形式进行存储，直到它被用于执行某些32位整型不支持的操作，这是为了便于进行位操作。大整数精度在2的53次方以内是不会丢失的，也就是说浏览器能精确计算Math.pow(2,53)以内所有的数，小数精度，当十进制小数的二进制表示的有限数字不超过 52 位时，在 JavaScript 里也是可以精确存储的。<br>解决办法：Math.round( (.1+.2)*100)/100;</p>
</blockquote>
<h3 id="5-1-lt-2-lt-3-3-lt-2-lt-1"><a href="#5-1-lt-2-lt-3-3-lt-2-lt-1" class="headerlink" title="5. [1&lt;2&lt;3,3&lt;2&lt;1]"></a>5. [1&lt;2&lt;3,3&lt;2&lt;1]</h3><p>&nbsp;&nbsp;此题会让人误以为是2&gt;1&amp;&amp;2&lt;3,其实不是的，这个题等价于</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&lt;<span class="number">2</span>=&gt;<span class="literal">true</span>;</div><div class="line"><span class="literal">true</span>&lt;<span class="number">3</span>=&gt;<span class="number">1</span>&lt;<span class="number">3</span>=&gt;<span class="literal">true</span>;</div><div class="line"><span class="number">3</span>&lt;<span class="number">2</span>=&gt;<span class="literal">true</span>;</div><div class="line"><span class="literal">false</span>&lt;<span class="number">1</span>=&gt;<span class="number">0</span>&lt;<span class="number">1</span>=&gt;<span class="literal">true</span>;</div></pre></td></tr></table></figure>
<p><strong>答案：[true,true]</strong> 这个题的重点是对于运算符的理解，一是javascript对于不同类型数值的比较规则，详见<a href="http://dorey.github.io/JavaScript-Equality-Table/" target="_blank" rel="external">js比较表</a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness" target="_blank" rel="external">javascript相等性判断</a>；二是对于<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Less_than_operator" target="_blank" rel="external">比较操作符</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Assignment_Operators" target="_blank" rel="external">赋值运算符</a>的理解，即一个自左向右一个自右向左~</p>
<h3 id="6-浏览器懵逼史（1）"><a href="#6-浏览器懵逼史（1）" class="headerlink" title="6. 浏览器懵逼史（1）"></a>6. 浏览器懵逼史（1）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">3.</span>toString;</div><div class="line"><span class="number">3.</span>.toString;</div><div class="line"><span class="number">3.</span>..toString;</div></pre></td></tr></table></figure>
<p>这个题感觉脑洞很大啊~先说答案：error,’3’,error;<br>可如果是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a=<span class="number">3</span>;</div><div class="line">a.toString;</div></pre></td></tr></table></figure>
<p>却又合法了答案就是’3’;<br>为啥呢？<br>因为在JS中1.1,1.,.1都是合法数字啊！那么在解析3.toString的时候到底是这是个数字呢，还是方法调用呢？浏览器就懵逼了呗，只能抛出一个error,所以说感觉此题就是在戏耍浏览器……</p>
<h3 id="7-声明提升"><a href="#7-声明提升" class="headerlink" title="7. 声明提升"></a>7. 声明提升</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">'World!'</span>;</div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">'undefined'</span>) &#123;</div><div class="line">        <span class="keyword">var</span> name = <span class="string">'Jack'</span>;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Goodbye '</span> + name);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + name);</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>答案是什么呢…笔者第一次做的时候傻傻的觉得是Hello,world…实则不然，正确答案是:Goodbye Jack;<br>为什么呢，声明提升…上述代码相当于下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">'World!'</span>;</div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">'undefined'</span>) &#123;</div><div class="line">        name = <span class="string">'Jack'</span>;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Goodbye '</span> + name);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + name);</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h3 id="8-坑爹史（1）"><a href="#8-坑爹史（1）" class="headerlink" title="8. 坑爹史（1）"></a>8. 坑爹史（1）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">0</span>];</div><div class="line"><span class="keyword">if</span> ([<span class="number">0</span>]) &#123;</div><div class="line">  <span class="built_in">console</span>.log(a == <span class="literal">true</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"wut"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>读者们你们觉得此题答案是什么呢？true?因为[0]被看做Boolean是被认为是true，理所当然的推出来[0]==true,控制台输出true…看似没错，然而并不是这样滴~[0]这个玩意儿在单独使用的时候是被认为是true的，但用作比较的时候它是false…所以正确答案是false；不信的话，F12控制台输出[0]==false；看是不是true……</p>
<p>###9. 坑爹史（2）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> + - + + + - + <span class="number">1</span></div></pre></td></tr></table></figure>
<p>这题应该是等同于：（倒着看）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> + <span class="function">(<span class="params">a</span>)  =&gt;</span> <span class="number">2</span></div><div class="line">a = - <span class="function">(<span class="params">b</span>) =&gt;</span> <span class="number">1</span></div><div class="line">b = + <span class="function">(<span class="params">c</span>) =&gt;</span> <span class="number">-1</span></div><div class="line">c = + <span class="function">(<span class="params">d</span>) =&gt;</span> <span class="number">-1</span></div><div class="line">d = + <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="number">-1</span></div><div class="line">e = + <span class="function">(<span class="params">f</span>) =&gt;</span> <span class="number">-1</span></div><div class="line">f = - <span class="function">(<span class="params">g</span>) =&gt;</span> <span class="number">-1</span></div><div class="line">g = + <span class="number">1</span>   =&gt; <span class="number">1</span></div></pre></td></tr></table></figure>
<p>答案是2</p>
<h3 id="10-坑爹史（3）"><a href="#10-坑爹史（3）" class="headerlink" title="10. 坑爹史（3）"></a>10. 坑爹史（3）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sidEffecting</span>(<span class="params">ary</span>) </span>&#123;</div><div class="line">  ary[<span class="number">0</span>] = ary[<span class="number">2</span>];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a,b,c</span>) </span>&#123;</div><div class="line">  c = <span class="number">10</span></div><div class="line">  sidEffecting(<span class="built_in">arguments</span>);</div><div class="line">  <span class="keyword">return</span> a + b + c;</div><div class="line">&#125;</div><div class="line">bar(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>此题涉及ES6语法，实在坑的不行…<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments" target="_blank" rel="external">arguments</a><br>首先 The arguments object is an Array-like object corresponding to the arguments passed to a function.也就是说 arguments 是一个 object, c 就是 arguments<a href="https://segmentfault.com/a/1190000004093058" target="_blank" rel="external">2</a>, 所以对于 c 的修改就是对 arguments<a href="https://segmentfault.com/a/1190000004093058" target="_blank" rel="external">2</a> 的修改.<br>所以答案是 21.<br>然而!!!!!!<br>当函数参数涉及到 any rest parameters, any default parameters or any destructured parameters 的时候, 这个 arguments 就不在是一个 mapped arguments object 了…..请看:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sidEffecting</span>(<span class="params">ary</span>) </span>&#123;</div><div class="line">  ary[<span class="number">0</span>] = ary[<span class="number">2</span>];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a,b,c=<span class="number">3</span></span>) </span>&#123;</div><div class="line">  c = <span class="number">10</span></div><div class="line">  sidEffecting(<span class="built_in">arguments</span>);</div><div class="line">  <span class="keyword">return</span> a + b + c;</div><div class="line">&#125;</div><div class="line">bar(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>答案是12…<br>请读者细细体会!!</p>
<h3 id="11-坑爹史（4）"><a href="#11-坑爹史（4）" class="headerlink" title="11. 坑爹史（4）"></a>11. 坑爹史（4）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[,,,].join(<span class="string">", "</span>)</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[,,,] =&gt; [<span class="literal">undefined</span> × <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>因为javascript 在定义数组的时候允许最后一个元素后跟一个,, 所以这是个长度为三的稀疏数组(这是长度为三, 并没有 0, 1, 2三个属性哦)<br>答案: “, , “</p>
<h3 id="12-浏览器懵逼史-2"><a href="#12-浏览器懵逼史-2" class="headerlink" title="12. 浏览器懵逼史(2)"></a>12. 浏览器懵逼史(2)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;<span class="attr">class</span>: <span class="string">"Animal"</span>, <span class="attr">name</span>: <span class="string">'Fido'</span>&#125;;</div><div class="line">a.class</div></pre></td></tr></table></figure>
<p>这个题比较流氓.. 因为是浏览器相关, class是个保留字(现在是个关键字了);Fuck!<br>所以答案不重要, 重要的是自己在取属性名称的时候尽量避免保留字. 如果使用的话请加引号 a[‘class’]</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 这是笔者平时积累的一些觉得比较有意思或是比较有难度的JavaScript题目理解和心得，会保持长期更新。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://damonare.github.io/2016/09/05/javascript%E5%A1%AB%E5%9D%91%E5%8F%B2/#more&quot;&gt;Javascript填坑史&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人生莫作妇人身，百年苦乐由他人。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript闭包总结</title>
    <link href="http://damonare.github.io/2016/12/23/Javascript%E9%97%AD%E5%8C%85%E6%B5%85%E8%B0%88/"/>
    <id>http://damonare.github.io/2016/12/23/Javascript闭包浅谈/</id>
    <published>2016-12-23T02:01:50.000Z</published>
    <updated>2016-12-23T02:01:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript的闭包"><a href="#JavaScript的闭包" class="headerlink" title="JavaScript的闭包"></a>JavaScript的闭包</h2><p><strong>总括：</strong> 本文总结了闭包的概念，并搜集了一些经典闭包的案例习题供给各位学习参考。</p>
<ul>
<li><p>原文博客地址：<a href="http://damonare.github.io/2016/09/06/javscript%E9%97%AD%E5%8C%85%E6%B5%85%E8%B0%88/#more">Javascript闭包小结</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>良辰难再，人生中大好时刻，不要再去旧梦重圆。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>其实关于闭包各个论坛社区里都有很多的文章来讲它，毕竟闭包是JavaScript中一个特色，也正因为这个雨中不同的特色也让闭包理解起来有一些吃力。笔者在这里不仅仅是想介绍闭包，也向列举一些笔者所见过的一些闭包，如果有读者还有一些比较经典的闭包例子，希望可以在评论区里留一下，谢谢。</p>
<p><strong>说了半天，究竟什么是闭包呢？</strong></p>
<ul>
<li><p>闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。</p>
</li>
<li><p>闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配。</p>
</li>
<li><p>当在一个函数内定义另外一个函数就会产生闭包。</p>
</li>
</ul>
<p><strong>为了便于理解，我们可以简单的将闭包理解为：</strong></p>
<ul>
<li>闭包：是指有权访问另外一个函数作用域中的变量的函数。</li>
</ul>
<h3 id="JavaScript中的作用域"><a href="#JavaScript中的作用域" class="headerlink" title="JavaScript中的作用域"></a>JavaScript中的作用域</h3><p>&nbsp;&nbsp;<strong>JavaScript中是没有块级作用域的。不过关于块级作用域我们在这里不做深入探究，笔者在<a href="https://segmentfault.com/a/1190000004092842" target="_blank" rel="external">JavaScript的作用域和块级作用域概念理解</a>中有对块级作用域较为详细的解释，不懂的读者可以去看看。</strong></p>
<blockquote>
<p>变量的作用域无非就是两种：全局变量和局部变量。</p>
<p>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> n=<span class="number">999</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(n);</div><div class="line">&#125;</div><div class="line">f1(); <span class="comment">// 999</span></div></pre></td></tr></table></figure>
<p><strong>如上函数，f1可调用全局变量n</strong></p>
<p>另一方面，在函数外部自然无法读取函数内的局部变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> n=<span class="number">999</span>;</div><div class="line">&#125;</div><div class="line">alert(n); <span class="comment">// error</span></div></pre></td></tr></table></figure>
<p><strong>这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    n=<span class="number">999</span>;</div><div class="line">&#125;</div><div class="line">f1();</div><div class="line">alert(n); <span class="comment">// 999</span></div></pre></td></tr></table></figure>
<p>###闭包</p>
<p><strong>1.理解闭包</strong></p>
<p><strong>我们已经理解了什么是作用域，什么是块级作用域，那又该如何去访问函数内部的变量呢？</strong></p>
<p>出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> n=<span class="number">999</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(n);</div><div class="line">&#125;</div><div class="line">    <span class="keyword">return</span> f2;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> result=f1();</div><div class="line">result();<span class="comment">// 弹出999</span></div></pre></td></tr></table></figure>
<p><strong>上面函数中的f2函数就是闭包，就是通过建立函数来访问函数内部的局部变量。</strong></p>
<p><strong>2.闭包的用途</strong></p>
<p>&nbsp;&nbsp;闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> n=<span class="number">999</span>;</div><div class="line">    nAdd=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;n+=<span class="number">1</span>&#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(n);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> f2;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> result=f1();</div><div class="line">result(); <span class="comment">// 999</span></div><div class="line">nAdd();</div><div class="line">result(); <span class="comment">// 1000</span></div></pre></td></tr></table></figure>
<p><strong>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。</strong></p>
<p><strong>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</strong></p>
<p><strong>这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</strong></p>
<p><strong>3.闭包的注意点</strong></p>
<blockquote>
<p>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>
<p>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>
</blockquote>
<p><strong>4.经典闭包小案例</strong></p>
<p><strong>如果你能理解下面全部的案例，那你的闭包就算是真正掌握了。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line"><span class="attr">name</span> : <span class="string">"My Object"</span>,</div><div class="line"><span class="attr">getNameFunc</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;　　alert(object.getNameFunc()());<span class="comment">//The Window</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line"><span class="attr">name</span> : <span class="string">"My Object"</span>,</div><div class="line"><span class="attr">getNameFunc</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> that.name;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  alert(object.getNameFunc()());<span class="comment">//My Object</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">n,o</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(o)</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">fun</span>:<span class="function"><span class="keyword">function</span>(<span class="params">m</span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> fun(m,n);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = fun(<span class="number">0</span>);  a.fun(<span class="number">1</span>);  a.fun(<span class="number">2</span>);  a.fun(<span class="number">3</span>);<span class="comment">//undefined,?,?,?</span></div><div class="line"><span class="keyword">var</span> b = fun(<span class="number">0</span>).fun(<span class="number">1</span>).fun(<span class="number">2</span>).fun(<span class="number">3</span>);<span class="comment">//undefined,?,?,?</span></div><div class="line"><span class="keyword">var</span> c = fun(<span class="number">0</span>).fun(<span class="number">1</span>);  c.fun(<span class="number">2</span>);  c.fun(<span class="number">3</span>);<span class="comment">//undefined,?,?,?</span></div></pre></td></tr></table></figure>
<p>​</p>
<blockquote>
<p>//问:三行a,b,c的输出分别是什么？</p>
</blockquote>
<p><strong>这是一道非常典型的JS闭包问题。其中嵌套了三层fun函数，搞清楚每层fun的函数是那个fun函数尤为重要。</strong></p>
<blockquote>
<p>//答案：</p>
</blockquote>
<p>//a: undefined,0,0,0</p>
<p>//b: undefined,0,1,2</p>
<p>//c: undefined,0,1,1</p>
<p><strong>都答对了么？如果都答对了恭喜你在js闭包问题当中几乎没什么可以难住你了。</strong></p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul>
<li><a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="external">学习Javascript闭包（Closure）</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JavaScript的闭包&quot;&gt;&lt;a href=&quot;#JavaScript的闭包&quot; class=&quot;headerlink&quot; title=&quot;JavaScript的闭包&quot;&gt;&lt;/a&gt;JavaScript的闭包&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 本文总结了闭包的概念，并搜集了一些经典闭包的案例习题供给各位学习参考。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文博客地址：&lt;a href=&quot;http://damonare.github.io/2016/09/06/javscript%E9%97%AD%E5%8C%85%E6%B5%85%E8%B0%88/#more&quot;&gt;Javascript闭包小结&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;良辰难再，人生中大好时刻，不要再去旧梦重圆。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>React全家桶实现一个简易备忘录</title>
    <link href="http://damonare.github.io/2016/12/20/React%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <id>http://damonare.github.io/2016/12/20/React全家桶实现简易备忘录/</id>
    <published>2016-12-20T06:09:42.000Z</published>
    <updated>2016-12-20T06:09:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 本文采用react+redux+react-router+less+es6+webpack,以实现一个简易备忘录(todolist)为例尽可能全面的讲述使用react全家桶实现一个完整应用的过程。</p>
<ul>
<li><p>代码地址：<a href="https://github.com/damonare/memos" target="_blank" rel="external">React全家桶实现一个简易备忘录</a></p>
</li>
<li><p>原文博客地址：<a href="http://damonare.github.io/2016/12/19/React%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E5%A4%87%E5%BF%98%E5%BD%95/#more">React全家桶实现一个简易备忘录</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>人生不失意，焉能暴己知。</strong></p>
<a id="more"></a>
<h3 id="技术说明"><a href="#技术说明" class="headerlink" title="技术说明"></a>技术说明</h3><blockquote>
<p>技术架构：本备忘录使用react+react-router+redux+less+ES6+webpack实现;</p>
<p>页面UI参照：<a href="http://www.todolist.cn/" target="_blank" rel="external">TodoList官网</a>实现;</p>
<p>在线演示地址：<a href="http://damonare.cn/memos" target="_blank" rel="external">Damonare的备忘录</a>;</p>
</blockquote>
<h3 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h3><ul>
<li>支持回车添加新事项;</li>
<li>支持删除事项(点击X符号);</li>
<li>支持状态转换具体包括：<ul>
<li>新建事项-&gt;正在进行(点击checkbox选项)</li>
<li>正在进行-&gt;已完成(点击文字内容本身)</li>
<li>正在进行-&gt;新建事项(点击checkbox选项)</li>
<li>已完成-&gt;正在进行(点击文字本身)</li>
</ul>
</li>
<li>支持判断输入空字符，过长字符(20个汉字以内);</li>
<li>支持搜索;</li>
<li>支持本地化存储;</li>
<li>支持状态的展开隐藏(点击标题)</li>
<li>兼容手机端(iPhone6及以上)</li>
<li>支持路由切换</li>
</ul>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-React浅谈"><a href="#1-React浅谈" class="headerlink" title="1. React浅谈"></a>1. React浅谈</h3><h4 id="1-1-组件化"><a href="#1-1-组件化" class="headerlink" title="1.1  组件化"></a>1.1  组件化</h4><p>​    毫无疑问，当谈到<code>React</code>的时候不能避免的会提到组件化思想。React刚开始想解决的问题只是UI这一层面的问题，也就是MVC中view层面的问题，不成想如今越滚越大，从最早的UI引擎变成了一整套前后端通吃的 Web App 解决方案。对于<code>React</code>组件的理解同样要站在view层面的角度出发，一个完整的页面是由大大小小的组件堆叠而成，就好像搭积木，每一块积木都是一个组件，组件套组件组成了用户所能看到的完整的页面。</p>
<h4 id="1-2-JSX语法糖"><a href="#1-2-JSX语法糖" class="headerlink" title="1.2  JSX语法糖"></a>1.2  JSX语法糖</h4><p>​    使用<code>React</code>，不一定非要使用<code>JSX</code>语法，可以使用原生的JS进行开发。但是<code>React</code>作者强烈建议我们使用<code>JSX</code>，因为<code>JSX</code>在定义类似HTML这种树形结构时，十分的简单明了。这里简单的讲下<code>JSX</code>的由来。</p>
<p>​    比如，下面一个div元素，我们用HTML语法描述为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>   如果换做使用javascript描述这个元素呢？最好的方式可以简单的转化为<code>json</code>对象，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  type:"div",</div><div class="line">  props:&#123;</div><div class="line">    className:"test",</div><div class="line">    children:&#123;</div><div class="line">      type:"span",</div><div class="line">      props:&#123;</div><div class="line">        children:"Test"</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   这样我们就可以在javascript中创建一个<code>Virtual DOM</code>（虚拟DOM）了。当然，这样是没法复用的，我们再把它封装一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Div=&gt;(&#123;text&#125;)&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">type</span>:<span class="string">"div"</span>,</div><div class="line">    <span class="attr">props</span>:&#123;</div><div class="line">      <span class="attr">className</span>:<span class="string">"test"</span>,</div><div class="line">      <span class="attr">children</span>:&#123;</div><div class="line">        <span class="attr">type</span>:<span class="string">"span"</span>,</div><div class="line">        <span class="attr">props</span>:&#123;</div><div class="line">          <span class="attr">children</span>: text,</div><div class="line">        &#125;,</div><div class="line">      &#125;,</div><div class="line">    &#125;,</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  接下来再实现这个div就可以直接调用Div(‘Test’)来创建。但上述结构看起来实在让人不爽，写起来也很容易写混，一旦结构复杂了，很容易让人找不着北，于是<code>JSX</code>语法应运而生。我们用写HTML的方式写这段代码，再经过翻译器转换成javascript后交给浏览器执行。上述代码用<code>JSX</code>重写：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Div =<span class="function"><span class="params">()</span>=&gt;</span>(</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"test"</span>&gt;</span></span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">);</div></pre></td></tr></table></figure>
<p>多么简单明了！！！具体的<code>JSX语法</code>不多说了，学习更多戳这：<a href="http://reactjs.cn/react/docs/jsx-in-depth.html" target="_blank" rel="external">JSX in Depth</a></p>
<h4 id="1-3-Virtual-DOM"><a href="#1-3-Virtual-DOM" class="headerlink" title="1.3  Virtual DOM"></a>1.3  Virtual DOM</h4><p>   其实上面已经提到了<code>Virtual DOM</code>，它的存在也是<code>React</code>长久不衰的原因之一，虚拟DOM的概念并不是FB首创却在FB的手上大火了起来(后台是多么重要)。</p>
<p>  我们知道真实的页面对应了一个DOM树，在传统页面的开发模式中，每次需要更新页面时，都需要对DOM进行更新，DOM操作十分昂贵，为减少对于真实DOM的操作，诞生了<code>Virtual DOM</code>的概念，也就是用javascript把真实的DOM树描述了一遍，使用的也就是我们刚刚说过的<code>JSX</code>语法。对比如下：</p>
<p><img src="http://7xsssj.com2.z0.glb.qiniucdn.com/1444448853198657.jpg" alt="Virtual DOM原理"></p>
<p>   每次数据更新之后，重新计算<code>Virtual DOM</code>，并和上一次的<code>Virtual DOM</code>对比，对发生的变化进行批量更新。React也提供了<code>shouldComponentUpdate</code>生命周期回调，来减少数据变化后不必要的<code>Virtual DOM</code>对比过程，提升了性能。</p>
<p> <code>Virtual DOM</code>虽然渲染方式比传统的DOM操作要好一些，但并不明显，因为对比DOM节点也是需要计算的，最大的好处在于可以很方便的和其它平台集成，比如<code>react-native</code>就是基于<code>Virtual DOM</code>渲染出原生控件。具体渲染出的是<code>Web DOM</code>还是<code>Android</code>控件或是<code>iOS</code>控件就由平台决定了。所以我们说<code>react</code>的出现是一场革命，一次对于<code>native app</code>的宣战,就像<code>react-native</code>那句口号——<strong>Learn Once,Write Anywhere</strong>.</p>
<h4 id="1-4-函数式编程"><a href="#1-4-函数式编程" class="headerlink" title="1.4 函数式编程"></a>1.4 函数式编程</h4><p>​    过去编程方式主要是以命令式编程为主，什么意思呢？简单说电脑的思维方式和我们人类的思考方式是不一样的。我们人类的大脑擅长的是分析问题，提出一个解决问题的方案，电脑则是生硬的执行指令，命令式编程就像是给电脑下达命令，让电脑去执行一样，现在主要的编程语言（比如：Java，C，C++等）都是由命令式编程构建起来的。</p>
<p>​   而函数式编程就不一样了，这是模仿我们人类的思维方式发明出来的。例如：操作某个数组的每一个元素然后返回一个新数组，如果是计算机的思考方式，会这样想：创建一个新数组=&gt;遍历旧数组=&gt;给新数组赋值。如果是人类的思考方式，会这样想：创建一个数组方法，作用在旧数组上，返回新数组。这样此方法可以被重复利用。而这就是函数式编程了。</p>
<h4 id="1-5-数据流"><a href="#1-5-数据流" class="headerlink" title="1.5 数据流"></a>1.5 数据流</h4><p>  在React中，数据的流动是单向的，即从父节点传递到子节点。也因此组件是简单的，他们只需要从父组件获取props渲染即可。如果顶层的props改变了，React会递归的向下遍历整个组件树，重新渲染所有使用这个属性的组件。那么父组件如何获取子组件数据呢？很简单，通过回调就可以了，父组件定义某个方法供给子组件调用，子组件调用方法传递给父组件数据，Over。</p>
<h3 id="2-React-router"><a href="#2-React-router" class="headerlink" title="2. React-router"></a>2. React-router</h3><p>这东西我觉得没啥难度，官方例子都很不错，跟着官方例子来一遍基本就明白到底是个啥玩意了，官方例子：<a href="https://github.com/reactjs/react-router-tutorial/tree/master/lessons" target="_blank" rel="external"><strong>react-router-tutorial。</strong></a></p>
<p>完事以后可以再看一下阮一峰老师的教程，主要是对一些API的讲解：<a href="http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu" target="_blank" rel="external">React Router 使用教程</a>。</p>
<p>还有啥不明白的欢迎评论留言共同探讨。</p>
<h3 id="3-Redux"><a href="#3-Redux" class="headerlink" title="3. Redux"></a>3. Redux</h3><h4 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h4><p>随着 JavaScript 单页应用开发日趋复杂，<strong>JavaScript 需要管理比任何时候都要多的 state （状态）</strong>。 这些 state 可能包括服务器响应、缓存数据、本地生成尚未持久化到服务器的数据，也包括 UI 状态，如激活的路由，被选中的标签，是否显示加载动效或者分页器等等。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个 model 的变化，依次地，可能会引起另一个 view 的变化。乱！</p>
<p>这时候<code>Redux</code>就强势登场了，现在你可以把<code>React</code>的model看作是一个个的子民，每一个子民都有自己的一个状态，纷纷扰扰，各自维护着自己状态，我行我素，那哪行啊！太乱了，我们需要一个King来领导大家，我们就可以把<code>Redux</code>看作是这个King。网罗所有的组件组成一个国家，掌控着一切子民的状态！防止有人叛乱生事！</p>
<p>这个时候就把组件分成了两种：容器组件(King或是路由)和展示组件(子民)。</p>
<ul>
<li>容器组件：即<code>redux</code>或是<code>router</code>,起到了维护状态，出发action的作用，其实就是King高高在上下达指令。</li>
<li>展示组件：不维护状态，所有的状态由容器组件通过<code>props</code>传给他，所有操作通过回调完成。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">展示组件</th>
<th style="text-align:center">容器组件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">作用</td>
<td style="text-align:center">描述如何展现（骨架、样式）</td>
<td style="text-align:center">描述如何运行（数据获取、状态更新）</td>
</tr>
<tr>
<td style="text-align:center">直接使用 Redux</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">数据来源</td>
<td style="text-align:center">props</td>
<td style="text-align:center">监听 Redux state</td>
</tr>
<tr>
<td style="text-align:center">数据修改</td>
<td style="text-align:center">从 props 调用回调函数</td>
<td style="text-align:center">向 Redux 派发 actions</td>
</tr>
<tr>
<td style="text-align:center">调用方式</td>
<td style="text-align:center">手动</td>
<td style="text-align:center">通常由 React Redux 生成</td>
</tr>
</tbody>
</table>
<p>Redux三大部分：<code>store</code>,<code>action</code>,<code>reducer</code>。相当于King的直系下属。</p>
<p>那么也可以看出<code>Redux</code>只是一个状态管理方案，完全可以单独拿出来使用，这个King不仅仅可以是React的，去Angular，Ember那里也是可以做King的。在React中维系King和组件关系的库叫做<code>react-redux</code>。</p>
<p>， 它主要有提供两个东西：<code>Provider</code> 和<code>connect</code>，具体使用文后说明。</p>
<p>提供几个Redux的学习地址：<a href="http://cn.redux.js.org/index.html" target="_blank" rel="external">官方教程-中文版</a>，<a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="external">Redux 入门教程（一）：基本用法</a></p>
<h4 id="3-2-Store"><a href="#3-2-Store" class="headerlink" title="3.2 Store"></a>3.2 Store</h4><p>Store 就是保存数据的地方，它实际上是一个<code>Object tree</code>。整个应用只能有一个 Store。这个Store可以看做是King的首相，掌控一切子民(组件)的活动(state)。</p>
<p>Redux 提供<code>createStore</code>这个函数，用来生成 Store。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"><span class="keyword">const</span> store = createStore(func);</div></pre></td></tr></table></figure>
<p>createStore接受一个函数作为参数，返回一个Store对象(首相诞生记)</p>
<p>我们来看一下Store(首相)的职责：</p>
<ul>
<li>维持应用的 state；</li>
<li>提供 <a href="http://cn.redux.js.org/docs/api/Store.html#getState" target="_blank" rel="external"><code>getState()</code></a> 方法获取 state；</li>
<li>提供 <a href="http://cn.redux.js.org/docs/api/Store.html#dispatch" target="_blank" rel="external"><code>dispatch(action)</code></a> 方法更新 state；</li>
<li>通过 <a href="http://cn.redux.js.org/docs/api/Store.html#subscribe" target="_blank" rel="external"><code>subscribe(listener)</code></a> 注册监听器;</li>
<li>通过 <a href="http://cn.redux.js.org/docs/api/Store.html#subscribe" target="_blank" rel="external"><code>subscribe(listener)</code></a> 返回的函数注销监听器。</li>
</ul>
<h4 id="3-3-action"><a href="#3-3-action" class="headerlink" title="3.3 action"></a>3.3 action</h4><p>State 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。即store的数据变化来自于用户操作。action就是一个通知，它可以看作是首相下面的邮递员，通知子民(组件)改变状态。它是 store 数据的<strong>唯一</strong>来源。一般来说会通过 <a href="http://cn.redux.js.org/docs/api/Store.html#dispatch" target="_blank" rel="external"><code>store.dispatch()</code></a> 将 action 传到 store。</p>
<p>Action 是一个对象。其中的<code>type</code>属性是必须的，表示 Action 的名称。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> action = &#123;</div><div class="line">  <span class="attr">type</span>: <span class="string">'ADD_TODO'</span>,</div><div class="line">  <span class="attr">payload</span>: <span class="string">'Learn Redux'</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>Action创建函数</strong></p>
<p><strong>Action 创建函数</strong> 就是生成 action 的方法。“action” 和 “action 创建函数” 这两个概念很容易混在一起，使用时最好注意区分。</p>
<p>在 Redux 中的 action 创建函数只是简单的返回一个 action:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">type</span>: ADD_TODO,</div><div class="line">    text</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样做将使 action 创建函数更容易被移植和测试。</p>
<h4 id="3-4-reducer"><a href="#3-4-reducer" class="headerlink" title="3.4 reducer"></a>3.4 reducer</h4><p><strong>Action</strong> 只是描述了<strong>有事情发生了</strong>这一事实，并没有指明应用如何更新 state。而这正是 reducer 要做的事情。也就是邮递员(action)只负责通知，具体你(组件)如何去做，他不负责，这事情只能是你们村长(reducer)告诉你如何去做才能符合社会主义核心价值观，如何做才能对建设共产主义社会有利。</p>
<p>专业解释: <strong>Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。</strong></p>
<p>Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> reducer = <span class="function"><span class="keyword">function</span> (<span class="params">state, action</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="keyword">return</span> new_state;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="3-5-数据流"><a href="#3-5-数据流" class="headerlink" title="3.5 数据流"></a>3.5 数据流</h4><p><strong>严格的单向数据流</strong>是 Redux 架构的设计核心。</p>
<p>Redux 应用中数据的生命周期遵循下面 4 个步骤：</p>
<ul>
<li><strong>调用</strong> <a href="http://cn.redux.js.org/docs/api/Store.html#dispatch" target="_blank" rel="external"><code>store.dispatch(action)</code></a>。</li>
<li><strong>Redux store 调用传入的 reducer 函数。</strong></li>
<li><strong>根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树。</strong></li>
<li><strong>Redux store 保存了根 reducer 返回的完整 state 树</strong>。</li>
</ul>
<p>工作流程图如下：</p>
<p><img src="http://7xsssj.com2.z0.glb.qiniucdn.com/6b3fb1df3ad9c95354280a332065941a_thumb.png" alt="redux工作原理图"></p>
<h4 id="3-6-Connect"><a href="#3-6-Connect" class="headerlink" title="3.6 Connect"></a>3.6 Connect</h4><p>这里需要再强调一下：Redux 和 React 之间没有关系。Redux 支持 React、Angular、Ember、jQuery 甚至纯 JavaScript。</p>
<p>尽管如此，Redux 还是和 <a href="http://facebook.github.io/react/" target="_blank" rel="external">React</a> 和 <a href="https://github.com/dekujs/deku" target="_blank" rel="external">Deku</a> 这类框架搭配起来用最好，因为这类框架允许你以 state 函数的形式来描述界面，Redux 通过 action 的形式来发起 state 变化。</p>
<p>Redux 默认并不包含 <a href="https://github.com/reactjs/react-redux" target="_blank" rel="external">React 绑定库</a>，需要单独安装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save react-redux</div></pre></td></tr></table></figure>
<p>当然，我们这个实例里是不需要的，所有需要的依赖已经在package.json里配置好了。</p>
<p><code>React-Redux</code> 提供<code>connect</code>方法，用于从 UI 组件生成容器组件。<code>connect</code>的意思，就是将这两种组件连起来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</div><div class="line"><span class="keyword">const</span> TodoList = connect()(Memos);</div></pre></td></tr></table></figure>
<p>上面代码中<code>Memos</code>是个UI组件，<code>TodoList</code>就是由 React-Redux 通过<code>connect</code>方法自动生成的容器组件。</p>
<p>而只是纯粹的这样把Memos包裹起来毫无意义，完整的connect方法这样使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></div><div class="line"><span class="keyword">const</span> TodoList = connect(</div><div class="line">  mapStateToProps</div><div class="line">)(Memos)</div></pre></td></tr></table></figure>
<p>上面代码中，<code>connect</code>方法接受两个参数：<code>mapStateToProps</code>和<code>mapDispatchToProps</code>。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将<code>state</code>映射到 UI 组件的参数（<code>props</code>），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。</p>
<h4 id="3-7-Provider"><a href="#3-7-Provider" class="headerlink" title="3.7 Provider"></a>3.7 Provider</h4><p> 这个Provider 其实是一个中间件，它是为了解决让容器组件拿到King的指令(<code>state</code>对象)而存在的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></div><div class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></div><div class="line"><span class="keyword">import</span> todoApp <span class="keyword">from</span> <span class="string">'./reducers'</span></div><div class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./components/App'</span></div><div class="line"><span class="keyword">let</span> store = createStore(todoApp);</div><div class="line">render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span>,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</div><div class="line">)</div></pre></td></tr></table></figure>
<p>上面代码中，<code>Provider</code>在根组件外面包了一层，这样一来，<code>App</code>的所有子组件就默认都可以拿到<code>state</code>了。</p>
<h3 id="4-实战备忘录"><a href="#4-实战备忘录" class="headerlink" title="4.实战备忘录"></a>4.实战备忘录</h3><p>讲解之前可以先看一下github上的代码，你可以clone下来学习，也可以在线给我提issue，欢迎戳这:<a href="https://github.com/damonare/memos" target="_blank" rel="external">React全家桶实现简易备忘录</a></p>
<h4 id="4-1目录结构"><a href="#4-1目录结构" class="headerlink" title="4.1目录结构"></a>4.1目录结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── app                 #开发目录</div><div class="line">|   |   </div><div class="line">|   ├──actions          #action的文件</div><div class="line">|   |   </div><div class="line">|   ├──components       #展示组件</div><div class="line">|   |   </div><div class="line">|   ├──containers       #容器组件,主页</div><div class="line">|   |   </div><div class="line">|   ├──reducers         #reducer文件</div><div class="line">|   |</div><div class="line">|   |——routes		   #路由文件，容器组件</div><div class="line">|   |</div><div class="line">|   |——static           #静态文件</div><div class="line">|   |</div><div class="line">|   ├──stores           #store配置文件</div><div class="line">|   |</div><div class="line">|   |——main.less        #路由样式</div><div class="line">|   |</div><div class="line">|   └──main.js          #入口文件</div><div class="line">|      </div><div class="line">├── build                #发布目录</div><div class="line">├── node_modules        #包文件夹</div><div class="line">├── .gitignore     </div><div class="line">├── .jshintrc      </div><div class="line">├── webpack.production.config.js  #生产环境配置      </div><div class="line">├── webpack.config.js   #webpack配置文件</div><div class="line">├── package.json        #环境配置</div><div class="line">└── README.md		   #使用说明</div></pre></td></tr></table></figure>
<p>接下来，我们只关注app目录就好了。</p>
<h4 id="4-2入口文件"><a href="#4-2入口文件" class="headerlink" title="4.2入口文件"></a>4.2入口文件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"><span class="keyword">import</span> &#123;Route, IndexRoute, browserHistory, Router&#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</div><div class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"><span class="keyword">import</span> &#123;Provider&#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</div><div class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./container/App'</span>;</div><div class="line"><span class="keyword">import</span> AllMemosRoute <span class="keyword">from</span> <span class="string">'./routes/AllMemosRoute'</span>;</div><div class="line"><span class="keyword">import</span> TodoRoute <span class="keyword">from</span> <span class="string">'./routes/TodoRoute'</span>;</div><div class="line"><span class="keyword">import</span> DoingRoute <span class="keyword">from</span> <span class="string">'./routes/DoingRoute'</span>;</div><div class="line"><span class="keyword">import</span> DoneRoute <span class="keyword">from</span> <span class="string">'./routes/DoneRoute'</span>;</div><div class="line"><span class="keyword">import</span> configureStore <span class="keyword">from</span> <span class="string">'./stores'</span>;</div><div class="line"><span class="keyword">import</span> <span class="string">'./main.less'</span>;</div><div class="line"><span class="keyword">const</span> store = configureStore();</div><div class="line">ReactDOM.render(</div><div class="line">    &lt;Provider store=&#123;store&#125;&gt;</div><div class="line">        &lt;Router history=&#123;browserHistory&#125;&gt;</div><div class="line">            &lt;Route path="/"  component=&#123;App&#125;&gt;</div><div class="line">                &lt;IndexRoute component=&#123;AllMemosRoute&#125;/&gt;</div><div class="line">                &lt;Route path="/todo" component=&#123;TodoRoute&#125;/&gt;</div><div class="line">                &lt;Route path="/doing" component=&#123;DoingRoute&#125;/&gt;</div><div class="line">                &lt;Route path="/done" component=&#123;DoneRoute&#125;/&gt;</div><div class="line">            &lt;/Route&gt;</div><div class="line">        &lt;/Router&gt;</div><div class="line">   &lt;/Provider&gt;,</div><div class="line"> document.body.appendChild(document.createElement('div')))</div></pre></td></tr></table></figure>
<p>这里我们从<code>react-redux</code>中获取到 Provider 组件，我们把它渲染到应用的最外层。<br>他需要一个属性 store ，他把这个 store 放在context里，给Router(connect)用。</p>
<h4 id="4-3-Store"><a href="#4-3-Store" class="headerlink" title="4.3 Store"></a>4.3 Store</h4><blockquote>
<p> app/store/index.jsx</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'../reducers'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">configureStore</span>(<span class="params">initialState</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> store = createStore(reducer, initialState);</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</div><div class="line">    <span class="comment">// Enable Webpack hot module replacement for reducers</span></div><div class="line">    <span class="built_in">module</span>.hot.accept(<span class="string">'../reducers'</span>, () =&gt; &#123;</div><div class="line">      <span class="keyword">const</span> nextReducer = <span class="built_in">require</span>(<span class="string">'../reducers'</span>);</div><div class="line">      store.replaceReducer(nextReducer);</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> store;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-4-Action-创建函数和常量"><a href="#4-4-Action-创建函数和常量" class="headerlink" title="4.4 Action 创建函数和常量"></a>4.4 Action 创建函数和常量</h4><blockquote>
<p>app/action/index.jsx</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * @author Damonare 2016-12-10</div><div class="line"> * @version 1.0.0</div><div class="line"> * action 类型</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> Add_Todo = <span class="string">'Add_Todo'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> Change_Todo_To_Doing = <span class="string">'Change_Todo_To_Doing'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> Change_Doing_To_Done = <span class="string">'Change_Doing_To_Done'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> Change_Done_To_Doing = <span class="string">'Change_Done_To_Doing'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> Change_Doing_To_Todo = <span class="string">'Change_Doing_To_Todo'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> Search=<span class="string">'Search'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> Delete_Todo=<span class="string">'Delete_Todo'</span>;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * action 创建函数</div><div class="line"> * @method  addTodo添加新事项</div><div class="line"> * @param  &#123;String&#125; text 添加事项的内容</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">type</span>: Add_Todo,</div><div class="line">      text</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * @method  search 查找事项</div><div class="line"> * @param  &#123;String&#125; text 查找事项的内容</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">type</span>: Search,</div><div class="line">      text</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * @method  changeTodoToDoing 状态由todo转为doing</div><div class="line"> * @param  &#123;Number&#125; index 需要改变状态的事项的下标</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">changeTodoToDoing</span>(<span class="params">index</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">type</span>: Change_Todo_To_Doing,</div><div class="line">      index</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * @method  changeDoneToDoing 状态由done转为doing</div><div class="line"> * @param  &#123;Number&#125; index 需要改变状态的事项的下标</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">changeDoneToDoing</span>(<span class="params">index</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">type</span>: Change_Done_To_Doing,</div><div class="line">      index</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * @method  changeDoingToTodo 状态由doing转为todo</div><div class="line"> * @param  &#123;Number&#125; index 需要改变状态的事项的下标</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">changeDoingToTodo</span>(<span class="params">index</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">type</span>: Change_Doing_To_Todo,</div><div class="line">      index</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * @method  changeDoingToDone 状态由doing转为done</div><div class="line"> * @param  &#123;Number&#125; index 需要改变状态的事项的下标</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">changeDoingToDone</span>(<span class="params">index</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">type</span>: Change_Doing_To_Done,</div><div class="line">      index</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * @method  deleteTodo 删除事项</div><div class="line"> * @param  &#123;Number&#125; index 需要删除的事项的下标</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">deleteTodo</span>(<span class="params">index</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">type</span>: Delete_Todo,</div><div class="line">      index</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在声明每一个返回 action 函数的时候，我们需要在头部声明这个 action 的 type，以便好组织管理。<br>每个函数都会返回一个 action 对象，所以在 容器组件里面调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">text =&gt;</div><div class="line">  dispatch(addTodo(text))</div></pre></td></tr></table></figure>
<p>就是调用<code>dispatch(action)</code> 。</p>
<h4 id="4-5-Reducers"><a href="#4-5-Reducers" class="headerlink" title="4.5 Reducers"></a>4.5 Reducers</h4><blockquote>
<p>app/reducers/index.jsx</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"><span class="keyword">import</span> todolist <span class="keyword">from</span> <span class="string">'./todos'</span>;</div><div class="line"><span class="comment">// import visibilityFilter from './visibilityFilter';</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</div><div class="line">  todolist</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> reducer;</div></pre></td></tr></table></figure>
<blockquote>
<p>app/reducers/todos.jsx</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">    Add_Todo,</div><div class="line">    Delete_Todo,</div><div class="line">    Change_Todo_To_Doing,</div><div class="line">    Change_Doing_To_Done,</div><div class="line">    Change_Doing_To_Todo,</div><div class="line">    Change_Done_To_Doing,</div><div class="line">    Search</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'../actions'</span>;</div><div class="line"><span class="keyword">let</span> todos;</div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (localStorage.todos) &#123;</div><div class="line">        todos = <span class="built_in">JSON</span>.parse(localStorage.todos)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        todos = []</div><div class="line">    &#125;</div><div class="line">&#125;)();</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">todolist</span>(<span class="params">state = todos, action</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">            <span class="comment">/*</span></div><div class="line">        *  添加新的事项</div><div class="line">        *  并进行本地化存储</div><div class="line">        *  使用ES6展开运算符链接新事项和旧事项</div><div class="line">        *  JSON.stringify进行对象深拷贝</div><div class="line">        */</div><div class="line">        <span class="keyword">case</span> Add_Todo:</div><div class="line">            localStorage.setItem(<span class="string">'todos'</span>, <span class="built_in">JSON</span>.stringify([</div><div class="line">                ...state, &#123;</div><div class="line">                    <span class="attr">todo</span>: action.text,</div><div class="line">                    <span class="attr">istodo</span>: <span class="literal">true</span>,</div><div class="line">                    <span class="attr">doing</span>: <span class="literal">false</span>,</div><div class="line">                    <span class="attr">done</span>: <span class="literal">false</span></div><div class="line">                &#125;</div><div class="line">            ]));</div><div class="line">            <span class="keyword">return</span> [</div><div class="line">                ...state, &#123;</div><div class="line">                    <span class="attr">todo</span>: action.text,</div><div class="line">                    <span class="attr">istodo</span>: <span class="literal">true</span>,</div><div class="line">                    <span class="attr">doing</span>: <span class="literal">false</span>,</div><div class="line">                    <span class="attr">done</span>: <span class="literal">false</span></div><div class="line">                &#125;</div><div class="line">            ];</div><div class="line">            <span class="comment">/*</span></div><div class="line">            *  将todo转为doing状态，注意action.index的类型转换</div><div class="line">            */</div><div class="line">        <span class="keyword">case</span> Change_Todo_To_Doing:</div><div class="line">            localStorage.setItem(<span class="string">'todos'</span>, <span class="built_in">JSON</span>.stringify([</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                &#123;</div><div class="line">                    <span class="attr">todo</span>:state[action.index].todo,</div><div class="line">                    <span class="attr">istodo</span>: <span class="literal">false</span>,</div><div class="line">                    <span class="attr">doing</span>: <span class="literal">true</span>,</div><div class="line">                    <span class="attr">done</span>: <span class="literal">false</span></div><div class="line">                &#125;,</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ]));</div><div class="line">            <span class="keyword">return</span> [</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                &#123;</div><div class="line">                    <span class="attr">todo</span>:state[action.index].todo,</div><div class="line">                    <span class="attr">istodo</span>: <span class="literal">false</span>,</div><div class="line">                    <span class="attr">doing</span>: <span class="literal">true</span>,</div><div class="line">                    <span class="attr">done</span>: <span class="literal">false</span></div><div class="line">                &#125;,</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ];</div><div class="line">            <span class="comment">/*</span></div><div class="line">            *  将doing转为done状态</div><div class="line">            */</div><div class="line">        <span class="keyword">case</span> Change_Doing_To_Done:</div><div class="line">            localStorage.setItem(<span class="string">'todos'</span>, <span class="built_in">JSON</span>.stringify([</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                &#123;</div><div class="line">                    <span class="attr">todo</span>:state[action.index].todo,</div><div class="line">                    <span class="attr">istodo</span>: <span class="literal">false</span>,</div><div class="line">                    <span class="attr">doing</span>: <span class="literal">false</span>,</div><div class="line">                    <span class="attr">done</span>: <span class="literal">true</span></div><div class="line">                &#125;,</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ]));</div><div class="line">            <span class="keyword">return</span> [</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                &#123;</div><div class="line">                    <span class="attr">todo</span>:state[action.index].todo,</div><div class="line">                    <span class="attr">istodo</span>: <span class="literal">false</span>,</div><div class="line">                    <span class="attr">doing</span>: <span class="literal">false</span>,</div><div class="line">                    <span class="attr">done</span>: <span class="literal">true</span></div><div class="line">                &#125;,</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ];</div><div class="line">            <span class="comment">/*</span></div><div class="line">            *  将done转为doing状态</div><div class="line">            */</div><div class="line">        <span class="keyword">case</span> Change_Done_To_Doing:</div><div class="line">            localStorage.setItem(<span class="string">'todos'</span>, <span class="built_in">JSON</span>.stringify([</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                &#123;</div><div class="line">                    <span class="attr">todo</span>:state[action.index].todo,</div><div class="line">                    <span class="attr">istodo</span>: <span class="literal">false</span>,</div><div class="line">                    <span class="attr">doing</span>: <span class="literal">true</span>,</div><div class="line">                    <span class="attr">done</span>: <span class="literal">false</span></div><div class="line">                &#125;,</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ]));</div><div class="line">            <span class="keyword">return</span> [</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                &#123;</div><div class="line">                    <span class="attr">todo</span>:state[action.index].todo,</div><div class="line">                    <span class="attr">istodo</span>: <span class="literal">false</span>,</div><div class="line">                    <span class="attr">doing</span>: <span class="literal">true</span>,</div><div class="line">                    <span class="attr">done</span>: <span class="literal">false</span></div><div class="line">                &#125;,</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ];</div><div class="line">            <span class="comment">/*</span></div><div class="line">            *  将doing转为todo状态</div><div class="line">            */</div><div class="line">        <span class="keyword">case</span> Change_Doing_To_Todo:</div><div class="line">            localStorage.setItem(<span class="string">'todos'</span>, <span class="built_in">JSON</span>.stringify([</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                &#123;</div><div class="line">                    <span class="attr">todo</span>:state[action.index].todo,</div><div class="line">                    <span class="attr">istodo</span>: <span class="literal">true</span>,</div><div class="line">                    <span class="attr">doing</span>: <span class="literal">false</span>,</div><div class="line">                    <span class="attr">done</span>: <span class="literal">false</span></div><div class="line">                &#125;,</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ]));</div><div class="line">            <span class="keyword">return</span> [</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                &#123;</div><div class="line">                    <span class="attr">todo</span>:state[action.index].todo,</div><div class="line">                    <span class="attr">istodo</span>: <span class="literal">true</span>,</div><div class="line">                    <span class="attr">doing</span>: <span class="literal">false</span>,</div><div class="line">                    <span class="attr">done</span>: <span class="literal">false</span></div><div class="line">                &#125;,</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ];</div><div class="line">            <span class="comment">/*</span></div><div class="line">            *  删除某个事项</div><div class="line">            */</div><div class="line">        <span class="keyword">case</span> Delete_Todo:</div><div class="line">            localStorage.setItem(<span class="string">'todos'</span>, <span class="built_in">JSON</span>.stringify([</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ]));</div><div class="line">            <span class="keyword">return</span> [</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ];</div><div class="line">            <span class="comment">/*</span></div><div class="line">            *  搜索</div><div class="line">            */</div><div class="line">        <span class="keyword">case</span> Search:</div><div class="line">        <span class="keyword">let</span> text=action.text;</div><div class="line">        <span class="keyword">let</span> reg=<span class="built_in">eval</span>(<span class="string">"/"</span>+text+<span class="string">"/gi"</span>);</div><div class="line">            <span class="keyword">return</span> state.filter(<span class="function"><span class="params">item</span>=&gt;</span> item.todo.match(reg));</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> todolist;</div></pre></td></tr></table></figure>
<p>具体的展示组件这里就不罗列代码了，感兴趣的可以戳这：<a href="https://github.com/damonare/memos/tree/master/app/components" target="_blank" rel="external">备忘录展示组件地址</a></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>严格来说，这个备忘录并不是使用的react全家桶，毕竟还有一部分less代码，不过这一个应用也算是比较全面的使用了react+react-router+redux，作为react全家桶技术学习的练手的小项目再适合不过了。如果您对这个小东西感兴趣，欢迎戳这:<a href="https://github.com/damonare/memos" target="_blank" rel="external">React全家桶实现简易备忘录</a>给个star。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 本文采用react+redux+react-router+less+es6+webpack,以实现一个简易备忘录(todolist)为例尽可能全面的讲述使用react全家桶实现一个完整应用的过程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;代码地址：&lt;a href=&quot;https://github.com/damonare/memos&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React全家桶实现一个简易备忘录&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原文博客地址：&lt;a href=&quot;http://damonare.github.io/2016/12/19/React%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E5%A4%87%E5%BF%98%E5%BD%95/#more&quot;&gt;React全家桶实现一个简易备忘录&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人生不失意，焉能暴己知。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="React" scheme="http://damonare.github.io/tags/React/"/>
    
      <category term="前端" scheme="http://damonare.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>十大经典排序算法</title>
    <link href="http://damonare.github.io/2016/12/20/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88javascript%E6%8F%8F%E8%BF%B0%EF%BC%89/"/>
    <id>http://damonare.github.io/2016/12/20/十大经典排序算法总结（javascript描述）/</id>
    <published>2016-12-20T04:29:56.000Z</published>
    <updated>2016-12-20T04:29:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong>  本文图文并茂的详细讲述了十大经典排序算法用javascript实现的过程。</p>
<ul>
<li><p>原文博客地址：<a href="http://damonare.github.io/2016/09/16/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88javascript%E6%8F%8F%E8%BF%B0%EF%BC%89/#more">十大经典排序算法</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>人生有情泪沾衣，江水江花岂终极。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>读者自行尝试可以<a href="https://github.com/damonare/Sorts" target="_blank" rel="external">想看源码戳这</a>，博主在github建了个库，读者可以Clone下来本地尝试。此博文配合源码体验更棒哦</p>
<blockquote>
<ul>
<li>这世界上总存在着那么一些看似相似但有完全不同的东西，比如雷锋和雷峰塔，小平和小平头，玛丽和马里奥，Java和javascript….当年javascript为了抱Java大腿恬不知耻的让自己变成了Java的干儿子，哦，不是应该是跪舔，毕竟都跟了Java的姓了。可如今，javascript来了个咸鱼翻身，几乎要统治web领域，Nodejs，React Native的出现使得javascript在后端和移动端都开始占有了一席之地。可以这么说,在Web的江湖，<mark>JavaScript可谓风头无两，已经坐上了头把交椅。</mark></li>
<li>在传统的计算机算法和数据结构领域，大多数专业教材和书籍的默认语言都是Java或者C/C+ +，O’REILLY家倒是出了一本叫做《数据结构与算法javascript描述》的书，但不得不说，不知道是作者吃了shit还是译者根本就没校对，满书的小错误，这就像那种无穷无尽的小bug一样,简直就是让人有种嘴里塞满了shit的感觉，吐也不是咽下去也不是。对于一个前端来说，尤其是笔试面试的时候，算法方面考的其实不难（<mark>十大排序算法或是和十大排序算法同等难度的</mark>），但就是之前没用javascript实现过或是没仔细看过相关算法的原理，导致写起来浪费很多时间。所以撸一撸袖子决定自己查资料自己总结一篇博客等用到了直接看自己的博客就OK了，正所谓靠天靠地靠大牛不如靠自己(ˉ(∞)ˉ)。</li>
<li>算法的由来：9世纪波斯数学家提出的：“al-Khowarizmi”就是下图这货（感觉重要数学元素提出者貌似都戴了顶白帽子），开个玩笑，阿拉伯人对于数学史的贡献还是值得人敬佩的。<br><img src="http://img.blog.csdn.net/20160916152402267" alt="大大"></li>
</ul>
</blockquote>
<h3 id="排序算法说明"><a href="#排序算法说明" class="headerlink" title="排序算法说明"></a>排序算法说明</h3><p><strong>（1）排序的定义：对一序列对象根据某个关键字进行排序；</strong></p>
<p>输入：n个数：a1,a2,a3,…,an<br>输出：n个数的排列:a1’,a2’,a3’,…,an’，使得a1’&lt;=a2’&lt;=a3’&lt;=…&lt;=an’。</p>
<p>再讲的形象点就是排排坐，调座位，高的站在后面，矮的站在前面咯。</p>
<p><strong>（3）对于评述算法优劣术语的说明</strong></p>
<p><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；<br><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</p>
<p><strong>内排序</strong>：所有排序操作都在内存中完成；<br><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</p>
<p><strong>时间复杂度</strong>: 一个算法执行所耗费的时间。<br><strong>空间复杂度</strong>: 运行完一个程序所需内存的大小。</p>
<p>关于时间空间复杂度的更多了解请戳<a href="http://blog.csdn.net/booirror/article/details/7707551/" target="_blank" rel="external">这里</a>，或是看书程杰大大编写的《大话数据结构》还是很赞的，通俗易懂。</p>
<p><strong>（4）排序算法图片总结(图片来源于网络):</strong></p>
<p>排序对比：</p>
<p><img src="http://img.blog.csdn.net/20160916153212716" alt="这里写图片描述"></p>
<p><strong>图片名词解释：</strong><br>n: 数据规模<br>k:“桶”的个数<br>In-place: 占用常数内存，不占用额外内存<br>Out-place: 占用额外内存</p>
<p>排序分类：</p>
<p><img src="http://img.blog.csdn.net/20160916154036887" alt="这里写图片描述"></p>
<h3 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1.冒泡排序（Bubble Sort）"></a>1.冒泡排序（Bubble Sort）</h3><blockquote>
<p>好的，开始总结第一个排序算法，冒泡排序。我想对于它每个学过C语言的都会了解的吧，这可能是很多人接触的第一个排序算法。</p>
</blockquote>
<h4 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="(1)算法描述"></a>(1)算法描述</h4><blockquote>
<p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
</blockquote>
<h4 id="2-算法描述和实现"><a href="#2-算法描述和实现" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>.比较相邻的元素。如果第一个比第二个大，就交换它们两个；</1></li>
<li><2>.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</2></li>
<li><3>.针对所有的元素重复以上的步骤，除了最后一个；</3></li>
<li><4>.重复步骤1~3，直到排序完成。</4></li>
</ul>
<p><strong>JavaScript代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> len = arr.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;        <span class="comment">//相邻元素两两对比</span></div><div class="line">                <span class="keyword">var</span> temp = arr[j+<span class="number">1</span>];        <span class="comment">//元素交换</span></div><div class="line">                arr[j+<span class="number">1</span>] = arr[j];</div><div class="line">                arr[j] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(bubbleSort(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<blockquote>
<p><strong>改进冒泡排序:</strong>设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。</p>
</blockquote>
<p>改进后算法如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort2</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'改进后冒泡排序耗时'</span>);</div><div class="line">    <span class="keyword">var</span> i = arr.length<span class="number">-1</span>;  <span class="comment">//初始时,最后位置保持不变</span></div><div class="line">    <span class="keyword">while</span> ( i&gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">var</span> pos= <span class="number">0</span>; <span class="comment">//每趟开始时,无记录交换</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j= <span class="number">0</span>; j&lt; i; j++)</div><div class="line">            <span class="keyword">if</span> (arr[j]&gt; arr[j+<span class="number">1</span>]) &#123;</div><div class="line">                pos= j; <span class="comment">//记录交换的位置</span></div><div class="line">                <span class="keyword">var</span> tmp = arr[j]; arr[j]=arr[j+<span class="number">1</span>];arr[j+<span class="number">1</span>]=tmp;</div><div class="line">            &#125;</div><div class="line">        i= pos; <span class="comment">//为下一趟排序作准备</span></div><div class="line">     &#125;</div><div class="line">     <span class="built_in">console</span>.timeEnd(<span class="string">'改进后冒泡排序耗时'</span>);</div><div class="line">     <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(bubbleSort2(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<blockquote>
<p>传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。</p>
</blockquote>
<p>改进后的算法实现为:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort3</span>(<span class="params">arr3</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> low = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> high= arr.length<span class="number">-1</span>; <span class="comment">//设置变量的初始值</span></div><div class="line">    <span class="keyword">var</span> tmp,j;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'2.改进后冒泡排序耗时'</span>);</div><div class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</div><div class="line">        <span class="keyword">for</span> (j= low; j&lt; high; ++j) <span class="comment">//正向冒泡,找到最大者</span></div><div class="line">            <span class="keyword">if</span> (arr[j]&gt; arr[j+<span class="number">1</span>]) &#123;</div><div class="line">                tmp = arr[j]; arr[j]=arr[j+<span class="number">1</span>];arr[j+<span class="number">1</span>]=tmp;</div><div class="line">            &#125;</div><div class="line">        --high;                 <span class="comment">//修改high值, 前移一位</span></div><div class="line">        <span class="keyword">for</span> (j=high; j&gt;low; --j) <span class="comment">//反向冒泡,找到最小者</span></div><div class="line">            <span class="keyword">if</span> (arr[j]&lt;arr[j<span class="number">-1</span>]) &#123;</div><div class="line">                tmp = arr[j]; arr[j]=arr[j<span class="number">-1</span>];arr[j<span class="number">-1</span>]=tmp;</div><div class="line">            &#125;</div><div class="line">        ++low;                  <span class="comment">//修改low值,后移一位</span></div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'2.改进后冒泡排序耗时'</span>);</div><div class="line">    <span class="keyword">return</span> arr3;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(bubbleSort3(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<p>三种方法耗时对比：</p>
<p><img src="http://img.blog.csdn.net/20160916163126374" alt="这里写图片描述"></p>
<blockquote>
<p>由图可以看出改进后的冒泡排序明显的时间复杂度更低，耗时更短了。读者自行尝试可以戳这，博主在github建了个库，读者可以Clone下来本地尝试。此博文配合源码体验更棒哦~~~</p>
</blockquote>
<p><strong>冒泡排序动图演示:</strong></p>
<p><img src="http://img.blog.csdn.net/20160916160748389" alt="这里写图片描述"></p>
<p><strong>(3)算法分析</strong></p>
<ul>
<li>最佳情况：T(n) = O(n)</li>
</ul>
<blockquote>
<p>当输入的数据已经是正序时（都已经是正序了，为毛何必还排序呢….）</p>
</blockquote>
<ul>
<li>最差情况：T(n) = O(n2)</li>
</ul>
<blockquote>
<p>当输入的数据是反序时(卧槽，我直接反序不就完了….)</p>
</blockquote>
<ul>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h3 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2.选择排序（Selection Sort）"></a>2.选择排序（Selection Sort）</h3><blockquote>
<p>表现最稳定的排序算法之一(这个稳定不是指算法层面上的稳定哈，相信聪明的你能明白我说的意思2333)，因为无论什么数据进去都是O(n²)的时间复杂度…..所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p>
</blockquote>
<h4 id="1-算法简介"><a href="#1-算法简介" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
</blockquote>
<h4 id="2-算法描述和实现-1"><a href="#2-算法描述和实现-1" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<ul>
<li><1>.初始状态：无序区为R[1..n]，有序区为空；</1></li>
<li><2>.第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</2></li>
<li><3>.n-1趟结束，数组有序化了。</3></li>
</ul>
<p><strong>Javascript代码实现:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> len = arr.length;</div><div class="line">    <span class="keyword">var</span> minIndex, temp;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'选择排序耗时'</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</div><div class="line">        minIndex = i;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class="comment">//寻找最小的数</span></div><div class="line">                minIndex = j;                 <span class="comment">//将最小数的索引保存</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        temp = arr[i];</div><div class="line">        arr[i] = arr[minIndex];</div><div class="line">        arr[minIndex] = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'选择排序耗时'</span>);</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(selectionSort(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<p><strong>选择排序动图演示：</strong></p>
<p><img src="http://img.blog.csdn.net/20160916164754013" alt="这里写图片描述"></p>
<h4 id="3-算法分析"><a href="#3-算法分析" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(n2)</li>
<li>最差情况：T(n) = O(n2)</li>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h2 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3.插入排序（Insertion Sort）"></a>3.插入排序（Insertion Sort）</h2><blockquote>
<p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。当然，如果你说你打扑克牌摸牌的时候从来不按牌的大小整理牌，那估计这辈子你对插入排序的算法都不会产生任何兴趣了…..</p>
</blockquote>
<h4 id="1-算法简介-1"><a href="#1-算法简介-1" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p> 插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
</blockquote>
<h4 id="2-算法描述和实现-2"><a href="#2-算法描述和实现-2" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<ul>
<li><1>.从第一个元素开始，该元素可以认为已经被排序；</1></li>
<li><2>.取出下一个元素，在已经排序的元素序列中从后向前扫描；</2></li>
<li><3>.如果该元素（已排序）大于新元素，将该元素移到下一位置；</3></li>
<li><4>.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</4></li>
<li><5>.将新元素插入到该位置后；</5></li>
<li><6>.重复步骤2~5。</6></li>
</ul>
<p><strong>Javascript代码实现:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(array).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Array'</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.time(<span class="string">'插入排序耗时：'</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</div><div class="line">            <span class="keyword">var</span> key = array[i];</div><div class="line">            <span class="keyword">var</span> j = i - <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; key) &#123;</div><div class="line">                array[j + <span class="number">1</span>] = array[j];</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">            array[j + <span class="number">1</span>] = key;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.timeEnd(<span class="string">'插入排序耗时：'</span>);</div><div class="line">        <span class="keyword">return</span> array;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'array is not an Array!'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>改进插入排序：</strong> 查找插入位置时使用二分查找的方式</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">binaryInsertionSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(array).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Array'</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.time(<span class="string">'二分插入排序耗时：'</span>);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</div><div class="line">            <span class="keyword">var</span> key = array[i], left = <span class="number">0</span>, right = i - <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (left &lt;= right) &#123;</div><div class="line">                <span class="keyword">var</span> middle = <span class="built_in">parseInt</span>((left + right) / <span class="number">2</span>);</div><div class="line">                <span class="keyword">if</span> (key &lt; array[middle]) &#123;</div><div class="line">                    right = middle - <span class="number">1</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    left = middle + <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i - <span class="number">1</span>; j &gt;= left; j--) &#123;</div><div class="line">                array[j + <span class="number">1</span>] = array[j];</div><div class="line">            &#125;</div><div class="line">            array[left] = key;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.timeEnd(<span class="string">'二分插入排序耗时：'</span>);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> array;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'array is not an Array!'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(binaryInsertionSort(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<blockquote>
<p>改进前后对比：</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20160916174656100" alt="这里写图片描述"></p>
<p><strong>插入排序动图演示:</strong></p>
<p><img src="http://img.blog.csdn.net/20160916173802597" alt="这里写图片描述"></p>
<h4 id="3-算法分析-1"><a href="#3-算法分析-1" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：输入数组按升序排列。T(n) = O(n)</li>
<li>最坏情况：输入数组按降序排列。T(n) = O(n2)</li>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h3 id="4-希尔排序（Shell-Sort）"><a href="#4-希尔排序（Shell-Sort）" class="headerlink" title="4.希尔排序（Shell Sort）"></a>4.希尔排序（Shell Sort）</h3><blockquote>
<p>1959年Shell发明；<br>第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序</p>
</blockquote>
<h4 id="1-算法简介-2"><a href="#1-算法简介-2" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版》的合著者Robert Sedgewick提出的。</p>
</blockquote>
<h4 id="2-算法描述和实现-3"><a href="#2-算法描述和实现-3" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li><1>. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</1></li>
<li><2>.按增量序列个数k，对序列进行k 趟排序；</2></li>
<li><3>.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</3></li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> len = arr.length,</div><div class="line">        temp,</div><div class="line">        gap = <span class="number">1</span>;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'希尔排序耗时:'</span>);</div><div class="line">    <span class="keyword">while</span>(gap &lt; len/<span class="number">5</span>) &#123;          <span class="comment">//动态定义间隔序列</span></div><div class="line">        gap =gap*<span class="number">5</span>+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (gap; gap &gt; <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap/<span class="number">5</span>)) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = gap; i &lt; len; i++) &#123;</div><div class="line">            temp = arr[i];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i-gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j-=gap) &#123;</div><div class="line">                arr[j+gap] = arr[j];</div><div class="line">            &#125;</div><div class="line">            arr[j+gap] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'希尔排序耗时:'</span>);</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(shellSort(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<p><strong>希尔排序图示（图片来源网络）：</strong></p>
<p><img src="http://img.blog.csdn.net/20160916235203417" alt="这里写图片描述"></p>
<h4 id="（3）算法分析"><a href="#（3）算法分析" class="headerlink" title="（3）算法分析"></a>（3）算法分析</h4><ul>
<li>最佳情况：T(n) = O(nlog2 n)</li>
<li>最坏情况：T(n) = O(nlog2 n)</li>
<li>平均情况：T(n) =O(nlog n)</li>
</ul>
<h3 id="5-归并排序（Merge-Sort）"><a href="#5-归并排序（Merge-Sort）" class="headerlink" title="5.归并排序（Merge Sort）"></a>5.归并排序（Merge Sort）</h3><blockquote>
<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</p>
</blockquote>
<h4 id="1-算法简介-3"><a href="#1-算法简介-3" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>　归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
</blockquote>
<h4 id="2-算法描述和实现-4"><a href="#2-算法描述和实现-4" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>.把长度为n的输入序列分成两个长度为n/2的子序列；</1></li>
<li><2>.对这两个子序列分别采用归并排序；</2></li>
<li><3>.将两个排序好的子序列合并成一个最终的排序序列。</3></li>
</ul>
<p><strong>Javscript代码实现:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;  <span class="comment">//采用自上而下的递归方法</span></div><div class="line">    <span class="keyword">var</span> len = arr.length;</div><div class="line">    <span class="keyword">if</span>(len &lt; <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">return</span> arr;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> middle = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>),</div><div class="line">        left = arr.slice(<span class="number">0</span>, middle),</div><div class="line">        right = arr.slice(middle);</div><div class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">var</span> result = [];</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'归并排序耗时'</span>);</div><div class="line">    <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</div><div class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</div><div class="line">            result.push(left.shift());</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            result.push(right.shift());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (left.length)</div><div class="line">        result.push(left.shift());</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (right.length)</div><div class="line">        result.push(right.shift());</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'归并排序耗时'</span>);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(mergeSort(arr));</div></pre></td></tr></table></figure>
<p><strong>归并排序动图演示:</strong></p>
<p><img src="http://img.blog.csdn.net/20160917001326254" alt="这里写图片描述"></p>
<h4 id="3-算法分析-2"><a href="#3-算法分析-2" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(n)</li>
<li>最差情况：T(n) = O(nlogn)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<h3 id="6-快速排序（Quick-Sort）"><a href="#6-快速排序（Quick-Sort）" class="headerlink" title="6.快速排序（Quick Sort）"></a>6.快速排序（Quick Sort）</h3><blockquote>
<p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高! 它是处理大数据最快的排序算法之一了。</p>
</blockquote>
<h4 id="1-算法简介-4"><a href="#1-算法简介-4" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
</blockquote>
<h4 id="2-算法描述和实现-5"><a href="#2-算法描述和实现-5" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li><1>.从数列中挑出一个元素，称为 “基准”（pivot）；</1></li>
<li><2>.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</2></li>
<li><3>.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</3></li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*方法说明：快速排序</span></div><div class="line">@param  array 待排序数组*/</div><div class="line"><span class="comment">//方法一</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">array, left, right</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'1.快速排序耗时'</span>);</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(array).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Array'</span> &amp;&amp; <span class="keyword">typeof</span> left === <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> right === <span class="string">'number'</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</div><div class="line">            <span class="keyword">var</span> x = array[right], i = left - <span class="number">1</span>, temp;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = left; j &lt;= right; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (array[j] &lt;= x) &#123;</div><div class="line">                    i++;</div><div class="line">                    temp = array[i];</div><div class="line">                    array[i] = array[j];</div><div class="line">                    array[j] = temp;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            quickSort(array, left, i - <span class="number">1</span>);</div><div class="line">            quickSort(array, i + <span class="number">1</span>, right);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.timeEnd(<span class="string">'1.快速排序耗时'</span>);</div><div class="line">        <span class="keyword">return</span> array;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'array is not an Array or left or right is not a number!'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//方法二</span></div><div class="line"><span class="keyword">var</span> quickSort2 = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'2.快速排序耗时'</span>);</div><div class="line">　　<span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> arr; &#125;</div><div class="line">　　<span class="keyword">var</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</div><div class="line">　　<span class="keyword">var</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</div><div class="line">　　<span class="keyword">var</span> left = [];</div><div class="line">　　<span class="keyword">var</span> right = [];</div><div class="line">　　<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</div><div class="line">　　　　<span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</div><div class="line">　　　　　　left.push(arr[i]);</div><div class="line">　　　　&#125; <span class="keyword">else</span> &#123;</div><div class="line">　　　　　　right.push(arr[i]);</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'2.快速排序耗时'</span>);</div><div class="line">　　<span class="keyword">return</span> quickSort2(left).concat([pivot], quickSort2(right));</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(quickSort(arr,<span class="number">0</span>,arr.length<span class="number">-1</span>));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div><div class="line"><span class="built_in">console</span>.log(quickSort2(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<p><strong>快速排序动图演示：</strong></p>
<p><img src="http://img.blog.csdn.net/20160917003004906" alt="快速排序"></p>
<h4 id="3-算法分析-3"><a href="#3-算法分析-3" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(nlogn)</li>
<li>最差情况：T(n) = O(n2)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<h3 id="7-堆排序（Heap-Sort）"><a href="#7-堆排序（Heap-Sort）" class="headerlink" title="7.堆排序（Heap Sort）"></a>7.堆排序（Heap Sort）</h3><blockquote>
<p>堆排序可以说是一种利用堆的概念来排序的选择排序。</p>
</blockquote>
<h4 id="1-算法简介-5"><a href="#1-算法简介-5" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
</blockquote>
<h4 id="2-算法描述和实现-6"><a href="#2-算法描述和实现-6" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>.将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</1></li>
<li><2>.将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</2></li>
<li><3>.由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</3></li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*方法说明：堆排序</span></div><div class="line">@param  array 待排序数组*/</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'堆排序耗时'</span>);</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(array).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Array'</span>) &#123;</div><div class="line">        <span class="comment">//建堆</span></div><div class="line">        <span class="keyword">var</span> heapSize = array.length, temp;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="built_in">Math</span>.floor(heapSize / <span class="number">2</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            heapify(array, i, heapSize);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//堆排序</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = heapSize - <span class="number">1</span>; j &gt;= <span class="number">1</span>; j--) &#123;</div><div class="line">            temp = array[<span class="number">0</span>];</div><div class="line">            array[<span class="number">0</span>] = array[j];</div><div class="line">            array[j] = temp;</div><div class="line">            heapify(array, <span class="number">0</span>, --heapSize);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.timeEnd(<span class="string">'堆排序耗时'</span>);</div><div class="line">        <span class="keyword">return</span> array;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'array is not an Array!'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*方法说明：维护堆的性质</span></div><div class="line">@param  arr 数组</div><div class="line">@param  x   数组下标</div><div class="line">@param  len 堆大小*/</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapify</span>(<span class="params">arr, x, len</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(arr).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Array'</span> &amp;&amp; <span class="keyword">typeof</span> x === <span class="string">'number'</span>) &#123;</div><div class="line">        <span class="keyword">var</span> l = <span class="number">2</span> * x + <span class="number">1</span>, r = <span class="number">2</span> * x + <span class="number">2</span>, largest = x, temp;</div><div class="line">        <span class="keyword">if</span> (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</div><div class="line">            largest = l;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</div><div class="line">            largest = r;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (largest != x) &#123;</div><div class="line">            temp = arr[x];</div><div class="line">            arr[x] = arr[largest];</div><div class="line">            arr[largest] = temp;</div><div class="line">            heapify(arr, largest, len);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'arr is not an Array or x is not a number!'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">91</span>,<span class="number">60</span>,<span class="number">96</span>,<span class="number">13</span>,<span class="number">35</span>,<span class="number">65</span>,<span class="number">46</span>,<span class="number">65</span>,<span class="number">10</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">31</span>,<span class="number">77</span>,<span class="number">81</span>,<span class="number">22</span>];</div><div class="line"><span class="built_in">console</span>.log(heapSort(arr));<span class="comment">//[10, 13, 20, 22, 30, 31, 35, 46, 60, 65, 65, 77, 81, 91, 96]</span></div></pre></td></tr></table></figure>
<p><strong>堆排序动图演示：</strong></p>
<p><img src="http://img.blog.csdn.net/20160917105502853" alt="这里写图片描述"></p>
<h4 id="3-算法分析-4"><a href="#3-算法分析-4" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(nlogn)</li>
<li>最差情况：T(n) = O(nlogn)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<h3 id="8-计数排序（Counting-Sort）"><a href="#8-计数排序（Counting-Sort）" class="headerlink" title="8.计数排序（Counting Sort）"></a>8.计数排序（Counting Sort）</h3><blockquote>
<p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。<br>作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
</blockquote>
<h4 id="1-算法简介-6"><a href="#1-算法简介-6" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p>
</blockquote>
<h4 id="2-算法描述和实现-7"><a href="#2-算法描述和实现-7" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>. 找出待排序的数组中最大和最小的元素；</1></li>
<li><2>. 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</2></li>
<li><3>. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</3></li>
<li><4>. 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</4></li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">countingSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> len = array.length,</div><div class="line">        B = [],</div><div class="line">        C = [],</div><div class="line">        min = max = array[<span class="number">0</span>];</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'计数排序耗时'</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        min = min &lt;= array[i] ? min : array[i];</div><div class="line">        max = max &gt;= array[i] ? max : array[i];</div><div class="line">        C[array[i]] = C[array[i]] ? C[array[i]] + <span class="number">1</span> : <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = min; j &lt; max; j++) &#123;</div><div class="line">        C[j + <span class="number">1</span>] = (C[j + <span class="number">1</span>] || <span class="number">0</span>) + (C[j] || <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k = len - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</div><div class="line">        B[C[array[k]] - <span class="number">1</span>] = array[k];</div><div class="line">        C[array[k]]--;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'计数排序耗时'</span>);</div><div class="line">    <span class="keyword">return</span> B;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>];</div><div class="line"><span class="built_in">console</span>.log(countingSort(arr)); <span class="comment">//[1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 6, 7, 7, 8, 8, 9, 9]</span></div></pre></td></tr></table></figure>
<p><strong>JavaScript动图演示：</strong>、</p>
<p><img src="http://img.blog.csdn.net/20160917110641479" alt="这里写图片描述"></p>
<h4 id="3-算法分析-5"><a href="#3-算法分析-5" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><blockquote>
<p>当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p>
</blockquote>
<ul>
<li>最佳情况：T(n) = O(n+k)</li>
<li>最差情况：T(n) = O(n+k)</li>
<li>平均情况：T(n) = O(n+k)</li>
</ul>
<h3 id="9-桶排序（Bucket-Sort）"><a href="#9-桶排序（Bucket-Sort）" class="headerlink" title="9.桶排序（Bucket Sort）"></a>9.桶排序（Bucket Sort）</h3><blockquote>
<p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p>
</blockquote>
<h4 id="1-算法简介-7"><a href="#1-算法简介-7" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排</p>
</blockquote>
<h4 id="2-算法描述和实现-8"><a href="#2-算法描述和实现-8" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>.设置一个定量的数组当作空桶；</1></li>
<li><2>.遍历输入数据，并且把数据一个一个放到对应的桶里去；</2></li>
<li><3>.对每个不是空的桶进行排序；</3></li>
<li><4>.从不是空的桶里把排好序的数据拼接起来。</4></li>
</ul>
<p><strong>Javascript代码实现:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*方法说明：桶排序</span></div><div class="line">@param  array 数组</div><div class="line">@param  num   桶的数量*/</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bucketSort</span>(<span class="params">array, num</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (array.length &lt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> array;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> len = array.length, buckets = [], result = [], min = max = array[<span class="number">0</span>], regex = <span class="string">'/^[1-9]+[0-9]*$/'</span>, space, n = <span class="number">0</span>;</div><div class="line">    num = num || ((num &gt; <span class="number">1</span> &amp;&amp; regex.test(num)) ? num : <span class="number">10</span>);</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'桶排序耗时'</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</div><div class="line">        min = min &lt;= array[i] ? min : array[i];</div><div class="line">        max = max &gt;= array[i] ? max : array[i];</div><div class="line">    &#125;</div><div class="line">    space = (max - min + <span class="number">1</span>) / num;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</div><div class="line">        <span class="keyword">var</span> index = <span class="built_in">Math</span>.floor((array[j] - min) / space);</div><div class="line">        <span class="keyword">if</span> (buckets[index]) &#123;   <span class="comment">//  非空桶，插入排序</span></div><div class="line">            <span class="keyword">var</span> k = buckets[index].length - <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; buckets[index][k] &gt; array[j]) &#123;</div><div class="line">                buckets[index][k + <span class="number">1</span>] = buckets[index][k];</div><div class="line">                k--;</div><div class="line">            &#125;</div><div class="line">            buckets[index][k + <span class="number">1</span>] = array[j];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//空桶，初始化</span></div><div class="line">            buckets[index] = [];</div><div class="line">            buckets[index].push(array[j]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (n &lt; num) &#123;</div><div class="line">        result = result.concat(buckets[n]);</div><div class="line">        n++;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'桶排序耗时'</span>);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(bucketSort(arr,<span class="number">4</span>));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<p><strong>桶排序图示（图片来源网络）：</strong></p>
<p><img src="http://img.blog.csdn.net/20160917111945979" alt="这里写图片描述"></p>
<p>关于桶排序<a href="http://www.cnblogs.com/lonelyxmas/p/3561938.html" target="_blank" rel="external">更多</a></p>
<h4 id="3-算法分析-6"><a href="#3-算法分析-6" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><blockquote>
<p>　桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p>
</blockquote>
<ul>
<li>最佳情况：T(n) = O(n+k)</li>
<li>最差情况：T(n) = O(n+k)</li>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h3 id="10-基数排序（Radix-Sort）"><a href="#10-基数排序（Radix-Sort）" class="headerlink" title="10.基数排序（Radix Sort）"></a>10.基数排序（Radix Sort）</h3><blockquote>
<p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；</p>
</blockquote>
<h4 id="1-算法简介-8"><a href="#1-算法简介-8" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>
</blockquote>
<h4 id="2-算法描述和实现-9"><a href="#2-算法描述和实现-9" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>.取得数组中的最大数，并取得位数；</1></li>
<li><2>.arr为原始数组，从最低位开始取每个位组成radix数组；</2></li>
<li><3>.对radix进行计数排序（利用计数排序适用于小范围数的特点）；</3></li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 基数排序适用于：</div><div class="line"> *  (1)数据范围较小，建议在小于1000</div><div class="line"> *  (2)每个数值都要大于等于0</div><div class="line"> * @author damonare</div><div class="line"> * @param  arr 待排序数组</div><div class="line"> * @param  maxDigit 最大位数</div><div class="line"> */</div><div class="line"><span class="comment">//LSD Radix Sort</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">radixSort</span>(<span class="params">arr, maxDigit</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> mod = <span class="number">10</span>;</div><div class="line">    <span class="keyword">var</span> dev = <span class="number">1</span>;</div><div class="line">    <span class="keyword">var</span> counter = [];</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'基数排序耗时'</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</div><div class="line">            <span class="keyword">var</span> bucket = <span class="built_in">parseInt</span>((arr[j] % mod) / dev);</div><div class="line">            <span class="keyword">if</span>(counter[bucket]== <span class="literal">null</span>) &#123;</div><div class="line">                counter[bucket] = [];</div><div class="line">            &#125;</div><div class="line">            counter[bucket].push(arr[j]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> pos = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; counter.length; j++) &#123;</div><div class="line">            <span class="keyword">var</span> value = <span class="literal">null</span>;</div><div class="line">            <span class="keyword">if</span>(counter[j]!=<span class="literal">null</span>) &#123;</div><div class="line">                <span class="keyword">while</span> ((value = counter[j].shift()) != <span class="literal">null</span>) &#123;</div><div class="line">                      arr[pos++] = value;</div><div class="line">                &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'基数排序耗时'</span>);</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(radixSort(arr,<span class="number">2</span>)); <span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<p><strong>基数排序LSD动图演示：</strong></p>
<p><img src="http://img.blog.csdn.net/20160917123313659" alt="这里写图片描述"></p>
<h4 id="3-算法分析-7"><a href="#3-算法分析-7" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(n * k)</li>
<li>最差情况：T(n) = O(n * k)</li>
<li>平均情况：T(n) = O(n * k)</li>
</ul>
<p>基数排序有两种方法：</p>
<ul>
<li>MSD 从高位开始进行排序</li>
<li>LSD 从低位开始进行排序</li>
</ul>
<p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p>
<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ol>
<li>基数排序：根据键值的每位数字来分配桶</li>
<li>计数排序：每个桶只存储单一键值</li>
<li>桶排序：每个桶存储一定范围的数值</li>
</ol>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote>
<p>十大排序算法的总结到这里就算告一段落了。博主总结完之后只有一个感觉，排序算法博大精深，前辈们用了数年甚至一辈子的心血研究出来的算法更值得我们推敲。站在十大算法的门前心里还是诚惶诚恐的，身为一个小学生，博主的总结难免会有所疏漏，欢迎各位批评指定。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt;  本文图文并茂的详细讲述了十大经典排序算法用javascript实现的过程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文博客地址：&lt;a href=&quot;http://damonare.github.io/2016/09/16/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88javascript%E6%8F%8F%E8%BF%B0%EF%BC%89/#more&quot;&gt;十大经典排序算法&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人生有情泪沾衣，江水江花岂终极。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://damonare.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://damonare.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>百度FE工程师实习offer到手记</title>
    <link href="http://damonare.github.io/2016/12/13/%E6%88%91%E7%9A%84Web%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86-%E7%99%BE%E5%BA%A6/"/>
    <id>http://damonare.github.io/2016/12/13/我的Web面试经历-百度/</id>
    <published>2016-12-13T12:10:20.000Z</published>
    <updated>2016-12-13T12:10:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong>  本文总结了博主最近参加百度FE工程师面试过程中的一些心得和体会，分享给还在求职的同学以作参考，希望能给以帮助或是启迪。另外博主就读于<a href="http://www.xidian.edu.cn/" target="_blank" rel="external">西安电子科技大学</a>，现在是大三在读。</p>
<ul>
<li><p>原文博客地址：<a href="http://damonare.github.io/2016/12/13/%E6%88%91%E7%9A%84Web%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86-%E7%99%BE%E5%BA%A6/#more">百度FE工程师实习offer到手记</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>没有什么能够阻挡，你对自由的向往。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><blockquote>
<p>整个面试过程是略微曲折的，博主参加了百度两个部门的面试，一个部门拿到了实习offer，另一个部门挂在了二面。文后暂且称为部门甲和部门乙吧。</p>
</blockquote>
<h3 id="面试前"><a href="#面试前" class="headerlink" title="面试前"></a>面试前</h3><p><strong>基础知识储备</strong></p>
<p>作为一个FE(front-end,也就是前端)工程师基础的扎实是十分重要的。基本的HTML，CSS，Javascript知识得懂吧，自己的技术栈得建立起来吧，毕竟前端框架层出不穷，起码要有一个稳定的路线支撑着自己研究下去啊。基础知识部分这里推荐两篇博主之前的博文：</p>
<ul>
<li><a href="http://damonare.github.io/2016/09/07/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/#more">前端面试题集</a></li>
<li><a href="http://damonare.github.io/2016/09/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8/#more">前端面试大全</a></li>
</ul>
<p>有一篇是我自己总结的，一篇是转载大牛的，都可以看一下。</p>
<p><strong>简历与经历</strong></p>
<p>好的表达能力确实是很加分的，语言流畅，思路清晰，多说专业词汇，我觉得会给面试官留下很好的印象。将简历的内容完整的表达出来并不容易，每一个人在刚开始写简历的时候肯定都会尽量把自己忘好的方向写，但心里没有个尺度是不行的，太完美的人是不存在的，敢写就先要想好如果面试官问该怎么回答，或是会问什么问题，站在面试官的角度思考一下，某一方面到底有没有必要写在简历里。这个自己心里是要有数的。比如：关于某社团经历，组织过什么小活动，怎么组织的，时间地点人物安排的流程是什么样的，心里是要有准的;再比如：关于某项目经历，该项目的技术难点，遇到的问题以及解决方法，技术栈是啥，由几部分人组成，开发周期等信息心里是要有数的。</p>
<p>简历这块我总结如下，最基本的：</p>
<ul>
<li>姓名、电话、邮箱、学校、位置等必要信息</li>
<li>项目经历(技术栈，个人担任的角色，项目内容要说明白</li>
<li>获奖经历(别把高中得过三好学生这种的扯出来就好…)</li>
<li>个人性格(纯属凑字数)</li>
</ul>
<p>加分项：</p>
<ul>
<li>实习经历</li>
<li>Github开源项目</li>
<li>个人博客</li>
</ul>
<p><strong>投递地址</strong></p>
<p>可以找一些招聘网站投递简历，比如：</p>
<ul>
<li><a href="http://my.zhaopin.com/" target="_blank" rel="external">智联招聘</a></li>
<li><a href="http://my.51job.com/" target="_blank" rel="external">前程无忧</a></li>
<li><a href="http://passport.lagou.com/" target="_blank" rel="external">拉钩</a></li>
<li>相关企业的校招网站</li>
<li>大佬内推</li>
</ul>
<h3 id="面试中"><a href="#面试中" class="headerlink" title="面试中"></a>面试中</h3><p>博主先面试的是部门甲，一面面试官声音很好听，给人一种很放松的感觉。<br>下面是一面问的问题：</p>
<ul>
<li>自我介绍</li>
<li>拿手项目难点解决方法</li>
<li>gulp和webpack对比</li>
<li>git和svn对比</li>
<li>CSS居中方法</li>
<li>vue和react对比</li>
<li>如何用栈实现队列</li>
<li>取球算法问题</li>
<li>Es6你常用的特性</li>
<li>jquery和react对比</li>
<li>原生实现ajax</li>
<li>口述react单项数据流</li>
<li>react子组件如何传值给父组件</li>
</ul>
<p>一面太紧张了，很多问题回答的支支吾吾的，好在大佬给了二面机会，二面的面试官感觉性格也是很好的那种人，有说有笑的，问的问题如下：</p>
<ul>
<li>HTML5表单新特性</li>
<li>自己总结下编写html使用嵌套的注意点</li>
<li>scss的好处</li>
<li>写过什么复杂的数据交互的页面没，介绍下</li>
<li>无限级联动的注意点</li>
<li>描述下跨域使用场景，举例说明</li>
<li>gulp和webpack对比介绍</li>
<li>gulp和webpack原理区别</li>
<li>口述如何模拟radio，模拟下拉框</li>
</ul>
<p>然后参加了部门乙的一面，问题如下：</p>
<ul>
<li>CSS两栏布局</li>
<li>gulp和webpack对比</li>
<li>vue和react对比</li>
</ul>
<p>这次的一面博主忘记做记录了，很多问题想不起来了….十分抱歉，二面很简单，问题如下：</p>
<ul>
<li>分析下URL由哪几部分组成的</li>
<li>冒泡排序的时间复杂度，是否稳定</li>
<li>堆排序的时间复杂度，是否稳定</li>
<li>单链表反转</li>
</ul>
<p>博主自以为这四个问题答得还可以呢，以为应该过了，最后原来只是我以为…部门乙的面试石沉大海再无消息。</p>
<p>隔天,部门甲来电话说给我笔试题，让我做做看。用他们的技术栈实现一个备忘录，要求一周内完成。说是备忘录实际上就是稍微复杂一点的todolist。技术栈要求：react+redux+react-router+less+ES6。</p>
<p>这事似乎有门！博主抓紧查阅了资料学习。之前对于react是熟悉的但redux一直没怎么懂，另外博主平时使用较多的CSS预处理语言是scss，less没用过，又是一通查阅。好在博主小爆发了一下，两天时间写完了，交了上去。现在看看，感觉自己还是有潜力发掘的，人被逼急了大脑真是会疯狂运转。算是超预期完成了吧，加上了react-router和本地化存储以及一些小feature。下面是在线地址，感兴趣的话您可以去看看：<a href="http://damonare.cn/memos" target="_blank" rel="external">Damonare的备忘录</a></p>
<p>笔试题结束后，隔了几天(大佬看完了我的笔试题代码之后)，来了三面，三面的面试官也很和蔼，给人一种很亲切的感觉。大概聊了一下具体的时间安排以及我平时的一些活动和对于一些专业名词的理解。面试官说我技术面实际上表现的很不好，很多问题都答得不尽人意，但看我挺喜欢这行的，就给了我一次笔试的机会，好在我笔试过关了…(很后怕啊)</p>
<h3 id="面试后"><a href="#面试后" class="headerlink" title="面试后"></a>面试后</h3><p>技术面试流程我总结是这样的：</p>
<ul>
<li>自我介绍(必不可少啊，总得让面试官大概的了解自己吧)</li>
<li>基础知识阶段(广度阶段)</li>
<li>项目中遇到的难点以及解决方法</li>
<li>针对某一技术进行深度挖掘</li>
<li>你有什么要问我的</li>
</ul>
<p>我个人在最后的阶段，两个部门都问了一下他们现在所使用的的技术栈。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际上能拿到这次百度的实习offer，您也能看出来很大一部分我靠的都是运气。部门甲的面试官们看了我的博客，同时他们在面试的时候也就几篇博文对我提了几个问题，可能也是从博客看出我对于FE的喜爱的吧。所以给了笔试的机会，否则我想部门甲的面试也会和部门乙一样挂掉。</p>
<p>但话说回来了，博客是自己搭的，博文是一篇一篇积累起来的，也不能说全是运气。</p>
<p>引用一句从一位现在在阿里工作的学长的一句话：<code>让别人知道你知道</code>。</p>
<p>让别人知道你知道，说起来好像很简单，但其实做起来并不容易，这个并不是只靠说的，嘴巴一张一合也只是让一个人知道了而已。想让更多人知道就得下点功夫了。不要在意别人的言语，包括博主自己现在某种程度上还是活在别人的眼里。那种过于在意别人的言语，渐渐把自己活成别人眼里的模样的人不是很可悲么。活出自己！过自己的生活，与他人何干。就像博主平时会码代码码到很晚，旁边也常传来一些不理解的话，诸如<code>码农</code>、<code>天天就知道写代码</code>。做自己！干自己喜欢的事！何必去理别人的看法呢！</p>
<p>另外，博主不是科班出身，不要以非科班或自己是个文科生去逃避，喜欢就去学，想做就做！Man一点好伐！诸如阮一峰，尤小右那样的大神不也是非科班一步步成就了现在的地位的么。</p>
<p>还有一点，如果您是一个现在在犹豫是否学习FE或是其他技术的人，请理智一点！千万不要拿我不喜欢技术这种枯燥的事为理由搪塞，谁告诉你技术枯燥的？！网络就是程序员的天下，所谓的程序员呆板钱多话少死得早都是程序员自黑的话，这种你也敢信？文字工作发泄情绪的平台是笔杆子，农民发泄情绪的平台是锄头，可悲的是这些并不会被大多数人看到，而程序员的自黑却会被整个网络的人看到。这点道理不明白？羡慕高薪就去学，学完了再去评论。没学过就说不感兴趣，那是愚蠢的！</p>
<p>最后，试着去推销自己吧，<code>让别人知道你知道</code>的方式有很多，诸如：做公众号，开专栏，写博客等方式。</p>
<p>当然为了不必要的烦恼，最好还是用昵称来经营自己。那么，博主选择方式就是写博客了。</p>
<p>就写博客这件事来说，一来可以作为自己学习的记录，二来可以作为一个学习笔记，三来可以作为一个知识分享的形式，一举三得，实在是个很好的方式。博主刚开始写的时候是没有人看的，当您正处在这个阶段的时候，不要放弃，坚持写，坚持记录，总有一天会有人发现某一篇博文的精彩的。不求带来多少经济利益，只为能给屏幕前的读者一丝帮助或是启迪。</p>
<p>总的来说，面试必需的三个要素我觉得如下：<code>礼貌</code>、<code>专业能力</code>、<code>运气</code>。一次面试的失败并没有什么，天时地利人和是很难凑齐的。不要灰心丧气，重整旗鼓，再战苍穹便是！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt;  本文总结了博主最近参加百度FE工程师面试过程中的一些心得和体会，分享给还在求职的同学以作参考，希望能给以帮助或是启迪。另外博主就读于&lt;a href=&quot;http://www.xidian.edu.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;西安电子科技大学&lt;/a&gt;，现在是大三在读。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文博客地址：&lt;a href=&quot;http://damonare.github.io/2016/12/13/%E6%88%91%E7%9A%84Web%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86-%E7%99%BE%E5%BA%A6/#more&quot;&gt;百度FE工程师实习offer到手记&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;没有什么能够阻挡，你对自由的向往。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="实习" scheme="http://damonare.github.io/categories/%E5%AE%9E%E4%B9%A0/"/>
    
    
      <category term="面试" scheme="http://damonare.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>CSS三栏布局的四种方法</title>
    <link href="http://damonare.github.io/2016/12/11/CSS%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://damonare.github.io/2016/12/11/CSS三栏布局的四种方法/</id>
    <published>2016-12-11T10:11:06.000Z</published>
    <updated>2016-12-11T10:11:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 不管是三栏布局还是两栏布局都是我们在平时项目里经常使用的，也许你不知道什么事三栏布局什么是两栏布局但实际已经在用，或许你知道三栏布局的一种或两种方法，但实际操作中也只会依赖那某一种方法，本文具体的介绍了三栏布局的四种方法，并介绍了它的使用场景。</p>
<ul>
<li><p>原文地址：<a href="http://damonare.github.io/2016/12/07/CSS%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/#more">CSS三栏布局的四种方法</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>年华一去不复返，事业放弃再难成。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><blockquote>
<p>所谓三栏布局就是指页面分为左中右三部分然后对中间一部分做自适应的一种布局方式。</p>
</blockquote>
<h3 id="1-绝对定位法"><a href="#1-绝对定位法" class="headerlink" title="1.绝对定位法"></a>1.绝对定位法</h3><p>HTML代码如下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>Left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span>Main<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>Right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>CSS代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//简单的进行CSS reset</div><div class="line">body,html&#123;</div><div class="line">    height:100%;</div><div class="line">    padding: 0px;</div><div class="line">    margin:0px;</div><div class="line">&#125;</div><div class="line">//左右绝对定位</div><div class="line">.left,.right&#123;</div><div class="line">    position: absolute;</div><div class="line">    top:0px;</div><div class="line">    background: red;</div><div class="line">    height:100%;</div><div class="line">&#125;</div><div class="line">.left&#123;</div><div class="line">    left:0;</div><div class="line">    width:100px;</div><div class="line">&#125;</div><div class="line">.right&#123;</div><div class="line">    right:0px;</div><div class="line">    width:200px;</div><div class="line">&#125;</div><div class="line">//中间使用margin空出左右元素所占据的空间</div><div class="line">.main&#123;</div><div class="line">    margin:0px 200px 0px 100px;</div><div class="line">    height:100%;</div><div class="line">    background: blue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法有个明显的缺点，就是如果中间栏含有最小宽度限制，或是含有宽度的内部元素，当浏览器宽度小到一定程度，会发生层重叠的情况。</p>
<h3 id="2-圣杯布局"><a href="#2-圣杯布局" class="headerlink" title="2. 圣杯布局"></a>2. 圣杯布局</h3><p>HTML代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//注意元素次序</div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span>Main<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>Left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>Right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>CSS代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">//习惯性的CSS reset</div><div class="line">body,html&#123;</div><div class="line">    height:100%;</div><div class="line">    padding: 0;</div><div class="line">    margin: 0</div><div class="line">&#125;</div><div class="line">//父元素body空出左右栏位</div><div class="line">body &#123;</div><div class="line">    padding-left: 100px;</div><div class="line">    padding-right: 200px;</div><div class="line">&#125;</div><div class="line">//左边元素更改</div><div class="line">.left &#123;</div><div class="line">    background: red;</div><div class="line">    width: 100px;</div><div class="line">    float: left;</div><div class="line">    margin-left: -100%;</div><div class="line">    position: relative;</div><div class="line">    left: -100px;</div><div class="line">    height: 100%;</div><div class="line">&#125;</div><div class="line">//中间部分</div><div class="line">.main &#123;</div><div class="line">    background: blue;</div><div class="line">    width: 100%;</div><div class="line">    height: 100%;</div><div class="line">    float: left;</div><div class="line">&#125;</div><div class="line">//右边元素定义</div><div class="line">.right &#123;</div><div class="line">    background: red;</div><div class="line">    width: 200px;</div><div class="line">    height: 100%;</div><div class="line">    float: left;</div><div class="line">    margin-left: -200px;</div><div class="line">    position: relative;</div><div class="line">    right: -200px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相关解释如下：</p>
<ul>
<li>(1)中间部分需要根据浏览器宽度的变化而变化，所以要用100%，这里设左中右向左浮动，因为中间100%，左层和右层根本没有位置上去</li>
<li>(2)把左层margin负100后，发现left上去了，因为负到出窗口没位置了，只能往上挪</li>
<li>(3)按第二步这个方法，可以得出它只要挪动窗口宽度那么宽就能到最左边了，利用负边距，把左右栏定位</li>
<li>(4)但由于左右栏遮挡住了中间部分，于是采用相对定位方法，各自相对于自己把自己挪出去，得到最终结果</li>
</ul>
<h3 id="3-双飞翼布局"><a href="#3-双飞翼布局" class="headerlink" title="3. 双飞翼布局"></a>3. 双飞翼布局</h3><p>HTML代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span></div><div class="line">        Main</div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>Left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>Right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>CSS代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">//CSS reset</div><div class="line">body,html &#123;</div><div class="line">    height:100%;</div><div class="line">    padding: 0;</div><div class="line">    margin: 0</div><div class="line">&#125;</div><div class="line">body &#123;</div><div class="line">    /*padding-left:100px;*/</div><div class="line">    /*padding-right:200px;*/</div><div class="line">&#125;</div><div class="line">.left &#123;</div><div class="line">    background: red;</div><div class="line">    width: 100px;</div><div class="line">    float: left;</div><div class="line">    margin-left: -100%;</div><div class="line">    height: 100%;</div><div class="line">    /*position: relative;*/</div><div class="line">    /*left:-100px;*/</div><div class="line">&#125;</div><div class="line">.main &#123;</div><div class="line">    background: blue;</div><div class="line">    width: 100%;</div><div class="line">    float: left;</div><div class="line">    height: 100%;</div><div class="line">&#125;</div><div class="line">.right &#123;</div><div class="line">    background: red;</div><div class="line">    width: 200px;</div><div class="line">    float: left;</div><div class="line">    margin-left: -200px;</div><div class="line">    height: 100%;</div><div class="line">    /*position:relative;*/</div><div class="line">    /*right:-200px;*/</div><div class="line">&#125;</div><div class="line">//新增inner元素</div><div class="line">.inner &#123;</div><div class="line">    margin-left: 100px;</div><div class="line">    margin-right: 200px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>圣杯布局实际看起来是复杂的后期维护性也不是很高，在淘宝UED的探讨下，出来了一种新的布局方式就是双飞翼布局，代码如上。增加多一个div就可以不用相对布局了，只用到了浮动和负边距。和圣杯布局差异的地方已经被注释。</p>
<h3 id="4-浮动"><a href="#4-浮动" class="headerlink" title="4. 浮动"></a>4. 浮动</h3><p>HTML代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//注意元素次序</div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>Left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>Right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span>Main<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>CSS代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//CSS reset</div><div class="line">body,html &#123;</div><div class="line">    height:100%;</div><div class="line">    padding: 0;</div><div class="line">    margin: 0</div><div class="line">&#125;</div><div class="line">//左栏左浮动</div><div class="line">.left &#123;</div><div class="line">    background: red;</div><div class="line">    width: 100px;</div><div class="line">    float: left;</div><div class="line">    height: 100%;</div><div class="line">&#125;</div><div class="line">//中间自适应</div><div class="line">.main &#123;</div><div class="line">    background: blue;</div><div class="line">    height: 100%;</div><div class="line">    margin:0px 200px 0px 100px;</div><div class="line">&#125;</div><div class="line">//右栏右浮动</div><div class="line">.right &#123;</div><div class="line">    background: red;</div><div class="line">    width: 200px;</div><div class="line">    float: right;</div><div class="line">    height: 100%;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式代码足够简洁与高效，也容易理解</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>四种方法其实只有圣杯布局和双飞翼布局较难理解，但实际上理解了圣杯布局，双飞翼布局自然就理解了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 不管是三栏布局还是两栏布局都是我们在平时项目里经常使用的，也许你不知道什么事三栏布局什么是两栏布局但实际已经在用，或许你知道三栏布局的一种或两种方法，但实际操作中也只会依赖那某一种方法，本文具体的介绍了三栏布局的四种方法，并介绍了它的使用场景。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://damonare.github.io/2016/12/07/CSS%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/#more&quot;&gt;CSS三栏布局的四种方法&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;年华一去不复返，事业放弃再难成。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="CSS" scheme="http://damonare.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>前端跨域整理</title>
    <link href="http://damonare.github.io/2016/12/01/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E6%95%B4%E7%90%86/"/>
    <id>http://damonare.github.io/2016/12/01/前端跨域整理/</id>
    <published>2016-12-01T13:57:52.000Z</published>
    <updated>2016-12-01T13:57:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 相信每一个前端er对于跨域这两个字都不会陌生，在实际项目中应用也是比较多的。但跨域方法的多种多样实在让人目不暇接。老规矩，碰到这种情况，就只能自己总结一篇博客，作为记录。</p>
<ul>
<li><p>原文地址：<a href="http://damonare.github.io/2016/10/30/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E6%95%B4%E7%90%86/#more">前端跨域总结</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></li>
</ul>
<p><strong>人生在勤，不索何获。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-什么是跨域？"><a href="#1-什么是跨域？" class="headerlink" title="1. 什么是跨域？"></a>1. 什么是跨域？</h3><blockquote>
<p> 跨域一词从字面意思看，就是跨域名嘛，但实际上跨域的范围绝对不止那么狭隘。具体概念如下：只要协议、域名、端口有任何一个不同，都被当作是不同的域。之所以会产生跨域这个问题呢，其实也很容易想明白，要是随便引用外部文件，不同标签下的页面引用类似的彼此的文件，浏览器很容易懵逼的，安全也得不到保障了就。什么事，都是安全第一嘛。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。所以我们要通过一些方法使本域的js能够操作其他域的页面对象或者使其他域的js能操作本域的页面对象（iframe之间）。下面是具体的跨域情况详解：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">URL                      说明       是否允许通信</div><div class="line">http:<span class="comment">//www.a.com/a.js</span></div><div class="line">http:<span class="comment">//www.a.com/b.js     同一域名下   允许</span></div><div class="line"></div><div class="line">http:<span class="comment">//www.a.com/lab/a.js</span></div><div class="line">http:<span class="comment">//www.a.com/script/b.js 同一域名下不同文件夹 允许</span></div><div class="line"></div><div class="line">http:<span class="comment">//www.a.com:8000/a.js</span></div><div class="line">http:<span class="comment">//www.a.com/b.js     同一域名，不同端口  不允许</span></div><div class="line"></div><div class="line">http:<span class="comment">//www.a.com/a.js</span></div><div class="line">https:<span class="comment">//www.a.com/b.js 同一域名，不同协议 不允许</span></div><div class="line"></div><div class="line">http:<span class="comment">//www.a.com/a.js</span></div><div class="line">http:<span class="comment">//70.32.92.74/b.js 域名和域名对应ip 不允许</span></div><div class="line"></div><div class="line">http:<span class="comment">//www.a.com/a.js</span></div><div class="line">http:<span class="comment">//script.a.com/b.js 主域相同，子域不同 不允许（cookie这种情况下也不允许访问）</span></div><div class="line"></div><div class="line">http:<span class="comment">//www.a.com/a.js</span></div><div class="line">http:<span class="comment">//a.com/b.js 同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问）</span></div><div class="line"></div><div class="line">http:<span class="comment">//www.cnblogs.com/a.js</span></div><div class="line">http:<span class="comment">//www.a.com/b.js 不同域名 不允许</span></div></pre></td></tr></table></figure>
<p><strong>这里我们需要注意两点:</strong></p>
<ol>
<li>如果是协议和端口造成的跨域问题“前台”是无能为力的；</li>
<li>在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。<br>(“URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。)</li>
</ol>
<h3 id="2-通过document-domain跨域"><a href="#2-通过document-domain跨域" class="headerlink" title="2. 通过document.domain跨域"></a>2. 通过document.domain跨域</h3><blockquote>
<p>前面说过了，浏览器有一个同源策略，其限制之一是不能通过ajax的方法去请求不同源中的文档。 第二个限制是浏览器中不同域的框架之间是不能进行js的交互操作的。不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。比如，有一个页面，它的地址是<a href="http://www.damonare.cn/a.html" target="_blank" rel="external">http://www.damonare.cn/a.html</a> ， 在这个页面里面有一个iframe，它的src是<a href="http://damonare.cn/b.html" target="_blank" rel="external">http://damonare.cn/b.html</a>, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的：</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line">    function test()&#123;</div><div class="line">        var iframe = document.getElementById('￼ifame');</div><div class="line">        var win = iframe.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的</div><div class="line">        var doc = win.document;//这里获取不到iframe里的document对象</div><div class="line">        var name = win.name;//这里同样获取不到window对象的name属性</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;iframe id = "iframe" src="http://damonare.cn/b.html" onload = "test()"&gt;&lt;/iframe&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>这个时候，document.domain就可以派上用场了，我们只要把<a href="http://www.damonare.cn/a.html和http://damonare.cn/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。" target="_blank" rel="external">http://www.damonare.cn/a.html和http://damonare.cn/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。</a></p>
</blockquote>
<ul>
<li>在页面<a href="http://www.damonare.cn/a.html" target="_blank" rel="external">http://www.damonare.cn/a.html</a> 中设置document.domain:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;iframe id = <span class="string">"iframe"</span> src=<span class="string">"http://damonare.cn/b.html"</span> onload = <span class="string">"test()"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></div><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    <span class="built_in">document</span>.domain = <span class="string">'damonare.cn'</span>;<span class="comment">//设置成主域</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="built_in">document</span>.getElementById(<span class="string">'￼iframe'</span>).contentWindow);<span class="comment">//contentWindow 可取得子窗口的 window 对象</span></div><div class="line">    &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>在页面<a href="http://damonare.cn/b.html" target="_blank" rel="external">http://damonare.cn/b.html</a> 中也设置document.domain:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    <span class="built_in">document</span>.domain = <span class="string">'damonare.cn'</span>;<span class="comment">//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p><strong>修改document.domain的方法只适用于不同子域的框架间的交互。</strong></p>
<h3 id="3-通过location-hash跨域"><a href="#3-通过location-hash跨域" class="headerlink" title="3. 通过location.hash跨域"></a>3. 通过location.hash跨域</h3><blockquote>
<p>因为父窗口可以对iframe进行URL读写，iframe也可以读写父窗口的URL，URL有一部分被称为hash，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server端并不关心这部分，应该说HTTP请求过程中不会携带hash，所以这部分的修改不会产生HTTP请求，但是会产生浏览器历史记录。此方法的原理就是改变URL的hash部分来进行双向通信。每个window通过改变其他 window的location来发送消息（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe），并通过监听自己的URL的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持onhashchange事件，需要轮询来获知URL的改变，最后，这样做也存在缺点，诸如数据直接暴露在了url中，数据容量和类型都有限等。下面举例说明：</p>
</blockquote>
<p>假如父页面是baidu.com/a.html,iframe嵌入的页面为google.com/b.html（此处省略了域名等url属性），要实现此两个页面间的通信可以通过以下方法。</p>
<ul>
<li>a.html传送数据到b.html<ul>
<li>a.html下修改iframe的src为google.com/b.html#paco</li>
<li>b.html监听到url发生变化，触发相应操作</li>
</ul>
</li>
<li><p>b.html传送数据到a.html，由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe</p>
<ul>
<li>b.html下创建一个隐藏的iframe，此iframe的src是baidu.com域下的，并挂上要传送的hash数据，如src=”<a href="http://www.baidu.com/proxy.html#data" target="_blank" rel="external">http://www.baidu.com/proxy.html#data</a>“</li>
<li>proxy.html监听到url发生变化，修改a.html的url（因为a.html和proxy.html同域，所以proxy.html可修改a.html的url hash）</li>
<li>a.html监听到url发生变化，触发相应操作</li>
</ul>
</li>
</ul>
<p>b.html页面的关键代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;  </div><div class="line">    parent.location.hash = <span class="string">'data'</span>;  </div><div class="line">&#125; <span class="keyword">catch</span> (e) &#123;  </div><div class="line">    <span class="comment">// ie、chrome的安全机制无法修改parent.location.hash，  </span></div><div class="line">    <span class="keyword">var</span> ifrproxy = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);  </div><div class="line">    ifrproxy.style.display = <span class="string">'none'</span>;  </div><div class="line">    ifrproxy.src = <span class="string">"http://www.baidu.com/proxy.html#data"</span>;  </div><div class="line">    <span class="built_in">document</span>.body.appendChild(ifrproxy);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>proxy.html页面的关键代码如下 :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//因为parent.parent（即baidu.com/a.html）和baidu.com/proxy.html属于同一个域，所以可以改变其location.hash的值  </span></div><div class="line">parent.parent.location.hash = self.location.hash.substring(<span class="number">1</span>);</div></pre></td></tr></table></figure>
<h3 id="4-通过HTML5的postMessage方法跨域"><a href="#4-通过HTML5的postMessage方法跨域" class="headerlink" title="4. 通过HTML5的postMessage方法跨域"></a>4. 通过HTML5的postMessage方法跨域</h3><blockquote>
<p>高级浏览器Internet Explorer 8+, chrome，Firefox , Opera  和 Safari 都将支持这个功能。这个功能主要包括接受信息的”message”事件和发送消息的”postMessage”方法。比如damonare.cn域的A页面通过iframe嵌入了一个google.com域的B页面，可以通过以下方法实现A和B的通信</p>
</blockquote>
<p>A页面通过postMessage方法发送消息：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </div><div class="line">    <span class="keyword">var</span> ifr = <span class="built_in">document</span>.getElementById(<span class="string">'ifr'</span>);  </div><div class="line">    <span class="keyword">var</span> targetOrigin = <span class="string">"http://www.google.com"</span>;  </div><div class="line">    ifr.contentWindow.postMessage(<span class="string">'hello world!'</span>, targetOrigin);  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>postMessage的使用方法：</p>
<ul>
<li><p>otherWindow.postMessage(message, targetOrigin);</p>
<ul>
<li>otherWindow:指目标窗口，也就是给哪个window发消息，是 window.frames 属性的成员或者由 window.open 方法创建的窗口</li>
<li>message:   是要发送的消息，类型为 String、Object (IE8、9 不支持)</li>
<li>targetOrigin:   是限定消息接收范围，不限制请使用 ‘*</li>
</ul>
</li>
</ul>
<p>B页面通过message事件监听并接受消息:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;  </div><div class="line">  <span class="keyword">var</span> data = event.data;<span class="comment">//消息  </span></div><div class="line">  <span class="keyword">var</span> origin = event.origin;<span class="comment">//消息来源地址  </span></div><div class="line">  <span class="keyword">var</span> source = event.source;<span class="comment">//源Window对象  </span></div><div class="line">  <span class="keyword">if</span>(origin==<span class="string">"http://www.baidu.com"</span>)&#123;  </div><div class="line"><span class="built_in">console</span>.log(data);<span class="comment">//hello world!  </span></div><div class="line">  &#125;  </div><div class="line">&#125;;  </div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.addEventListener != <span class="string">'undefined'</span>) &#123;  </div><div class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, onmessage, <span class="literal">false</span>);  </div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.attachEvent != <span class="string">'undefined'</span>) &#123;  </div><div class="line">  <span class="comment">//for ie  </span></div><div class="line">  <span class="built_in">window</span>.attachEvent(<span class="string">'onmessage'</span>, onmessage);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同理，也可以B页面发送消息，然后A页面监听并接受消息。</p>
<h3 id="5-通过jsonp跨域"><a href="#5-通过jsonp跨域" class="headerlink" title="5.通过jsonp跨域"></a>5.通过jsonp跨域</h3><blockquote>
<p>刚才说的这几种都是双向通信的，即两个iframe，页面与iframe或是页面与页面之间的，下面说几种单项跨域的（一般用来获取数据），因为通过script标签引入的js是不受同源策略的限制的。所以我们可以通过script标签引入一个js或者是一个其他后缀形式（如php，jsp等）的文件，此文件返回一个js函数的调用。</p>
</blockquote>
<p>比如，有个a.html页面，它里面的代码需要利用ajax获取一个不同域上的json数据，假设这个json数据地址是<a href="http://damonare.cn/data.php,那么a.html中的代码就可以这样：" target="_blank" rel="external">http://damonare.cn/data.php,那么a.html中的代码就可以这样：</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line">    function dosomething(jsondata)&#123;</div><div class="line">        //处理获得的json数据</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;script src="http://example.com/data.php?callback=dosomething"&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>我们看到获取数据的地址后面还有一个callback参数，按惯例是用这个参数名，但是你用其他的也一样。当然如果获取数据的jsonp地址页面不是你自己能控制的，就得按照提供数据的那一方的规定格式来操作了。</p>
<p>因为是当做一个js文件来引入的，所以<a href="http://damonare.cn/data.php返回的必须是一个能执行的js文件，所以这个页面的php代码可能是这样的(一定要和后端约定好哦" target="_blank" rel="external">http://damonare.cn/data.php返回的必须是一个能执行的js文件，所以这个页面的php代码可能是这样的(一定要和后端约定好哦</a>):</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$callback = $_GET[<span class="string">'callback'</span>];<span class="comment">//得到回调函数名</span></div><div class="line">$data = <span class="keyword">array</span>(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>);<span class="comment">//要返回的数据</span></div><div class="line"><span class="keyword">echo</span> $callback.<span class="string">'('</span>.json_encode($data).<span class="string">')'</span>;<span class="comment">//输出</span></div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>最终，输出结果为：dosomething([‘a’,’b’,’c’]);</p>
<p>如果你的页面使用jquery，那么通过它封装的方法就能很方便的来进行jsonp操作了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    $.getJSON(<span class="string">'http://example.com/data.php?callback=?,function(jsondata)'</span>)&#123;</div><div class="line">        <span class="comment">//处理获得的json数据</span></div><div class="line">    &#125;);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>jquery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。</p>
<ul>
<li>JSONP的优缺点<ul>
<li>JSONP的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。</li>
<li>JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</li>
</ul>
</li>
</ul>
<h3 id="6-通过CORS跨域"><a href="#6-通过CORS跨域" class="headerlink" title="6. 通过CORS跨域"></a>6. 通过CORS跨域</h3><blockquote>
<p>CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
</blockquote>
<p><strong>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</strong></p>
<p>平时的ajax请求可能是这样的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    xhr.open(<span class="string">"POST"</span>, <span class="string">"/damonare"</span>,<span class="literal">true</span>);</div><div class="line">    xhr.send();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>以上damonare部分是相对路径，如果我们要使用CORS，相关Ajax代码可能如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    xhr.open(<span class="string">"￼GET"</span>, <span class="string">"http://segmentfault.com/u/trigkit4/"</span>,<span class="literal">true</span>);</div><div class="line">    xhr.send();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>代码与之前的区别就在于相对路径换成了其他域的绝对路径，也就是你要跨域访问的接口地址。</p>
<p>服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。关于CORS更多了解可以看下阮一峰老师的这一篇文章：<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">跨域资源共享 CORS 详解</a></p>
<ul>
<li><p>CORS和JSONP对比</p>
<ul>
<li><p>JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。</p>
</li>
<li><p>使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。</p>
</li>
<li><p>JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS）。</p>
</li>
</ul>
</li>
</ul>
<p>CORS与JSONP相比，无疑更为先进、方便和可靠。</p>
<h3 id="7-通过window-name跨域"><a href="#7-通过window-name跨域" class="headerlink" title="7. 通过window.name跨域"></a>7. 通过window.name跨域</h3><blockquote>
<p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</p>
</blockquote>
<p>比如：我们在任意一个页面输入</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.name = <span class="string">"My window's name"</span>;</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">window</span>.location.href = <span class="string">"http://damonare.cn/"</span>;</div><div class="line">&#125;,<span class="number">1000</span>)</div></pre></td></tr></table></figure>
<p>进入damonare.cn页面后我们再检测再检测 window.name :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.name; <span class="comment">// My window's name</span></div></pre></td></tr></table></figure>
<p>可以看到，如果在一个标签里面跳转网页的话，我们的 window.name 是不会改变的。<br>基于这个思想，我们可以在某个页面设置好 window.name 的值，然后跳转到另外一个页面。在这个页面中就可以获取到我们刚刚设置的 window.name 了。</p>
<blockquote>
<p>由于安全原因，浏览器始终会保持 window.name 是string 类型。</p>
</blockquote>
<p>同样这个方法也可以应用到和iframe的交互来：<br>比如：我的页面(<a href="http://damonare.cn/index.html)中内嵌了一个iframe：" target="_blank" rel="external">http://damonare.cn/index.html)中内嵌了一个iframe：</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;iframe id=<span class="string">"iframe"</span> src=<span class="string">"http://www.google.com/iframe.html"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>在 iframe.html 中设置好了 window.name 为我们要传递的字符串。<br>我们在 index.html 中写了下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</div><div class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</div><div class="line">iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    data = iframe.contentWindow.name;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Boom!报错！肯定的，因为两个页面不同源嘛，想要解决这个问题可以这样干：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</div><div class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</div><div class="line">iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        data = iframe.contentWindow.name;</div><div class="line">    &#125;</div><div class="line">    iframe.src = <span class="string">'about:blank'</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>或者将里面的 about:blank 替换成某个同源页面（about:blank，javascript: 和 data: 中的内容，继承了载入他们的页面的源。）</strong></p>
<p>这种方法与 document.domain 方法相比，放宽了域名后缀要相同的限制，可以从任意页面获取 string 类型的数据。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote>
<p>其它诸如中间件跨域，服务器代理跨域，Flash URLLoader跨域，动态创建script标签（简化版本的jsonp）不作讨论。</p>
</blockquote>
<p><strong>参考文章：</strong></p>
<ul>
<li><p><a href="https://segmentfault.com/a/1190000000718840#articleHeader1" target="_blank" rel="external">详解js跨域问题</a></p>
</li>
<li><p><a href="http://blog.csdn.net/joyhen/article/details/21631833" target="_blank" rel="external">前端解决跨域问题的8种方案（最新最全）</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 相信每一个前端er对于跨域这两个字都不会陌生，在实际项目中应用也是比较多的。但跨域方法的多种多样实在让人目不暇接。老规矩，碰到这种情况，就只能自己总结一篇博客，作为记录。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://damonare.github.io/2016/10/30/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E6%95%B4%E7%90%86/#more&quot;&gt;前端跨域总结&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人生在勤，不索何获。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
      <category term="前端" scheme="http://damonare.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="跨域" scheme="http://damonare.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSS居中小谈</title>
    <link href="http://damonare.github.io/2016/11/30/CSS%E5%B1%85%E4%B8%AD%E5%B0%8F%E8%B0%88/"/>
    <id>http://damonare.github.io/2016/11/30/CSS居中小谈/</id>
    <published>2016-11-30T09:59:46.000Z</published>
    <updated>2016-11-30T09:59:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong>  CSS居中一直是一个比较敏感的话题，为了以后开发的方便，楼主觉得确实需要总结一下了，总的来说，居中问题分为垂直居中和水平居中，实际上水平居中是很简单的，但垂直居中的方式和方法就千奇百怪了。</p>
<ul>
<li><p>原文地址：<a href="http://damonare.github.io/2016/09/06/CSS%E5%B1%85%E4%B8%AD%E5%B0%8F%E8%B0%88/#more">CSS居中小谈</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>人生用物，各有天限；夏涝太多，必有秋旱。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="内联元素居中方案"><a href="#内联元素居中方案" class="headerlink" title="内联元素居中方案"></a>内联元素居中方案</h3><p><strong>水平居中设置：</strong></p>
<ol>
<li><p>行内元素 设置 text-align:center；</p>
</li>
<li><p>Flex布局 设置display:flex;justify-content:center;(灵活运用)</p>
</li>
</ol>
<p><strong>垂直居中设置：</strong></p>
<ol>
<li>父元素高度确定的单行文本（内联元素） 设置 height = line-height；</li>
<li><p>父元素高度确定的多行文本（内联元素） a:插入 table （插入方法和水平居中一样），然后设置 vertical-align:middle； b:先设置 display:table-cell 再设置 vertical-align:middle；</p>
<h2 id="块级元素居中方案"><a href="#块级元素居中方案" class="headerlink" title="块级元素居中方案"></a>块级元素居中方案</h2><p><strong>水平居中设置：</strong></p>
</li>
<li><p>定宽块状元素 设置 左右 margin 值为 auto；</p>
</li>
<li><p>不定宽块状元素 a:在元素外加入 table 标签（完整的，包括 table、tbody、tr、td），该元素写在 td 内，然后设置 margin 的值为 auto； b:给该元素设置 display:inine 方法； c:父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left:50%；</p>
</li>
</ol>
<p><strong>垂直居中设置：</strong></p>
<ul>
<li><p>1.使用position:absolute（fixed）,设置left、top、margin-left、margin-top的属性;</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123;</div><div class="line"><span class="attribute">position</span>:absolute;<span class="comment">/*或fixed*/</span></div><div class="line"><span class="attribute">top</span>:<span class="number">50%</span>;</div><div class="line"><span class="attribute">left</span>:<span class="number">50%</span>;</div><div class="line"><span class="attribute">margin-top</span>:-<span class="number">100px</span>;</div><div class="line"><span class="attribute">margin-left</span>:-<span class="number">200px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>2.利用position:fixed（absolute）属性，margin:auto这个必须不要忘记了;</li>
</ul>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.box&#123;</div><div class="line">    position: absolute;或fixed</div><div class="line">    top:0;</div><div class="line">    right:0;</div><div class="line">    bottom:0;</div><div class="line">    left:0;</div><div class="line">    margin: auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>3.利用display:table-cell属性使内容垂直居中,这个方法在多行文字居中的时候用的比较多;</li>
</ul>
<p>HTML代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>多行文字，此处居中设置<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>CSS代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123;</div><div class="line">    <span class="attribute">display</span>:table-cell;</div><div class="line">    <span class="attribute">vertical-align</span>:middle;</div><div class="line">    <span class="attribute">text-align</span>:center;</div><div class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</div><div class="line">    <span class="attribute">height</span>:<span class="number">120px</span>;</div><div class="line">    <span class="attribute">background</span>:purple;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.box</span> <span class="selector-tag">span</span>&#123;</div><div class="line">    <span class="attribute">display</span>: inline-block;</div><div class="line">    <span class="attribute">vertical-align</span>: middle;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>4.使用css3的新属性transform:translate(x,y)属性;</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</div><div class="line">    <span class="attribute">left</span>:<span class="number">50%</span>;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%,-50%);</div><div class="line">    <span class="attribute">-webkit-transform</span>:<span class="built_in">translate</span>(-50%,-50%);</div><div class="line">    <span class="attribute">-moz-transform</span>:<span class="built_in">translate</span>(-50%,-50%);</div><div class="line">    <span class="attribute">-ms-transform</span>:<span class="built_in">translate</span>(-50%,-50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>5.最高大上的一种，使用before，after伪元素;</li>
</ul>
<p>HTML代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'box'</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'content'</span>&gt;</span></div><div class="line">        垂直居中</div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>CSS代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123;</div><div class="line">    <span class="attribute">position</span>:fixed;</div><div class="line">    <span class="attribute">display</span>:block;</div><div class="line">    <span class="attribute">background</span>:<span class="built_in">rgba</span>(0,0,0,.5);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:before</span>&#123;</div><div class="line">    <span class="attribute">content</span>:<span class="string">''</span>;</div><div class="line">    <span class="attribute">display</span>:inline-block;</div><div class="line">    <span class="attribute">vertical-align</span>:middle;</div><div class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:after</span>&#123;</div><div class="line">    <span class="attribute">content</span>:<span class="string">''</span>;</div><div class="line">    <span class="attribute">display</span>:inline-block;</div><div class="line">    <span class="attribute">vertical-align</span>:middle;</div><div class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.box</span> <span class="selector-class">.content</span>&#123;</div><div class="line">    <span class="attribute">width</span>:<span class="number">60px</span>;</div><div class="line">    <span class="attribute">height</span>:<span class="number">60px</span>;</div><div class="line">    <span class="attribute">line-height</span>:<span class="number">60px</span>;</div><div class="line">    <span class="attribute">color</span>:red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>6.Flex布局;</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">.box&#123;</div><div class="line">    display: -webkit-box;</div><div class="line">    display: -webkit-flex;</div><div class="line">    display: -moz-box;</div><div class="line">    display: -moz-flex;</div><div class="line">    display: -ms-flexbox;</div><div class="line">    display: flex;</div><div class="line">    水平居中</div><div class="line">    -webkit-box-align: center;</div><div class="line">    -moz-box-align: center;</div><div class="line">    -ms-flex-pack:center;</div><div class="line">    -webkit-justify-content: center;</div><div class="line">    -moz-justify-content: center;</div><div class="line">    justify-content: center;</div><div class="line">     垂直居中</div><div class="line">    -webkit-box-pack: center;</div><div class="line">    -moz-box-pack: center;</div><div class="line">    -ms-flex-align:center;</div><div class="line">    -webkit-align-items: center;</div><div class="line">    -moz-align-items: center;</div><div class="line">    align-items: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote>
<p>博主暂时掌握了这些居中方法，读者如果还有好方法或是觉得那个地方不对，欢迎评论，不吝感谢。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt;  CSS居中一直是一个比较敏感的话题，为了以后开发的方便，楼主觉得确实需要总结一下了，总的来说，居中问题分为垂直居中和水平居中，实际上水平居中是很简单的，但垂直居中的方式和方法就千奇百怪了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://damonare.github.io/2016/09/06/CSS%E5%B1%85%E4%B8%AD%E5%B0%8F%E8%B0%88/#more&quot;&gt;CSS居中小谈&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人生用物，各有天限；夏涝太多，必有秋旱。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="CSS" scheme="http://damonare.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Javascript作用域总结</title>
    <link href="http://damonare.github.io/2016/11/26/Javascript%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%80%BB%E7%BB%93/"/>
    <id>http://damonare.github.io/2016/11/26/Javascript作用域总结/</id>
    <published>2016-11-26T10:14:04.000Z</published>
    <updated>2016-11-26T10:14:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 作用域永远都是任何一门编程语言中的重中之重，因为它控制着变量与参数的可见性与生命周期。说到这里我们需要理解两个概念：块级作用域与函数作用域。</p>
<ul>
<li><p>原文地址：<a href="http://damonare.github.io/2016/09/06/javascript%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%80%BB%E7%BB%93/#more">Javascript作用域总结</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>人生世上风波险，一日风波十二时。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p><strong>这个应该好理解，函数作用域就是说定义在函数中的参数和变量在函数外部是不可见的。</strong></p>
<p><strong>大多数类C语言都拥有块级作用域，JS却没有。请看下文demo:</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//C语言</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> i=<span class="number">2</span>;</div><div class="line">i--;</div><div class="line"><span class="keyword">if</span>(i)</div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> j=<span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d/n"</span>,j);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>运行这段代码，会出现“use an undefined variable:j”的错误。可以看到，C语言拥有块级作用域，因为j是在if的语句块中定义的，因此，它在块外是无法访问的。</strong></p>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><hr>
<blockquote>
<p>任何一对花括号中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。</p>
</blockquote>
<p>正如我们举的C语言的例子，大多数类C语言都是有块级作用域的，那么在JavaScript又有什么不同呢？</p>
<p><strong>我们一起看看这个JavaScript的demo:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">functin test()&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</div><div class="line">&#125;</div><div class="line">alert(i);</div><div class="line">&#125;</div><div class="line">test();</div></pre></td></tr></table></figure>
<p><strong>运行这段代码，弹出”3”，可见，在块外，块中定义的变量i仍然是可以访问的。也就是说，JS并不支持块级作用域，它只支持函数作用域，而且在一个函数中的任何位置定义的变量在该函数中的任何地方都是可见的。</strong></p>
<p><strong>那么我们该如何使JS拥有块级作用域呢？是否还记得，在一个函数中定义的变量，当这个函数调用完后，变量会被销毁，我们是否可以用这个特性来模拟出JS的块级作用域呢？看下面这个demo：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</div><div class="line">&#125;</div><div class="line">&#125;)();</div><div class="line">alert(i);</div><div class="line">&#125;</div><div class="line">test();</div></pre></td></tr></table></figure>
<p><strong>这时候再次运行，会弹出”i”未定义的错误，哈哈，实现了吧~~~这里，我们把for语句块放到了一个闭包之中，然后调用这个函数，当函数调用完毕，变量i自动销毁，因此，我们在块外便无法访问了。</strong></p>
<p><strong>JS的闭包特性is the most important feature((<em>^__^</em>) 大家懂的)。在JS中，为了防止命名冲突，我们应该尽量避免使用全局变量和全局函数。那么，该如何避免呢？不错，正如上文demo所示，我们可以把要定义的所有内容放入到一个</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line"><span class="comment">//内容</span></div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p><strong>之中，这时候，我们是不是相当于给它们的外层添加了一个函数作用域呢？该作用域之外的程序是无法访问它们的。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 作用域永远都是任何一门编程语言中的重中之重，因为它控制着变量与参数的可见性与生命周期。说到这里我们需要理解两个概念：块级作用域与函数作用域。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://damonare.github.io/2016/09/06/javascript%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%80%BB%E7%BB%93/#more&quot;&gt;Javascript作用域总结&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人生世上风波险，一日风波十二时。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript本地存储小结</title>
    <link href="http://damonare.github.io/2016/11/26/Javascript%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%B0%8F%E7%BB%93/"/>
    <id>http://damonare.github.io/2016/11/26/Javascript本地存储小结/</id>
    <published>2016-11-26T10:06:10.000Z</published>
    <updated>2016-11-26T10:06:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括:</strong> 详细讲述<code>Cookie</code>,<code>LocalStorge</code>,<code>SesstionStorge</code>的区别和用法。</p>
<ul>
<li><p>原文博客地址：<a href="http://damonare.github.io/2016/11/16/Javascript%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%B0%8F%E7%BB%93/#more">Javascript本地存储小结</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>人生如画，岁月如歌。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-各种存储方案的简单对比"><a href="#1-各种存储方案的简单对比" class="headerlink" title="1. 各种存储方案的简单对比"></a>1. 各种存储方案的简单对比</h3><ul>
<li>Cookies：浏览器均支持，容量为4KB</li>
<li>UserData：仅IE支持，容量为64KB</li>
<li>Flash：100KB，非HTML原生，需要插件支持</li>
<li>Google Gears SQLite ：需要插件支持，容量无限制</li>
<li>LocalStorage：HTML5，容量为5M</li>
<li>SesstionStorage：HTML5，容量为5M</li>
<li>globalStorage：Firefox独有的，Firefox13开始就不再支持这个方法<blockquote>
<p>UserData仅IE支持， Google Gears SQLite需要插件，Flash已经伴随着HTML5的出现渐渐退出了历史舞台，因此今天我们的主角只有他们三个：<code>Cookie</code>,<code>LocalStorge</code>,<code>SesstionStorge</code>;</p>
</blockquote>
</li>
</ul>
<h3 id="2-Cookie"><a href="#2-Cookie" class="headerlink" title="2. Cookie"></a>2. Cookie</h3><p>作为一个前端和Cookie打交道的次数肯定不会少了，Cookie算是比较古老的技术了<br>1993 年，网景公司雇员 Lou Montulli 为了让用户在访问某网站时，进一步提高访问速度，同时也为了进一步实现个人化网络，发明了今天广泛使用的 Cookie。</p>
<h4 id="2-1-Cookie的特点"><a href="#2-1-Cookie的特点" class="headerlink" title="2.1 Cookie的特点"></a>2.1 Cookie的特点</h4><p><strong>我们先来看下Cookie的特点：</strong></p>
<ul>
<li><p>1）cookie的大小受限制，cookie大小被限制在4KB，不能接受像大文件或邮件那样的大数据。</p>
</li>
<li><p>2）只要有请求涉及cookie，cookie就要在服务器和浏览器之间来回传送（这解释为什么本地文件不能测试cookie）。而且cookie数据始终在同源的http请求中携带（即使不需要），这也是Cookie不能太大的重要原因。正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。</p>
</li>
<li><p>3）用户每请求一次服务器数据，cookie则会随着这些请求发送到服务器，服务器脚本语言如PHP等能够处理cookie发送的数据，可以说是非常方便的。当然前端也是可以生成Cookie的，用js对cookie的操作相当的繁琐，浏览器只提供document.cookie这样一个对象，对cookie的赋值，获取都比较麻烦。而在PHP中，我们可以通过setcookie()来设置cookie，通过$_COOKIE这个超全局数组来获取cookie。</p>
</li>
</ul>
<blockquote>
<p>cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。</p>
</blockquote>
<h4 id="2-2-Session"><a href="#2-2-Session" class="headerlink" title="2.2 Session"></a>2.2 Session</h4><p>说到Cookie就不能不说Session。</p>
<blockquote>
<p>Session机制。session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。比如：<code>http://damonare.cn?sessionid=123456</code>还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。比如：</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">"testform"</span> <span class="attr">action</span>=<span class="string">"/xxx"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"sessionid"</span> <span class="attr">value</span>=<span class="string">"123456"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
<p>实际上这种技术可以简单的用对action应用URL重写来代替。</p>
<h4 id="2-3-Cookie和Session简单对比"><a href="#2-3-Cookie和Session简单对比" class="headerlink" title="2.3 Cookie和Session简单对比"></a>2.3 Cookie和Session简单对比</h4><p><strong>Cookie和Session 的区别：</strong></p>
<ul>
<li><p>1）cookie数据存放在客户的浏览器上，session数据放在服务器上。</p>
</li>
<li><p>2）cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。</p>
</li>
<li><p>3）session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。</p>
</li>
<li>4）单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li>
<li>5）所以建议：<ul>
<li>将登陆信息等重要信息存放为SESSION</li>
<li>其他信息如果需要保留，可以放在cookie中</li>
</ul>
</li>
</ul>
<h4 id="2-4-document-cookie的属性"><a href="#2-4-document-cookie的属性" class="headerlink" title="2.4 document.cookie的属性"></a>2.4 document.cookie的属性</h4><p><strong>expires属性</strong></p>
<blockquote>
<p>指定了coolie的生存期，默认情况下coolie是暂时存在的，他们存储的值只在浏览器会话期间存在，当用户推出浏览器后这些值也会丢失，如果想让cookie存在一段时间，就要为expires属性设置为未来的一个过期日期。现在已经被max-age属性所取代，max-age用秒来设置cookie的生存期。</p>
</blockquote>
<p><strong>path属性</strong></p>
<blockquote>
<p>它指定与cookie关联在一起的网页。在默认的情况下cookie会与创建它的网页，该网页处于同一目录下的网页以及与这个网页所在目录下的子目录下的网页关联。</p>
</blockquote>
<p><strong>domain属性</strong></p>
<blockquote>
<p>domain属性可以使多个web服务器共享cookie。domain属性的默认值是创建cookie的网页所在服务器的主机名。不能将一个cookie的域设置成服务器所在的域之外的域。例如让位于order.damonare.cn的服务器能够读取catalog.damonare.cn设置的cookie值。如果catalog.damonare.cn的页面创建的cookie把自己的path属性设置为“/”，把domain属性设置成“.damonare.cn”，那么所有位于catalog.damonare.cn的网页和所有位于orlders.damonare.cn的网页，以及位于damonare.cn域的其他服务器上的网页都可以访问这个cookie。</p>
</blockquote>
<p><strong>secure属性</strong></p>
<blockquote>
<p>它是一个布尔值，指定在网络上如何传输cookie，默认是不安全的，通过一个普通的http连接传输</p>
</blockquote>
<h4 id="2-5-cookie实战"><a href="#2-5-cookie实战" class="headerlink" title="2.5 cookie实战"></a>2.5 cookie实战</h4><blockquote>
<p>这里我们使用javascript来写一段cookie,借用w3cschool的demo:</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">c_name</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.cookie.length&gt;<span class="number">0</span>)&#123;</div><div class="line">        c_start=<span class="built_in">document</span>.cookie.indexOf(c_name + <span class="string">"="</span>)</div><div class="line">        <span class="keyword">if</span> (c_start!=<span class="number">-1</span>)&#123;</div><div class="line">            c_start=c_start + c_name.length+<span class="number">1</span></div><div class="line">            c_end=<span class="built_in">document</span>.cookie.indexOf(<span class="string">";"</span>,c_start)</div><div class="line">            <span class="keyword">if</span> (c_end==<span class="number">-1</span>) c_end=<span class="built_in">document</span>.cookie.length</div><div class="line">            <span class="keyword">return</span> <span class="built_in">unescape</span>(<span class="built_in">document</span>.cookie.substring(c_start,c_end))</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">c_name,value,expiredays</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> exdate=<span class="keyword">new</span> <span class="built_in">Date</span>()</div><div class="line">    exdate.setDate(exdate.getDate()+expiredays)</div><div class="line">    <span class="built_in">document</span>.cookie=c_name+ <span class="string">"="</span> +<span class="built_in">escape</span>(value)+</div><div class="line">            ((expiredays==<span class="literal">null</span>) ? <span class="string">""</span> : <span class="string">"; expires="</span>+exdate.toUTCString())</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkCookie</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    username=getCookie(<span class="string">'username'</span>)</div><div class="line">    <span class="keyword">if</span>(username!=<span class="literal">null</span> &amp;&amp; username!=<span class="string">""</span>)&#123;alert(<span class="string">'Welcome again '</span>+username+<span class="string">'!'</span>)&#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        username=prompt(<span class="string">'Please enter your name:'</span>,<span class="string">""</span>)</div><div class="line">        <span class="keyword">if</span> (username!=<span class="literal">null</span> &amp;&amp; username!=<span class="string">""</span>)&#123;</div><div class="line">            setCookie(<span class="string">'username'</span>,username,<span class="number">355</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意这里对Cookie的生存期进行了定义，也就是355天</p>
</blockquote>
<h3 id="3-localStorage"><a href="#3-localStorage" class="headerlink" title="3. localStorage"></a>3. localStorage</h3><blockquote>
<p>这是一种持久化的存储方式，也就是说如果不手动清除，数据就永远不会过期。<br>它也是采用Key - Value的方式存储数据，底层数据接口是sqlite，按域名将数据分别保存到对应数据库文件里。它能保存更大的数据（IE8上是10MB，Chrome是5MB），同时保存的数据不会再发送给服务器，避免带宽浪费。</p>
</blockquote>
<h4 id="3-1-localStorage的属性方法"><a href="#3-1-localStorage的属性方法" class="headerlink" title="3.1 localStorage的属性方法"></a>3.1 localStorage的属性方法</h4><p>下表是localStorge的一些属性和方法</p>
<table>
<thead>
<tr>
<th>属性方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>localStorage.length</td>
<td>获得storage中的个数</td>
</tr>
<tr>
<td>localStorage.key(n)</td>
<td>获得storage中第n个元素对的键值（第一个元素是0）</td>
</tr>
<tr>
<td>localStorage.getItem(key)</td>
<td>获取键值key对应的值</td>
</tr>
<tr>
<td>localStorage.key</td>
<td>获取键值key对应的值</td>
</tr>
<tr>
<td>localStorage.setItem(key, value)</td>
<td>添加数据，键值为key，值为value</td>
</tr>
<tr>
<td>localStorage.removeItem(key)</td>
<td>移除键值为key的数据</td>
</tr>
<tr>
<td>localStorage.clear()</td>
<td>清除所有数据</td>
</tr>
</tbody>
</table>
<h4 id="3-2-localStorage的缺点"><a href="#3-2-localStorage的缺点" class="headerlink" title="3.2 localStorage的缺点"></a>3.2 localStorage的缺点</h4><ul>
<li>① localStorage大小限制在500万字符左右，各个浏览器不一致</li>
<li>② localStorage在隐私模式下不可读取</li>
<li>③ localStorage本质是在读写文件，数据多的话会比较卡（firefox会一次性将数据导入内存，想想就觉得吓人啊）</li>
<li>④ localStorage不能被爬虫爬取，不要用它完全取代URL传参</li>
</ul>
<h3 id="4-sessionStorage"><a href="#4-sessionStorage" class="headerlink" title="4. sessionStorage"></a>4. sessionStorage</h3><blockquote>
<p>和服务器端使用的session类似，是一种会话级别的缓存，关闭浏览器会数据会被清除。不过有点特别的是它的作用域是窗口级别的，也就是说不同窗口间的sessionStorage数据不能共享的。使用方法（和localStorage完全相同）：</p>
</blockquote>
<table>
<thead>
<tr>
<th>属性方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sessionStorage.length</td>
<td>获得storage中的个数</td>
</tr>
<tr>
<td>sessionStorage.key(n)</td>
<td>获得storage中第n个元素对的键值（第一个元素是0）</td>
</tr>
<tr>
<td>sessionStorage.getItem(key)</td>
<td>获取键值key对应的值</td>
</tr>
<tr>
<td>sessionStorage.key</td>
<td>获取键值key对应的值</td>
</tr>
<tr>
<td>sessionStorage.setItem(key, value)</td>
<td>添加数据，键值为key，值为value</td>
</tr>
<tr>
<td>sessionStorage.removeItem(key)</td>
<td>移除键值为key的数据</td>
</tr>
<tr>
<td>sessionStorage.clear()</td>
<td>清除所有数据</td>
</tr>
</tbody>
</table>
<h3 id="5-sessionStorage和localStorage的区别"><a href="#5-sessionStorage和localStorage的区别" class="headerlink" title="5. sessionStorage和localStorage的区别"></a>5. sessionStorage和localStorage的区别</h3><ul>
<li><p>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。当用户关闭浏览器窗口后，数据立马会被删除。</p>
</li>
<li><p>localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。第二天、第二周或下一年之后，数据依然可用。</p>
</li>
</ul>
<h4 id="5-1-测试"><a href="#5-1-测试" class="headerlink" title="5.1 测试"></a>5.1 测试</h4><p><strong>sessionStorage:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (sessionStorage.pagecount)&#123;</div><div class="line">    sessionStorage.pagecount=<span class="built_in">Number</span>(sessionStorage.pagecount) +<span class="number">1</span>;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">      sessionStorage.pagecount=<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Visits "</span>+ sessionStorage.pagecount + <span class="string">" time(s)."</span>);</div></pre></td></tr></table></figure>
<p><strong>测试过程：我们在控制台输入上述代码查看打印结果</strong></p>
<p><strong>控制台首次输入代码：</strong></p>
<p><img src="http://img.blog.csdn.net/20161116225014652" alt="sessionStorage测试结果"></p>
<p><strong>关闭窗口，控制台再次输入代码：</strong></p>
<p><img src="http://img.blog.csdn.net/20161116225014652" alt="sessionStorage测试结果"></p>
<p><strong>所谓的关闭窗口即销毁，就是这样，关闭窗口重新打开输入代码输出结果还是上面图片的样子，也就是说关闭窗口后sessionStorage.pagecount即被销毁，除非重心创建。或者从历史记录进入才会相关数据才会存在。好的，我们再来看下localStorge表现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (localStorage.pagecount)&#123;</div><div class="line">    localStorage.pagecount=<span class="built_in">Number</span>(localStorage.pagecount) +<span class="number">1</span>;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    localStorage.pagecount=<span class="number">1</span>;</div><div class="line"> &#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Visits "</span>+ localStorage.pagecount + <span class="string">" time(s)."</span>);</div></pre></td></tr></table></figure>
<p><strong>控制台首次输入代码：</strong></p>
<p><img src="http://img.blog.csdn.net/20161116225028996" alt="localStorage测试结果1"></p>
<p><strong>关闭窗口，控制台再次输入代码：</strong></p>
<p><img src="http://img.blog.csdn.net/20161116225040575" alt="localStorage测试结果2"></p>
<h3 id="6-web-Storage和cookie的区别"><a href="#6-web-Storage和cookie的区别" class="headerlink" title="6. web Storage和cookie的区别"></a>6. web Storage和cookie的区别</h3><p>Web Storage(localStorage和sessionStorage)的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。</p>
<p>除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。</p>
<p>但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote>
<p>博主尽可能思路清晰的理了一遍cookie，session，localStorage，sessionStorage之间的区别和联系，希望可以帮到大家。<br>参考文章：</p>
</blockquote>
<ul>
<li><a href="http://www.cnblogs.com/shiyangxt/archive/2008/10/07/1305506.html" target="_blank" rel="external">cookie 和session 的区别详解</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括:&lt;/strong&gt; 详细讲述&lt;code&gt;Cookie&lt;/code&gt;,&lt;code&gt;LocalStorge&lt;/code&gt;,&lt;code&gt;SesstionStorge&lt;/code&gt;的区别和用法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文博客地址：&lt;a href=&quot;http://damonare.github.io/2016/11/16/Javascript%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%B0%8F%E7%BB%93/#more&quot;&gt;Javascript本地存储小结&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人生如画，岁月如歌。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
      <category term="HTML5" scheme="http://damonare.github.io/tags/HTML5/"/>
    
      <category term="Cookie" scheme="http://damonare.github.io/tags/Cookie/"/>
    
      <category term="缓存" scheme="http://damonare.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="localStorage" scheme="http://damonare.github.io/tags/localStorage/"/>
    
      <category term="sessionStorage" scheme="http://damonare.github.io/tags/sessionStorage/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript ES6 核心功能一览</title>
    <link href="http://damonare.github.io/2016/11/26/JavaScript%20ES6%20%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%80%E8%A7%88/"/>
    <id>http://damonare.github.io/2016/11/26/JavaScript ES6 核心功能一览/</id>
    <published>2016-11-26T10:05:00.000Z</published>
    <updated>2016-11-26T10:05:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>本文属于转载文章</p>
</blockquote>
<ul>
<li>原文地址：<a href="http://adrianmejia.com/blog/2016/10/19/Overview-of-JavaScript-ES6-features-a-k-a-ECMAScript-6-and-ES2015/" target="_blank" rel="external">Overview of JavaScript ES6 features (a.k.a ECMAScript 6 and ES2015+)</a></li>
<li>原文作者：<a href="http://adrianmejia.com/#about" target="_blank" rel="external">Adrian Mejia</a></li>
<li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="external">掘金翻译计划</a></li>
<li>译者：<a href="https://github.com/L9m" target="_blank" rel="external">L9m</a></li>
<li>校对者：<a href="https://github.com/Tina92" target="_blank" rel="external">Tina92</a>，<a href="https://github.com/luoyaqifei" target="_blank" rel="external">luoyaqifei</a>，<a href="https://github.com/theJian" target="_blank" rel="external">theJian</a></li>
</ul>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="JavaScript-ES6-核心功能一览（ES6-亦作-ECMAScript-6-或-ES2015-）"><a href="#JavaScript-ES6-核心功能一览（ES6-亦作-ECMAScript-6-或-ES2015-）" class="headerlink" title="JavaScript ES6 核心功能一览（ES6 亦作 ECMAScript 6 或 ES2015+）"></a>JavaScript ES6 核心功能一览（ES6 亦作 ECMAScript 6 或 ES2015+）</h3><p>JavaScript 在过去几年里发生了很大的变化。这里介绍 12 个你马上就能用的新功能。</p>
<h3 id="JavaScript-历史"><a href="#JavaScript-历史" class="headerlink" title="JavaScript 历史"></a>JavaScript 历史</h3><p>新的语言规范被称作 ECMAScript 6。也称为 ES6 或 ES2015+ 。</p>
<p>自从 1995 年 JavaScript 诞生以来，它一直在缓慢地发展。每隔几年就会增加一些新内容。1997 年，ECMAScript 成为 JavaScript 语言实现的规范。它已经有了好几个版本，比如 ES3 , ES5 , ES6 等等。</p>
<p><img src="http://adrianmejia.com/images/history-javascript-evolution-es6.png" alt="" title="JavaScript 发展史"></p>
<p>如你所见，ES3，ES5 和 ES6 之间分别存在着 10 年和 6 年的间隔。像 ES6 那样一次进行大幅修改的模式被逐年渐进式的新模式所替代。</p>
<h3 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h3><p>所有现代浏览器和环境都已支持 ES6。</p>
<p><img src="http://adrianmejia.com/images/es6-javascript-support.png" alt="" title="ES6 Support"></p>
<p>来源: <a href="https://kangax.github.io/compat-table/es6/" target="_blank" rel="external">https://kangax.github.io/compat-table/es6/</a></p>
<p>Chrome，MS Edge，Firefox，Safari，Node 和许多其他的环境都已内置支持大多数的 JavaScript ES6 功能。所以，在本教程中你学到的每个知识，你都可以马上开始应用。</p>
<p>让我们开始学习 ECMAScript 6 吧！</p>
<h3 id="核心-ES6-功能"><a href="#核心-ES6-功能" class="headerlink" title="核心 ES6 功能"></a>核心 ES6 功能</h3><p>你可以在浏览器的控制台中测试所有下面的代码片段。</p>
<p><img src="http://adrianmejia.com/images/javascript-es6-classes-on-browser-console.png" alt="" title="Testing Javascript ES6 classes on browser console"></p>
<p>不要笃信我的话，而是要亲自去测试每一个 ES5 和 ES6 示例。让我们开始动手吧 💪</p>
<h4 id="变量的块级作用域"><a href="#变量的块级作用域" class="headerlink" title="变量的块级作用域"></a>变量的块级作用域</h4><p>使用 ES6，声明变量我们可以用 <code>var</code> ，也可以用 <code>let</code> 或 <code>const</code>。</p>
<p><code>var</code> 有什么不足？</p>
<p>使用 <code>var</code> 的问题是变量会漏入其他代码块中，诸如 <code>for</code> 循环或 <code>if</code> 代码块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">var x = &apos;outer&apos;;</div><div class="line">function test(inner) &#123;</div><div class="line">  if (inner) &#123;</div><div class="line">    var x = &apos;inner&apos;; // 作用于整个 function</div><div class="line">    return x;</div><div class="line">  &#125;</div><div class="line">  return x; // 因为第四行的声明提升，被重新定义</div><div class="line">&#125;</div><div class="line">test(false); // undefined 😱</div><div class="line">test(true); // inner</div></pre></td></tr></table></figure>
<p>对于 <code>test(fasle)</code> ，你期望返回 <code>outer</code>，<strong>但是</strong>，你得到的是 <code>undefined</code>。</p>
<p>为什么？</p>
<p>因为尽管没有执行 <code>if</code> 代码块，第四行中的表达式 <code>var x</code> 也会被提升。</p>
<blockquote>
<p>var <strong>提升</strong>：</p>
<ul>
<li><code>var</code> 是函数作用域。在整个函数中甚至是声明语句之前都是可用的。</li>
<li>声明被提升。所以你能在声明之前使用一个变量。</li>
<li>初始化是不被提升的。如果你使用 <code>var</code> 声明变量，请总是将它放在顶部。</li>
<li>在应用了声明提升规则之后，我们就能更容易地理解发生了什么：</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">var x = &apos;outer&apos;;</div><div class="line">function test(inner) &#123;</div><div class="line">    var x; // 声明提升</div><div class="line">    if (inner) &#123;</div><div class="line">        x = &apos;inner&apos;; // 初始化不被提升</div><div class="line">        return x;</div><div class="line">    &#125;</div><div class="line">    return x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre></blockquote>
<p>ECMAScript 2015 找到了解决的办法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">let x = &apos;outer&apos;;</div><div class="line">function test(inner) &#123;</div><div class="line">  if (inner) &#123;</div><div class="line">    let x = &apos;inner&apos;;</div><div class="line">    return x;</div><div class="line">  &#125;</div><div class="line">  return x; // 从第一行获取到预期结果</div><div class="line">&#125;</div><div class="line">test(false); // outer</div><div class="line">test(true); // inner</div></pre></td></tr></table></figure>
<p>将 <code>var</code> 改为 <code>let</code>，代码将像期望的那样运行。如果 <code>if</code> 代码块没有被调用，<code>x</code> 变量也就不会在代码块外被提升。</p>
<blockquote>
<p>let <strong>提升</strong> 和“暂存死区（temporal dead zone）”</p>
<ul>
<li>在 ES6 中，<code>let</code> 将变量提升到代码块的顶部（不是像 ES5 那样的函数顶部）。</li>
<li>然而，代码块中，在变量声明之前引用它会导致 <code>ReferenceError</code> 错误。</li>
<li><code>let</code> 是块级作用域。你不能在它被声明之前引用它。</li>
<li>“暂存死区（Temporal dead zone）”是指从代码块开始直到变量被声明之间的区域。</li>
</ul>
</blockquote>
<p><strong>IIFE</strong></p>
<p>在解释 IIFE 之前让我们看一个例子。来看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">&#123;</div><div class="line">  var private = 1;</div><div class="line">&#125;</div><div class="line">console.log(private); // 1</div></pre></td></tr></table></figure>
<p>如你所见，<code>private</code> 漏出(代码块)。你需要使用 IIFE（immediately-invoked function expression，立即执行函数表达式）来包含它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">(function()&#123;</div><div class="line">  var private2 = 1;</div><div class="line">&#125;)();</div><div class="line">console.log(private2); // Uncaught ReferenceError</div></pre></td></tr></table></figure>
<p>如果你看一看 jQuery/loadsh 或其他开源项目，你会注意到他们用 IIFE 来避免污染全局环境而且只在全局中定义了诸如 <code>_</code>，<code>$</code>和<code>jQuery</code>。</p>
<p>在 ES6 上则一目了然，我们可以只用代码块和 <code>let</code>，也不再需要使用 IIFE了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">&#123;</div><div class="line">  let private3 = 1;</div><div class="line">&#125;</div><div class="line">console.log(private3); // Uncaught ReferenceError</div></pre></td></tr></table></figure>
<p><strong>Const</strong></p>
<p>如果你想要一个变量保持不变（常量），你也可以使用 <code>const</code>。</p>
<p><img src="http://adrianmejia.com/images/javascript-es6-const-variables-example.png" alt="" title="const variable example"></p>
<blockquote>
<p>总之：用 <code>let</code>，<code>const</code> 而不是 <code>var</code></p>
<ul>
<li>对所有引用使用 <code>const</code>；避免使用 <code>var</code>。</li>
<li>如果你必须重新指定引用，用 <code>let</code> 替代 <code>const</code>。</li>
</ul>
</blockquote>
<h4 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h4><p>有了模板字面量，我们就不用做多余的嵌套拼接了。来看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">var first = &apos;Adrian&apos;;</div><div class="line">var last = &apos;Mejia&apos;;</div><div class="line">console.log(&apos;Your name is &apos; + first + &apos; &apos; + last + &apos;.&apos;);</div></pre></td></tr></table></figure>
<p>现在你可以使用反引号 (`) 和字符串插值 <code>${}</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">const first = &apos;Adrian&apos;;</div><div class="line">const last = &apos;Mejia&apos;;</div><div class="line">console.log(`Your name is $&#123;first&#125; $&#123;last&#125;.`);</div></pre></td></tr></table></figure>
<h4 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h4><p>我们再也不需要添加 + <code>\n</code> 来拼接字符串了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">var template = &apos;&lt;li *ngFor=&quot;let todo of todos&quot; [ngClass]=&quot;&#123;completed: todo.isDone&#125;&quot; &gt;\n&apos; +</div><div class="line">&apos;  &lt;div class=&quot;view&quot;&gt;\n&apos; +</div><div class="line">&apos;    &lt;input class=&quot;toggle&quot; type=&quot;checkbox&quot; [checked]=&quot;todo.isDone&quot;&gt;\n&apos; +</div><div class="line">&apos;    &lt;label&gt;&lt;/label&gt;\n&apos; +</div><div class="line">&apos;    &lt;button class=&quot;destroy&quot;&gt;&lt;/button&gt;\n&apos; +</div><div class="line">&apos;  &lt;/div&gt;\n&apos; +</div><div class="line">&apos;  &lt;input class=&quot;edit&quot; value=&quot;&quot;&gt;\n&apos; +</div><div class="line">&apos;&lt;/li&gt;&apos;;</div><div class="line">console.log(template);</div></pre></td></tr></table></figure>
<p>在 ES6 上， 我们可以同样使用反引号来解决这个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">const template = `&lt;li *ngFor=&quot;let todo of todos&quot; [ngClass]=&quot;&#123;completed: todo.isDone&#125;&quot; &gt;</div><div class="line">  &lt;div class=&quot;view&quot;&gt;</div><div class="line">    &lt;input class=&quot;toggle&quot; type=&quot;checkbox&quot; [checked]=&quot;todo.isDone&quot;&gt;</div><div class="line">    &lt;label&gt;&lt;/label&gt;</div><div class="line">    &lt;button class=&quot;destroy&quot;&gt;&lt;/button&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">  &lt;input class=&quot;edit&quot; value=&quot;&quot;&gt;</div><div class="line">&lt;/li&gt;`;</div><div class="line">console.log(template);</div></pre></td></tr></table></figure>
<p>两段代码的结果是完全一样的。</p>
<h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>ES6 的解构不仅实用而且很简洁。如下例所示：</p>
<p><strong>从数组中获取元素</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">var array = [1, 2, 3, 4];</div><div class="line">var first = array[0];</div><div class="line">var third = array[2];</div><div class="line">console.log(first, third); // 1 3</div></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const array = [1, 2, 3, 4];</div><div class="line">const [first, ,third] = array;</div><div class="line">console.log(first, third); // 1 3</div></pre></td></tr></table></figure>
<p><strong>交换值</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">var a = 1;</div><div class="line">var b = 2;</div><div class="line">var tmp = a;</div><div class="line">a = b;</div><div class="line">b = tmp;</div><div class="line">console.log(a, b); // 2 1</div></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">let a = 1;</div><div class="line">let b = 2;</div><div class="line">[a, b] = [b, a];</div><div class="line">console.log(a, b); // 2 1</div></pre></td></tr></table></figure>
<p><strong>多个返回值的解构</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">function margin() &#123;</div><div class="line">  var left=1, right=2, top=3, bottom=4;</div><div class="line">  return &#123; left: left, right: right, top: top, bottom: bottom &#125;;</div><div class="line">&#125;</div><div class="line">var data = margin();</div><div class="line">var left = data.left;</div><div class="line">var bottom = data.bottom;</div><div class="line">console.log(left, bottom); // 1 4</div></pre></td></tr></table></figure>
<p>在第 3 行中，你也可以用一个像这样的数组返回（同时省去了一些编码）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return [left, right, top, bottom];</div></pre></td></tr></table></figure>
<p>但另一方面，调用者需要考虑返回数据的顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var left = data[0];</div><div class="line">var bottom = data[3];</div></pre></td></tr></table></figure>
<p>用 ES6，调用者只需选择他们需要的数据即可（第 6 行）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line"></div><div class="line">function margin() &#123;</div><div class="line">  const left=1, right=2, top=3, bottom=4;</div><div class="line">  return &#123; left, right, top, bottom &#125;;</div><div class="line">&#125;</div><div class="line">const &#123; left, bottom &#125; = margin();</div><div class="line">console.log(left, bottom); // 1 4</div></pre></td></tr></table></figure>
<p><em>注意：</em> 在第 3 行中，我们使用了一些其他的 ES6 功能。我们将 <code>{ left: left }</code> 简化到只有 <code>{ left }</code>。与 ES5 版本相比，它变得如此简洁。酷不酷？</p>
<p><strong>参数匹配的解构</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">var user = &#123;firstName: &apos;Adrian&apos;, lastName: &apos;Mejia&apos;&#125;;</div><div class="line">function getFullName(user) &#123;</div><div class="line">  var firstName = user.firstName;</div><div class="line">  var lastName = user.lastName;</div><div class="line">  return firstName + &apos; &apos; + lastName;</div><div class="line">&#125;</div><div class="line">console.log(getFullName(user)); // Adrian Mejia</div></pre></td></tr></table></figure>
<p>等同于（但更简洁）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">const user = &#123;firstName: &apos;Adrian&apos;, lastName: &apos;Mejia&apos;&#125;;</div><div class="line">function getFullName(&#123; firstName, lastName &#125;) &#123;</div><div class="line">  return `$&#123;firstName&#125; $&#123;lastName&#125;`;</div><div class="line">&#125;</div><div class="line">console.log(getFullName(user)); // Adrian Mejia</div></pre></td></tr></table></figure>
<p><strong>深度匹配</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">function settings() &#123;</div><div class="line">  return &#123; display: &#123; color: &apos;red&apos; &#125;, keyboard: &#123; layout: &apos;querty&apos;&#125; &#125;;</div><div class="line">&#125;</div><div class="line">var tmp = settings();</div><div class="line">var displayColor = tmp.display.color;</div><div class="line">var keyboardLayout = tmp.keyboard.layout;</div><div class="line">console.log(displayColor, keyboardLayout); // red querty</div></pre></td></tr></table></figure>
<p>等同于（但更简洁）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">function settings() &#123;</div><div class="line">  return &#123; display: &#123; color: &apos;red&apos; &#125;, keyboard: &#123; layout: &apos;querty&apos;&#125; &#125;;</div><div class="line">&#125;</div><div class="line">const &#123; display: &#123; color: displayColor &#125;, keyboard: &#123; layout: keyboardLayout &#125;&#125; = settings();</div><div class="line">console.log(displayColor, keyboardLayout); // red querty</div></pre></td></tr></table></figure>
<p>这也称作对象的解构。</p>
<p>如你所见，解构是非常实用的而且有利于促进良好的编码风格。</p>
<blockquote>
<p>最佳实践:</p>
<ul>
<li>使用数组解构去获取元素或交换值。它可以避免创建临时引用。</li>
<li>不要对多个返回值使用数组解构，而是要用对象解构。</li>
</ul>
</blockquote>
<h4 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h4><p>用 ECMAScript 6，我们从“构造函数”🔨 来到了“类”🍸。</p>
<blockquote>
<p>在 JavaScript 中，每个对象都有一个原型对象。所有的 JavaScript 对象都从它们的原型对象那里继承方法和属性。</p>
</blockquote>
<p>在 ES5 中，为了实现面向对象编程（OOP），我们使用构造函数来创建对象，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">var Animal = (function () &#123;</div><div class="line">  function MyConstructor(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">  &#125;</div><div class="line">  MyConstructor.prototype.speak = function speak() &#123;</div><div class="line">    console.log(this.name + &apos; makes a noise.&apos;);</div><div class="line">  &#125;;</div><div class="line">  return MyConstructor;</div><div class="line">&#125;)();</div><div class="line">var animal = new Animal(&apos;animal&apos;);</div><div class="line">animal.speak(); // animal makes a noise.</div></pre></td></tr></table></figure></p>
<p>ES6 中有了一些语法糖。通过像 <code>class</code> 和 <code>constructor</code> 这样的关键字和减少样板代码，我们可以做到同样的事情。另外，<code>speak()</code> 相对照 <code>constructor.prototype.speak = function ()</code>  更加清晰：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">class Animal &#123;</div><div class="line">  constructor(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">  &#125;</div><div class="line">  speak() &#123;</div><div class="line">    console.log(this.name + &apos; makes a noise.&apos;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">const animal = new Animal(&apos;animal&apos;);</div><div class="line">animal.speak(); // animal makes a noise.</div></pre></td></tr></table></figure>
<p>正如你所见，两种式样（ES5 与 6）在幕后产生相同的结果而且用法一致。</p>
<blockquote>
<p>最佳实践：</p>
<ul>
<li>总是使用 <code>class</code> 语法并避免直接直接操纵 <code>prototype</code>。为什么？因为它让代码更加简洁和易于理解。</li>
<li>避免使用空的构造函数。如果没有指定，类有一个默认的构造函数。</li>
</ul>
</blockquote>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>基于前面的 <code>Animal</code> 类。 让我们扩展它并定义一个 <code>Lion</code> 类。</p>
<p>在 ES5 中，它更多的与原型继承有关。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">var Lion = (function () &#123;</div><div class="line">  function MyConstructor(name)&#123;</div><div class="line">    Animal.call(this, name);</div><div class="line">  &#125;</div><div class="line">  // 原型继承</div><div class="line">  MyConstructor.prototype = Object.create(Animal.prototype);</div><div class="line">  MyConstructor.prototype.constructor = Animal;</div><div class="line">  MyConstructor.prototype.speak = function speak() &#123;</div><div class="line">    Animal.prototype.speak.call(this);</div><div class="line">    console.log(this.name + &apos; roars 🦁&apos;);</div><div class="line">  &#125;;</div><div class="line">  return MyConstructor;</div><div class="line">&#125;)();</div><div class="line">var lion = new Lion(&apos;Simba&apos;);</div><div class="line">lion.speak(); // Simba makes a noise.</div><div class="line">// Simba roars.</div></pre></td></tr></table></figure>
<p>我不会重复所有的细节，但请注意：</p>
<ul>
<li>第 3 行中，我们添加参数显式调用了 <code>Animal</code> 构造函数。</li>
<li>第 7-8 行，我们将 <code>Lion</code> 原型指派给 <code>Animal</code> 原型。</li>
<li>第 11行中，我们调用了父类 <code>Animal</code> 的 <code>speak</code> 方法。</li>
</ul>
<p>在 ES6 中，我们有了新关键词 <code>extends</code> 和 <code>super</code> <img src="http://adrianmejia.com/images/superman_shield.svg" width="25" height="25" alt="superman shield" style="display:inline-block;" data-pin-nopin="true">。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">class Lion extends Animal &#123;</div><div class="line">  speak() &#123;</div><div class="line">    super.speak();</div><div class="line">    console.log(this.name + &apos; roars 🦁&apos;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">const lion = new Lion(&apos;Simba&apos;);</div><div class="line">lion.speak(); // Simba makes a noise.</div><div class="line">// Simba roars.</div></pre></td></tr></table></figure>
<p>虽然 ES6 和 ES5 的代码作用一致，但是 ES6 的代码显得更易读。更胜一筹！</p>
<blockquote>
<p>最佳实践：</p>
<ul>
<li>使用  <code>extends</code> 内置方法实现继承。</li>
</ul>
</blockquote>
<h4 id="原生-Promises"><a href="#原生-Promises" class="headerlink" title="原生 Promises"></a>原生 Promises</h4><p>从回调地狱 👹 到 promises 🙏。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">function printAfterTimeout(string, timeout, done)&#123;</div><div class="line">  setTimeout(function()&#123;</div><div class="line">    done(string);</div><div class="line">  &#125;, timeout);</div><div class="line">&#125;</div><div class="line">printAfterTimeout(&apos;Hello &apos;, 2e3, function(result)&#123;</div><div class="line">  console.log(result);</div><div class="line">  // 嵌套回调</div><div class="line">  printAfterTimeout(result + &apos;Reader&apos;, 2e3, function(result)&#123;</div><div class="line">    console.log(result);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>我们有一个接收一个回调的函数，当 <code>done</code> 时执行。我们必须一个接一个地执行它两次。这也是为什么我们在回调中第二次调用  <code>printAfterTimeout</code> 的原因。</p>
<p>如果你需要第 3 次或第 4 次回调，可能很快就会变得混乱。来看看我们用 promises 的写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">function printAfterTimeout(string, timeout)&#123;</div><div class="line">  return new Promise((resolve, reject) =&gt; &#123;</div><div class="line">    setTimeout(function()&#123;</div><div class="line">      resolve(string);</div><div class="line">    &#125;, timeout);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line">printAfterTimeout(&apos;Hello &apos;, 2e3).then((result) =&gt; &#123;</div><div class="line">  console.log(result);</div><div class="line">  return printAfterTimeout(result + &apos;Reader&apos;, 2e3);</div><div class="line">&#125;).then((result) =&gt; &#123;</div><div class="line">  console.log(result);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如你所见，使用 promises 我们能在函数完成后进行一些操作。不再需要嵌套函数。</p>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>ES6 没有移除函数表达式，但是新增了一种，叫做箭头函数。</p>
<p>在 ES5 中，对于 <code>this</code> 我们有一些问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">var _this = this; // 保持一个引用</div><div class="line">$(&apos;.btn&apos;).click(function(event)&#123;</div><div class="line">  _this.sendData(); // 引用的是外层的 this</div><div class="line">&#125;);</div><div class="line">$(&apos;.input&apos;).on(&apos;change&apos;,function(event)&#123;</div><div class="line">  this.sendData(); // 引用的是外层的 this</div><div class="line">&#125;.bind(this)); // 绑定到外层的 this</div></pre></td></tr></table></figure>
<p>你需要使用一个临时的 <code>this</code> 在函数内部进行引用或用 <code>bind</code> 绑定。在 ES6 中，你可以用箭头函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">// 引用的是外部的那个 this</div><div class="line">$(&apos;.btn&apos;).click((event) =&gt;  this.sendData());</div><div class="line">// 隐式返回</div><div class="line">const ids = [291, 288, 984];</div><div class="line">const messages = ids.map(value =&gt; `ID is $&#123;value&#125;`);</div></pre></td></tr></table></figure>
<h4 id="For…of"><a href="#For…of" class="headerlink" title="For…of"></a>For…of</h4><p>从 <code>for</code> 到 <code>forEach</code> 再到 <code>for...of</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">// for</div><div class="line">var array = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;];</div><div class="line">for (var i = 0; i &lt; array.length; i++) &#123;</div><div class="line">  var element = array[i];</div><div class="line">  console.log(element);</div><div class="line">&#125;</div><div class="line">// forEach</div><div class="line">array.forEach(function (element) &#123;</div><div class="line">  console.log(element);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>ES6 的 for…of 同样可以实现迭代。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">// for ...of</div><div class="line">const array = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;];</div><div class="line">for (const element of array) &#123;</div><div class="line">    console.log(element);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>从检查一个变量是否被定义到重新指定一个值再到 <code>default parameters</code>。<br>你以前写过类似这样的代码吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">function point(x, y, isFlag)&#123;</div><div class="line">  x = x || 0;</div><div class="line">  y = y || -1;</div><div class="line">  isFlag = isFlag || true;</div><div class="line">  console.log(x,y, isFlag);</div><div class="line">&#125;</div><div class="line">point(0, 0) // 0 -1 true 😱</div><div class="line">point(0, 0, false) // 0 -1 true 😱😱</div><div class="line">point(1) // 1 -1 true</div><div class="line">point() // 0 -1 true</div></pre></td></tr></table></figure>
<p>可能有过，这是一种检查变量是否赋值的常见模式，不然则分配一个默认值。然而，这里有一些问题：</p>
<ul>
<li>第 8 行中，我们传入 <code>0, 0</code> 返回了 <code>0, -1</code>。</li>
<li>第 9 行中， 我们传入 <code>false</code> 但是返回了 <code>true</code>。</li>
</ul>
<p>如果你传入一个布尔值作为默认参数或将值设置为 0，它不能正常起作用。你知道为什么吗？在讲完 ES6 示例后我会告诉你。</p>
<p>用 ES6，现在你可以用更少的代码做到更好！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">function point(x = 0, y = -1, isFlag = true)&#123;</div><div class="line">  console.log(x,y, isFlag);</div><div class="line">&#125;</div><div class="line">point(0, 0) // 0 0 true</div><div class="line">point(0, 0, false) // 0 0 false</div><div class="line">point(1) // 1 -1 true</div><div class="line">point() // 0 -1 true</div></pre></td></tr></table></figure>
<p>请注意第 5 行和第 6 行，我们得到了预期的结果。ES5 示例则无效。首先检查是否等于 <code>undefined</code>，因为 <code>false</code>，<code>null</code>，<code>undefined</code> 和 <code>0</code> 都是假值，我们可以避开这些数字，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">function point(x, y, isFlag)&#123;</div><div class="line">  x = x || 0;</div><div class="line">  y = typeof(y) === &apos;undefined&apos; ? -1 : y;</div><div class="line">  isFlag = typeof(isFlag) === &apos;undefined&apos; ? true : isFlag;</div><div class="line">  console.log(x,y, isFlag);</div><div class="line">&#125;</div><div class="line">point(0, 0) // 0 0 true</div><div class="line">point(0, 0, false) // 0 0 false</div><div class="line">point(1) // 1 -1 true</div><div class="line">point() // 0 -1 true</div></pre></td></tr></table></figure>
<p>当我们检查是否为 <code>undefined</code> 后，获得了期望的结果。</p>
<h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>从参数到剩余参数和扩展操作符。</p>
<p>在 ES5 中，获取任意数量的参数是非常麻烦的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">function printf(format) &#123;</div><div class="line">  var params = [].slice.call(arguments, 1);</div><div class="line">  console.log(&apos;params: &apos;, params);</div><div class="line">  console.log(&apos;format: &apos;, format);</div><div class="line">&#125;</div><div class="line">printf(&apos;%s %d %.2f&apos;, &apos;adrian&apos;, 321, Math.PI);</div></pre></td></tr></table></figure>
<p>我们可以用 rest 操作符 <code>...</code> 做到同样的事情。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line"></div><div class="line">function printf(format, ...params) &#123;</div><div class="line">  console.log(&apos;params: &apos;, params);</div><div class="line">  console.log(&apos;format: &apos;, format);</div><div class="line">&#125;</div><div class="line">printf(&apos;%s %d %.2f&apos;, &apos;adrian&apos;, 321, Math.PI);</div></pre></td></tr></table></figure>
<h4 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h4><p>从 <code>apply()</code> 到展开运算符。我们同样用 <code>...</code> 来解决：</p>
<blockquote>
<p>提醒：我们使用 <code>apply()</code> 将数组转换为一列参数。例如，<code>Math.max()</code> 作用于一列参数，但是如果我们有一个数组，我们就能用 <code>apply</code> 让它生效。</p>
</blockquote>
<p><img src="http://adrianmejia.com/images/javascript-math-apply-arrays.png" alt="" title="JavaScript Math apply for arrays"></p>
<p>正如我们较早之前看过的，我们可以使用 <code>apply</code> 将数组作为参数列表传递：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">Math.max.apply(Math, [2,100,1,6,43]) // 100</div></pre></td></tr></table></figure>
<p>在 ES6 中，你可以用展开运算符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">Math.max(...[2,100,1,6,43]) // 100</div></pre></td></tr></table></figure>
<p>同样，从 <code>concat</code> 数组到使用展开运算符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">var array1 = [2,100,1,6,43];</div><div class="line">var array2 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;];</div><div class="line">var array3 = [false, true, null, undefined];</div><div class="line">console.log(array1.concat(array2, array3));</div></pre></td></tr></table></figure>
<p>在 ES6 中，你可以用展开运算符来压平嵌套：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">const array1 = [2,100,1,6,43];</div><div class="line">const array2 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;];</div><div class="line">const array3 = [false, true, null, undefined];</div><div class="line">console.log([...array1, ...array2, ...array3]);</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>JavaScript 经历了相当多的修改。这篇文章涵盖了每个 JavaScript 开发者都应该了解的大多数核心功能。同样，我们也介绍了一些让你的代码更加简洁，易于理解的最佳实践。</p>
<p>如果你认为还有一些没有提到的<strong>必知</strong>的功能，请在下方留言，我会更新这篇文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本文属于转载文章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;http://adrianmejia.com/blog/2016/10/19/Overview-of-JavaScript-ES6-features-a-k-a-ECMAScript-6-and-ES2015/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Overview of JavaScript ES6 features (a.k.a ECMAScript 6 and ES2015+)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文作者：&lt;a href=&quot;http://adrianmejia.com/#about&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Adrian Mejia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译文出自：&lt;a href=&quot;https://github.com/xitu/gold-miner&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;掘金翻译计划&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译者：&lt;a href=&quot;https://github.com/L9m&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;L9m&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;校对者：&lt;a href=&quot;https://github.com/Tina92&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Tina92&lt;/a&gt;，&lt;a href=&quot;https://github.com/luoyaqifei&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;luoyaqifei&lt;/a&gt;，&lt;a href=&quot;https://github.com/theJian&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;theJian&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
      <category term="转载" scheme="http://damonare.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="ES6" scheme="http://damonare.github.io/tags/ES6/"/>
    
  </entry>
  
</feed>
